[
  {
    "id": 1,
    "question": "Powłoka (ang. shell) w systemie UNIX jest odpowiedzialna za...",
    "options": [
      {
        "text": "wykonywanie niektórych wbudowanych podstawowych komend (komendy nie wbudowane są wywoływane przez powłokę jako programy zewnętrzne)",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "bezpośrednie zarządzanie przydziałem czasu procesora dla uruchomionych procesów",
        "inline_explanation": "(to zadanie planisty/schedulera w jądrze)",
        "correct": false
      },
      {
        "text": "tylko i wyłącznie wyświetlanie graficznego interfejsu użytkownika",
        "inline_explanation": "(shell to przede wszystkim CLI, choć może uruchamiać GUI)",
        "correct": false
      },
      {
        "text": "kompilację kodu źródłowego jądra w czasie rzeczywistym przed każdym uruchomieniem komendy",
        "inline_explanation": "(shell jest interpreterem, a nie kompilatorem; jądro jest już skompilowanym kodem binarnym)",
        "correct": false
      },
      {
        "text": "obsługę przekierowań strumieni wejścia/wyjścia oraz mechanizmu potoków (łączenie programów znakiem |)",
        "inline_explanation": "(to jedna z kluczowych funkcji powłoki, pozwalająca na tworzenie złożonych poleceń)",
        "correct": true
      }
    ],
    "explanation": "Powłoka (shell) to program systemowy, który pełni rolę pośrednika między użytkownikiem a jądrem systemu operacyjnego (kernelem). Jest to interpreter poleceń. Kiedy wpisujesz komendę w terminalu, shell ją analizuje (parsowanie) i decyduje, jak ją wykonać. Kluczowym rozróżnieniem jest tutaj podział na komendy wbudowane (built-in, np. cd, echo), które shell wykonuje sam, oraz zewnętrzne (programy w /bin), które uruchamia. Dodatkowo shell zarządza środowiskiem pracy (zmienne środowiskowe), obsługuje historię poleceń oraz pozwala na sterowanie przepływem danych między procesami (potoki i przekierowania). Nie zajmuje się jednak bezpośrednim zarządzaniem sprzętem (np. czasem procesora), co jest wyłącznym zadaniem jądra."
  },
  {
    "id": 2,
    "question": "Przeciążenie (przeładowanie) operatorów w języku C++ pozwala...",
    "options": [
      {
        "text": "dodać do siebie obiekty dwóch różnych klas np. wektor i liczbę zespoloną",
        "inline_explanation": "(to kluczowa zaleta, pozwalająca na intuicyjne operacje matematyczne na własnych typach danych)",
        "correct": true
      },
      {
        "text": "zdefiniować własne zachowanie dla operatorów wejścia/wyjścia (<< i >>)",
        "inline_explanation": "(dzięki temu można wypisywać całe obiekty na ekran instrukcją cout << obiekt, zamiast tworzyć metody print)",
        "correct": true
      },
      {
        "text": "zmieniać priorytety wykonywania operatorów matematycznych",
        "inline_explanation": "(priorytety są ściśle zdefiniowane w gramatyce języka i są niezmienne dla wszystkich typów)",
        "correct": false
      },
      {
        "text": "tworzyć zupełnie nowe symbole operatorów, które nie istnieją w języku (np. ** dla potęgowania)",
        "inline_explanation": "(można przeciążać tylko te operatory, które już istnieją w składni C++, np. +, -, *, /)",
        "correct": false
      },
      {
        "text": "zmieniać liczarność argumentów operatora (np. sprawić, by operator jednoargumentowy ! przyjmował dwa argumenty)",
        "inline_explanation": "(arność operatora jest stała - operator jednoargumentowy zawsze musi działać na jednym argumencie)",
        "correct": false
      }
    ],
    "explanation": "Przeciążanie operatorów (operator overloading) to mechanizm polimorfizmu statycznego, który pozwala nadać nowe znaczenie standardowym operatorom (np. +, -, <<) w odniesieniu do typów zdefiniowanych przez użytkownika. Głównym celem jest zwiększenie czytelności kodu (np. dodawanie macierzy znakiem + zamiast funkcją addMatrix). Istnieją jednak sztywne ograniczenia: nie można zmieniać priorytetów operatorów, ich łączności (lewo/prawostronnej), liczby argumentów (arności) ani tworzyć nowych symboli (jak ** czy <->). Nie można też zmieniać działania operatorów dla typów wbudowanych (np. nie można zmienić znaczenia 2 + 2)."
  },
  {
    "id": 3,
    "question": "Wymień zasoby, które w systemach UNIXowych mogą mieć pełną reprezentację w postaci pliku (np. w wirtualnym systemie plików /proc albo /dev).",
    "options": [
      {
        "text": "partycja dyskowa, pamięć RAM, karta sieciowa (NIC), parametry uruchomionych procesów",
        "inline_explanation": "(wszystkie te zasoby są mapowane na pliki w katalogach /dev, /proc lub /sys)",
        "correct": true
      },
      {
        "text": "wyłącznie pliki tekstowe i binarne zapisane na fizycznym dysku twardym",
        "inline_explanation": "(taka definicja jest błędna, bo w Unixie plikami są również urządzenia, potoki i gniazda)",
        "correct": false
      },
      {
        "text": "rejestry procesora dostępne bezpośrednio jako pliki do edycji w notatniku",
        "inline_explanation": "(rejestry to wewnętrzne komórki CPU o ogromnej szybkości; system nie udostępnia ich jako plików w /dev)",
        "correct": false
      },
      {
        "text": "tylko urządzenia peryferyjne podłączane przez USB, ale nie komponenty wewnętrzne jak RAM",
        "inline_explanation": "(pamięć RAM również jest dostępna jako plik, zazwyczaj pod ścieżką /dev/mem)",
        "correct": false
      },
      {
        "text": "terminal (TTY), generator liczb losowych, dysk twardy, informacje o modelu procesora",
        "inline_explanation": "(odpowiednio: /dev/tty, /dev/random, /dev/sda, /proc/cpuinfo)",
        "correct": true
      },
      {
        "text": "partycja dyskowa, pamięć RAM, pamięć podręczna procesora (L1 Cache), rejestry sterujące",
        "inline_explanation": "(cache L1 i rejestry sterujące są zarządzane sprzętowo i nie są widoczne jako pliki w systemie plików)",
        "correct": false
      }
    ],
    "explanation": "Filozofia systemów UNIX brzmi: \"Wszystko jest plikiem\" (Everything is a file). Oznacza to, że system operacyjny udostępnia jednolity interfejs plikowy (open, read, write, close) do obsługi sprzętu i danych systemowych. Katalog /dev zawiera pliki urządzeń (np. /dev/sda dla dysku, /dev/mem dla RAM, /dev/tty dla terminala, /dev/random dla entropii). Katalog /proc to wirtualny system plików mapujący stan jądra (np. /proc/cpuinfo) i procesów. Nie wszystko jednak jest plikiem - wyjątkiem są m.in. niskopoziomowe zasoby CPU jak rejestry czy pamięć cache L1/L2, do których dostęp ma tylko procesor/kernel."
  },
  {
    "id": 4,
    "question": "Wskaż instrukcje sterujące w języku C/C++.",
    "options": [
      {
        "text": "`if( ... ){ ... }`",
        "inline_explanation": "(podstawowa instrukcja warunkowa)",
        "correct": true
      },
      {
        "text": "`switch( ... ) { ... }`",
        "inline_explanation": "(instrukcja wyboru wielowariantowego)",
        "correct": true
      },
      {
        "text": "`for(int i=0; i<n; i++) { ... }`",
        "inline_explanation": "(pętla - instrukcja iteracyjna)",
        "correct": true
      },
      {
        "text": "`return 0;`",
        "inline_explanation": "(instrukcja skoku - powrót z funkcji)",
        "correct": true
      },
      {
        "text": "`break;`",
        "inline_explanation": "(instrukcja skoku - przerwanie pętli lub switcha)",
        "correct": true
      },
      {
        "text": "`int a = 5;`",
        "inline_explanation": "(to jest deklaracja i inicjalizacja zmiennej)",
        "correct": false
      },
      {
        "text": "`#include <stdio.h>`",
        "inline_explanation": "(to dyrektywa preprocesora, przetwarzana przed właściwą kompilacją)",
        "correct": false
      },
      {
        "text": "`a + b;`",
        "inline_explanation": "(to wyrażenie arytmetyczne, a nie instrukcja sterująca przepływem)",
        "correct": false
      }
    ],
    "explanation": "Instrukcje sterujące (control flow statements) decydują o kolejności wykonywania poleceń w programie. Pozwalają na warunkowe wykonanie kodu lub jego powtarzanie.\nDo podstawowych instrukcji sterujących należą:\n⚫instrukcje warunkowe (`if`, `if...else`, `switch`),\n⚫pętle (`for`, `while`, `do...while`),\n⚫instrukcje skoku (`break`, `continue`, `return`, `goto`).\nDeklaracje zmiennych (np. `int a`) i dyrektywy preprocesora (zaczynające się od `#`) nie sterują przepływem programu w czasie jego działania."
  },
  {
    "id": 5,
    "question": "Operator widoczności `protected` dla pola składowego klasy bazowej oznacza że:",
    "options": [
      {
        "text": "pole to jest niedostępne dla klasy bazowej ale widoczne w klasie pochodnej",
        "inline_explanation": "(klasa bazowa zawsze ma dostęp do własnych pól, niezależnie od modyfikatora)",
        "correct": false
      },
      {
        "text": "pole to jest dostępne dla metod klasy bazowej oraz metod klas pochodnych, ale niedostępne dla obiektów z zewnątrz",
        "inline_explanation": "(to jest dokładnie definicja modyfikatora protected w C++)",
        "correct": true
      },
      {
        "text": "pole to jest widoczne publicznie dla wszystkich funkcji w programie",
        "inline_explanation": "(to definicja `public`)",
        "correct": false
      },
      {
        "text": "pole to jest dostępne tylko i wyłącznie dla klasy bazowej",
        "inline_explanation": "(to definicja `private`)",
        "correct": false
      }
    ],
    "explanation": "Pola `protected` są widoczne w klasie, która je zdefiniowała (bazowej) ORAZ w klasach, które po niej dziedziczą (pochodnych). Są ukryte przed światem zewnętrznym (np. funkcją main). Twierdzenie, że klasa bazowa nie ma dostępu do własnego pola protected, jest fałszywe."
  },
  {
    "id": 6,
    "question": "Komunikatem w systemie UNIX (kolejki komunikatów System V) może być:",
    "options": [
      {
        "text": "dowolna struktura danych, przy czym pierwsza zmienna w strukturze musi być typu long",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "wyłącznie ciąg znaków (string) zakończony znakiem null",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "dowolna liczba całkowita typu int przesyłana przez potok",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "wskaźnik do pamięci współdzielonej, który musi być pierwszą zmienną",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "W kolejkach komunikatów System V ({msgsnd}, {msgrcv}) komunikat jest strukturą. System operacyjny wymaga, aby pierwszym elementem tej struktury był {long mtype} (typ komunikatu), który służy do filtrowania wiadomości. Reszta struktury zależy od programisty."
  },
  {
    "id": 6,
    "question": "Komunikatem w systemie UNIX (kolejki komunikatów System V) może być:",
    "options": [
      {
        "text": "dowolna struktura danych, przy czym pierwsza zmienna w strukturze musi być typu `long`",
        "inline_explanation": "(ten typ `long mtype` służy do identyfikacji i filtrowania komunikatów przy odbiorze)",
        "correct": true
      },
      {
        "text": "struktura zdefiniowana przez użytkownika, rozpoczynająca się od pola `long mtype`, po którym następują dowolne dane",
        "inline_explanation": "(to definicja zgodna ze standardem funkcji `msgsnd`)",
        "correct": true
      },
      {
        "text": "wyłącznie ciąg znaków (string) zakończony znakiem null",
        "inline_explanation": "(kolejki mogą przesyłać dowolne dane binarne, nie tylko tekst)",
        "correct": false
      },
      {
        "text": "dowolna liczba całkowita typu `int` przesyłana przez potok",
        "inline_explanation": "(potoki to strumienie bajtów, a nie kolejki komunikatów; kolejki wymagają struktury)",
        "correct": false
      },
      {
        "text": "wskaźnik do pamięci współdzielonej, który musi być pierwszą zmienną",
        "inline_explanation": "(pierwszą zmienną musi być typ wiadomości; przesyłanie samych wskaźników między procesami jest też błędem logicznym ze względu na różne przestrzenie adresowe)",
        "correct": false
      }
    ],
    "explanation": "W mechanizmie kolejek komunikatów System V (funkcje `msgsnd`, `msgrcv`) komunikat nie jest surowym strumieniem bajtów, lecz strukturą. System operacyjny narzuca jeden wymóg: pierwszym polem tej struktury musi być liczba całkowita typu `long` (często nazywana `mtype`). Służy ona do nadawania priorytetów lub typów wiadomościom, co pozwala na ich wybiórcze odbieranie (np. 'odbierz tylko komunikaty typu 1'). Pozostała część struktury jest całkowicie dowolna i zależy od definicji programisty."
  },
  {
    "id": 8,
    "question": "Ile interfejsów sieciowych można utworzyć na jednym interfejsie fizycznym?",
    "options": [
      {
        "text": "zależnie od użytej maski podsieci",
        "inline_explanation": "(maska określa wielkość sieci logicznej, a nie limit liczby interfejsów w systemie)",
        "correct": false
      },
      {
        "text": "wiele (teoretycznie liczba nieograniczona, w praktyce ograniczona zasobami systemu operacyjnego)",
        "inline_explanation": "(limitują nas tylko zasoby RAM/CPU i limity kernela/sterownika)",
        "correct": true
      },
      {
        "text": "dokładnie jeden wirtualny interfejs na jeden fizyczny",
        "inline_explanation": "(to fałsz; wirtualizacja sieci pozwala na setki interfejsów, np. w kontenerach)",
        "correct": false
      },
      {
        "text": "maksymalnie 4, zgodnie ze standardem Ethernet",
        "inline_explanation": "(standard Ethernet nie narzuca sztywnego limitu na liczbę interfejsów logicznych/wirtualnych)",
        "correct": false
      },
      {
        "text": "nawet kilka tysięcy, np. przy wykorzystaniu standardu VLAN (802.1Q) lub aliasów IP",
        "inline_explanation": "(każdy VLAN jest widoczny w systemie jako osobny interfejs, np. `eth0.10`, `eth0.20`)",
        "correct": true
      }
    ],
    "explanation": "W systemach operacyjnych (zwłaszcza Linux/Unix) jeden interfejs fizyczny (np. `eth0`) może być 'rodzicem' dla wielu interfejsów wirtualnych. Przykłady to: aliasy IP (`eth0:0`), interfejsy VLAN (`eth0.100`), interfejsy macvlan czy mostki (bridges). Maska podsieci określa, ile adresów IP mieści się w danej sieci, ale nie zabrania przypisania wielu różnych podsieci do tej samej karty sieciowej. Limit jest więc narzucany przez zasoby sprzętowe (RAM) i wydajność procesora, a nie przez sam standard sieciowy."
  },
  {
    "id": 9,
    "question": "Plik `/dev/zero` w systemie Unix jest plikiem:",
    "options": [
      {
        "text": "zwykłym (regular file)",
        "inline_explanation": "(pliki zwykłe, jak tekstowe czy binarne, przechowują trwałe dane na nośniku)",
        "correct": false
      },
      {
        "text": "specjalnym znakowym (character special file)",
        "inline_explanation": "(oferuje dostęp sekwencyjny do danych, bajt po bajcie; w `ls -l` oznaczony literą `c`)",
        "correct": true
      },
      {
        "text": "katalogiem (directory)",
        "inline_explanation": "(katalogi służą do organizowania struktury plików)",
        "correct": false
      },
      {
        "text": "specjalnym blokowym (block special file)",
        "inline_explanation": "(urządzenia blokowe, jak dyski twarde, operują na blokach danych i są buforowane)",
        "correct": false
      },
      {
        "text": "dowiązaniem symbolicznym (symbolic link)",
        "inline_explanation": "(choć w `/dev` jest wiele linków, `/dev/zero` jest zazwyczaj niezależnym węzłem urządzenia)",
        "correct": false
      }
    ],
    "explanation": "Katalog `/dev` zawiera pliki reprezentujące urządzenia. `/dev/zero` to **urządzenie znakowe** (character device). Jego zadaniem jest dostarczanie nieskończonego strumienia bajtów o wartości 0 (null bytes) podczas odczytu (używane np. do bezpiecznego wymazywania dysków poleceniem `dd` lub tworzenia pustych plików o zadanym rozmiarze). Odróżnia się je od urządzeń blokowych (jak dyski `/dev/sda`), które przechowują dane w blokach i pozwalają na swobodny dostęp (seeking)."
  },
  {
    "id": 10,
    "question": "Które z wymienionych systemów plików są systemami z dziennikiem (journalling filesystems):",
    "options": [
      {
        "text": "NTFS (Windows)",
        "inline_explanation": "(standard w systemach Windows NT/10/11; posiada plik dziennika `$LogFile`)",
        "correct": true
      },
      {
        "text": "ext4",
        "inline_explanation": "(najpopularniejszy obecnie system plików w Linuxie, posiada domyślnie włączone księgowanie)",
        "correct": true
      },
      {
        "text": "XFS",
        "inline_explanation": "(wysokowydajny, 64-bitowy system plików z księgowaniem, domyślny np. w RHEL)",
        "correct": true
      },
      {
        "text": "ext3",
        "inline_explanation": "(następca ext2, który jako pierwszy w tej rodzinie wprowadził mechanizm journalingu)",
        "correct": true
      },
      {
        "text": "FAT32",
        "inline_explanation": "(prosty system plików z ery Windows 95/98, nie posiada dziennika i jest podatny na uszkodzenia)",
        "correct": false
      },
      {
        "text": "ext2",
        "inline_explanation": "(starszy standard Linuxa; brak dziennika wymusza długotrwałe sprawdzanie `fsck` po awarii)",
        "correct": false
      },
      {
        "text": "ext5",
        "inline_explanation": "(taki system plików nie istnieje; rozwój zatrzymał się na ext4, a nowsze to np. Btrfs czy ZFS)",
        "correct": false
      }
    ],
    "explanation": "Systemy plików z księgowaniem (journalling) zapisują metadane zmian w specjalnym wydzielonym obszarze (dzienniku) zanim zostaną one fizycznie zapisane w głównej strukturze danych. Pozwala to na błyskawiczne przywrócenie spójności systemu plików po nagłym zaniku zasilania (tzw. replay log). Do systemów z dziennikiem należą: **NTFS**, **ext3**, **ext4**, **XFS**, **JFS**, **ReiserFS**. Systemy starsze (**FAT32**, **ext2**) nie posiadają tej funkcji. Nazwa **ext5** jest zmyślona."
  },
  {
    "id": 11,
    "question": "Plik o nazwie `file` miał prawa dostępu: `rwsr-x-wx`. Wykonano polecenie: `chmod u=rx,g+ws,o=r file`. Jakie będą jego prawa dostępu?",
    "options": [
      {
        "text": "`rwsrw-rwx`",
        "inline_explanation": "(błędne; sugeruje, że bit SUID u właściciela został zachowany, a grupa nie otrzymała bitu `s`)",
        "correct": false
      },
      {
        "text": "`r-xrwsr--`",
        "inline_explanation": "(poprawny wynik: `u` nadpisane na `r-x` (bez s), `g` rozszerzone do `rws`, `o` przycięte do `r--`)",
        "correct": true
      },
      {
        "text": "`rwxrwxrwx`",
        "inline_explanation": "(to pełne uprawnienia 777, wynikające z niezrozumienia operatorów `=` i `+`)",
        "correct": false
      },
      {
        "text": "`r--r--r--`",
        "inline_explanation": "(to uprawnienia 444, brakuje praw wykonania i bitów specjalnych)",
        "correct": false
      },
      {
        "text": "`r-xr-xr--`",
        "inline_explanation": "(błędne; brakuje dodanego zapisu `w` oraz bitu SGID `s` dla grupy)",
        "correct": false
      }
    ],
    "explanation": "Analiza polecenia krok po kroku:\n1. **Stan początkowy:** `rwsr-x-wx` (User: `rws` [SUID], Group: `r-x`, Other: `wx`).\n2. `u=rx`: Operator `=` ustawia uprawnienia na sztywno. Właściciel otrzymuje `r-x`. Bit SUID znika, bo nie został wymieniony przy przypisaniu. Wynik częściowy: `r-x`.\n3. `g+ws`: Operator `+` dodaje do istniejących (`r-x`). Dodajemy `w` (zapis) -> `rwx`. Dodajemy `s` (SGID) -> `rws`. Wynik częściowy: `rws`.\n4. `o=r`: Ustawia dla reszty świata tylko odczyt. Wynik częściowy: `r--`.\n**Wynik końcowy:** `r-xrwsr--`."
  },
  {
    "id": 12,
    "question": "Utworzenie dowiązania (linku) twardego do pliku powoduje:",
    "options": [
      {
        "text": "utworzenie nowego węzła (tzw. i-nodu) pod tą samą nazwą",
        "inline_explanation": "(link twardy nie tworzy nowego inode'a, lecz wskazuje na już istniejący)",
        "correct": false
      },
      {
        "text": "utworzenie w katalogu nowej nazwy wskazującej na ten sam i-węzeł, co plik oryginalny",
        "inline_explanation": "(obie nazwy są równoważne, a licznik dowiązań w i-węźle zwiększa się o 1)",
        "correct": true
      },
      {
        "text": "skopiowanie zawartości pliku do nowej lokalizacji na dysku",
        "inline_explanation": "(to działanie polecenia `cp`; hard link nie zajmuje dodatkowego miejsca na dane)",
        "correct": false
      },
      {
        "text": "stworzenie specjalnego pliku tekstowego zawierającego ścieżkę do oryginału",
        "inline_explanation": "(to definicja linku symbolicznego - soft link)",
        "correct": false
      },
      {
        "text": "utworzenie skrótu, który może działać między różnymi systemami plików (partycjami)",
        "inline_explanation": "(linki twarde nie mogą przekraczać granic partycji, ponieważ numery inode są unikalne tylko w obrębie jednego systemu plików)",
        "correct": false
      }
    ],
    "explanation": "W systemie plików typu UNIX plik jest identyfikowany przez numer i-węzła (inode). Nazwa pliku to tylko wpis w katalogu wskazujący na ten numer. **Link twardy** (hard link, tworzony przez `ln`) to po prostu kolejna nazwa (wpis katalogowy) wskazująca na ten sam, fizyczny i-węzeł. Usunięcie jednej nazwy nie usuwa danych, dopóki licznik dowiązań (link count) nie spadnie do zera. Z kolei **Link symboliczny** (`ln -s`) to osobny mały plik (nowy inode), którego zawartością jest ścieżka tekstowa do pliku docelowego."
  },
  {
    "id": 13,
    "question": "Jaka jest różnica między kolejkami FIFO (Named Pipes) i łączami komunikacyjnymi (Anonymous Pipes) w systemie UNIX?",
    "options": [
      {
        "text": "tylko kolejki FIFO mają zdefiniowaną nazwę (wpis w systemie plików)",
        "inline_explanation": "(zwykłe łącza `pipe` są anonimowe i istnieją tylko w pamięci jądra jako para deskryptorów)",
        "correct": true
      },
      {
        "text": "łącza anonimowe mogą łączyć tylko procesy spokrewnione, a FIFO - dowolne procesy w systemie",
        "inline_explanation": "(ponieważ FIFO identyfikujemy po ścieżce do pliku, każdy proces z uprawnieniami może z niej skorzystać)",
        "correct": true
      },
      {
        "text": "łącza komunikacyjne (pipes) działają dwukierunkowo (full-duplex), a FIFO jednokierunkowo",
        "inline_explanation": "(w standardowym POSIX/UNIX oba mechanizmy są zazwyczaj jednokierunkowe; dane płyną w jedną stronę)",
        "correct": false
      },
      {
        "text": "kolejki FIFO przechowują przesyłane dane trwale na dysku twardym",
        "inline_explanation": "(nie, FIFO ma tylko *nazwę* na dysku; dane przelatują przez bufor w pamięci RAM i znikają po odczycie)",
        "correct": false
      },
      {
        "text": "łącza komunikacyjne mogą łączyć procesy uruchomione na różnych komputerach w sieci",
        "inline_explanation": "(nie, oba mechanizmy to IPC lokalne; do komunikacji sieciowej służą gniazda - `sockets`)",
        "correct": false
      }
    ],
    "explanation": "Podstawowa różnica dotyczy sposobu adresowania. Zwykłe łącza (tworzone funkcją `pipe()` lub znakiem `|` w shellu) są **anonimowe** i pozwalają na komunikację tylko procesów posiadających wspólnego przodka (dziedziczenie deskryptorów). Kolejki FIFO (tworzone poleceniem `mkfifo`) posiadają **nazwę** w systemie plików (np. `/tmp/my_fifo`), dzięki czemu mogą łączyć dwa zupełnie niezależne, niespokrewnione procesy działające w tym samym systemie operacyjnym."
  },
  {
    "id": 14,
    "question": "Zaznacz prawdziwe zdania dotyczące algorytmów sortowania (Heapsort vs Quicksort).",
    "options": [
      {
        "text": "Heapsort jest zwykle szybszy niż Quicksort, jednak posiada gorszą pesymistyczną złożoność czasową",
        "inline_explanation": "(jest odwrotnie: Heapsort jest wolniejszy w praktyce, ale ma lepszą, bo gwarantowaną złożoność pesymistyczną)",
        "correct": false
      },
      {
        "text": "Quicksort jest zwykle szybszy w praktyce, ale ma gorszą złożoność pesymistyczną ($O(n^2)$) niż Heapsort ($O(n \\log n)$)",
        "inline_explanation": "(Złożoność pesymistyczna: Quicksort ($O(n^2)$), Heapsort ($O(n \\log n)$).\nQuicksort lepiej wykorzystuje pamięć podręczną CPU, ale zły dobór elementu osiowego (pivot) może go drastycznie spowolnić)",
        "correct": true
      },
      {
        "text": "Obydwa algorytmy mają identyczną złożoność pesymistyczną $O(n^2)$",
        "inline_explanation": "(Heapsort jest algorytmem o gwarantowanej złożoności $O(n \\log n)$ niezależnie od danych wejściowych)",
        "correct": false
      },
      {
        "text": "Heapsort jest algorytmem stabilnym",
        "inline_explanation": "(nie, operacje na kopcu zmieniają kolejność występowania elementów o tej samej wartości)",
        "correct": false
      },
      {
        "text": "Quicksort jest algorytmem typu \"dziel i rządź\" (divide and conquer), działającym w miejscu (in-place)",
        "inline_explanation": "(tak, dzieli tablicę na mniejsze partycje i nie wymaga dodatkowej tablicy pomocniczej o rozmiarze n, jak Mergesort)",
        "correct": true
      }
    ],
    "explanation": "Porównanie algorytmów: **Quicksort** jest w praktyce najszybszy dzięki świetnej lokalności odwołań (cache friendly), ale w najgorszym przypadku (np. posortowana tablica) jego złożoność spada do $O(n^2)$. **Heapsort** (przez kopcowanie) gwarantuje $O(n \\log n)$ w każdym przypadku, ale jest wolniejszy przez chaotyczne skoki po pamięci. Obydwa algorytmy są **niestabilne** (nie zachowują kolejności równych elementów). Algorytmem stabilnym o złożoności $O(n \\log n)$ jest np. Mergesort."
  },
  {
    "id": 15,
    "question": "Problem NP-trudny można rozwiązać w skończonym czasie:",
    "options": [
      {
        "text": "przekształcając go do znanego problemu NP-zupełnego",
        "inline_explanation": "(redukcja służy do udowodnienia trudności problemu, a nie do jego szybszego rozwiązania; problem wynikowy nadal pozostaje trudny obliczeniowo)",
        "correct": false
      },
      {
        "text": "stosując algorytm o złożoności wykładniczej (np. przegląd zupełny / brute force)",
        "inline_explanation": "(złożoność rzędu $O(2^n)$ lub $O(n!)$ jest ogromna, ale matematycznie skończona i gwarantuje poprawny wynik)",
        "correct": true
      },
      {
        "text": "stosując algorytm aproksymacyjny",
        "inline_explanation": "(często rezygnujemy z idealnej dokładności na rzecz akceptowalnego czasu obliczeń, uzyskując wynik \"wystarczająco dobry\")",
        "correct": true
      },
      {
        "text": "jest to niemożliwe, ponieważ problemy NP-trudne są nierozstrzygalne",
        "inline_explanation": "(fałsz; są one obliczalne, problemem jest jedynie czas potrzebny na wykonanie obliczeń, który rośnie lawinowo wraz z danymi)",
        "correct": false
      },
      {
        "text": "używając standardowego algorytmu o złożoności wielomianowej (zakładając $P \\neq NP$)",
        "inline_explanation": "(obecnie nie znamy algorytmów wielomianowych dla problemów NP-trudnych; ich odkrycie oznaczałoby, że $P=NP$)",
        "correct": false
      }
    ],
    "explanation": "Klasa problemów **NP-trudnych** obejmuje zadania, dla których nie znamy szybkich (wielomianowych) algorytmów rozwiązujących. Nie oznacza to jednak, że są nierozwiązywalne (jak np. Problem Stopu). Można je rozwiązać algorytmami dokładnymi o złożoności wykładniczej (np. sprawdzając wszystkie możliwości), co dla małych danych jest wykonalne. W praktyce inżynierskiej najczęściej stosuje się **algorytmy heurystyczne** i **aproksymacyjne**, które w skończonym czasie dają wynik zbliżony do optymalnego."
  },
  {
    "id": 16,
    "question": "Błąd względny:",
    "options": [
      {
        "text": "jest zawsze większy lub równy 1",
        "inline_explanation": "(błąd względny jest zazwyczaj małym ułamkiem, np. 0.05; wartość > 1 oznaczałaby, że błąd jest większy niż mierzona wielkość)",
        "correct": false
      },
      {
        "text": "jest wielkością bezwymiarową (nie posiada jednostki)",
        "inline_explanation": "(jednostki licznika i mianownika się skracają, np. $\\frac{[m]}{[m]}$)",
        "correct": true
      },
      {
        "text": "jest ilorazem błędu bezwzględnego i wartości dokładnej (lub zmierzonej)",
        "inline_explanation": "(wyraża się wzorem $\\delta = \\frac{\\Delta x}{x_0}$)",
        "correct": true
      },
      {
        "text": "posiada taką samą jednostkę jak mierzona wielkość",
        "inline_explanation": "(to cecha błędu bezwzględnego, który wyrażamy np. w metrach lub sekundach)",
        "correct": false
      },
      {
        "text": "przyjmuje wartości ujemne dla pomiarów zaniżonych",
        "inline_explanation": "(zwyczajowo błąd względny definiuje się przy użyciu wartości bezwzględnej, więc jest wielkością nieujemną)",
        "correct": false
      }
    ],
    "explanation": "Błąd względny (relative error) określa jakość pomiaru w odniesieniu do wielkości mierzonej. Wzór: $\\delta = \\frac{|x - x_0|}{|x_0|}$. Dzięki temu, że jest wielkością **bezwymiarową** (często wyrażaną w procentach), pozwala porównywać dokładność pomiarów różnych wielkości fizycznych (np. czy dokładniej zmierzyliśmy długość stołu, czy czas biegu)."
  },
  {
    "id": 17,
    "question": "Algorytm Dijkstry:",
    "options": [
      {
        "text": "rozwiązuje problem wyboru najkrótszej ścieżki w grafach z ujemnymi wagami",
        "inline_explanation": "(nie, algorytm ten jest zachłanny i nie potrafi cofnąć decyzji, co przy ujemnych wagach prowadzi do błędów; należy użyć algorytmu Bellmana-Forda)",
        "correct": false
      },
      {
        "text": "wymaga, aby wagi krawędzi w grafie były nieujemne",
        "inline_explanation": "(jest to warunek konieczny, aby zachłanna strategia wyboru wierzchołka o najmniejszym koszcie działała poprawnie)",
        "correct": true
      },
      {
        "text": "znajduje najkrótsze ścieżki z jednego źródła do wszystkich innych wierzchołków",
        "inline_explanation": "(jest to algorytm typu Single-Source Shortest Path)",
        "correct": true
      },
      {
        "text": "służy do znajdowania Minimalnego Drzewa Rozpinającego (MST)",
        "inline_explanation": "(do MST służą algorytmy Prima lub Kruskala; Dijkstra buduje drzewo najkrótszych ścieżek, które jest czymś innym)",
        "correct": false
      },
      {
        "text": "ma zawsze gorszą złożoność obliczeniową niż algorytm Bellmana-Forda",
        "inline_explanation": "(fałsz, Dijkstra na kopcach Fibonacciego jest znacznie szybszy: $O(E + V \\log V)$ vs Bellman-Ford: $O(V \\cdot E)$)",
        "correct": false
      }
    ],
    "explanation": "Algorytm Dijkstry to klasyczny algorytm grafowy służący do znajdowania najkrótszej ścieżki z jednego wierzchołka do wszystkich pozostałych. Jego kluczowym ograniczeniem jest wymóg **nieujemnych wag krawędzi**. Jeśli graf zawiera krawędzie o wagach ujemnych (np. w logistyce: zysk zamiast kosztu), należy zastosować wolniejszy, ale bardziej ogólny algorytm Bellmana-Forda."
  },
  {
    "id": 18,
    "question": "Zaznacz prawdziwe zdania odnoszące się do analizy algorytmów.",
    "options": [
      {
        "text": "Operacje dominujące to takie, które mogą być pominięte podczas szacowania złożoności obliczeniowej",
        "inline_explanation": "(jest odwrotnie - to właśnie operacje dominujące decydują o rzędzie złożoności i to je zliczamy)",
        "correct": false
      },
      {
        "text": "Operacja dominująca to instrukcja, której liczba wykonań jest proporcjonalna do całkowitego czasu działania algorytmu (dla dużych n)",
        "inline_explanation": "(zazwyczaj jest to instrukcja w najbardziej zagnieżdżonej pętli)",
        "correct": true
      },
      {
        "text": "Szacując złożoność obliczeniową, pomijamy stałe współczynniki oraz wyrazy niższego rzędu",
        "inline_explanation": "(dlatego np. $2n^2 + 100n$ upraszczamy do notacji $O(n^2)$)",
        "correct": true
      },
      {
        "text": "Złożoność pesymistyczna opisuje najlepszy możliwy przypadek wykonania algorytmu",
        "inline_explanation": "(opisuje najgorszy przypadek - Worst Case; najlepszy przypadek to złożoność optymistyczna)",
        "correct": false
      },
      {
        "text": "Złożoność pamięciowa algorytmu jest zawsze równa jego złożoności czasowej",
        "inline_explanation": "(fałsz, np. Quicksort ma czas $O(n \\log n)$, ale pamięć $O(\\log n)$)",
        "correct": false
      }
    ],
    "explanation": "W asymptotycznej analizie złożoności (Notacja Duże O) interesuje nas tempo wzrostu czasu wykonania (lub zużycia pamięci) w funkcji rozmiaru danych wejściowych ($n$). Skupiamy się na **operacji dominującej** (wykonywanej najczęściej). Stałe (np. \"algorytm wykonuje 5 operacji na każdy element\") oraz składniki niższego rzędu są pomijane, ponieważ dla bardzo dużych $n$ przestają mieć znaczenie."
  },
  {
    "id": 19,
    "question": "Problemem NP-trudnym jest:",
    "options": [
      {
        "text": "problem minimalnego drzewa rozpinającego (MST)",
        "inline_explanation": "(klasa P - rozwiązywalny w czasie wielomianowym algorytmami Prima/Kruskala)",
        "correct": false
      },
      {
        "text": "problem komiwojażera (TSP - Traveling Salesman Problem)",
        "inline_explanation": "(klasyczny problem optymalizacyjny, dla którego nie znamy rozwiązania wielomianowego)",
        "correct": true
      },
      {
        "text": "problem plecakowy (Knapsack problem)",
        "inline_explanation": "(problem decyzyjny wyboru przedmiotów o największej wartości przy ograniczonej wadze)",
        "correct": true
      },
      {
        "text": "wyszukiwanie binarne w posortowanej tablicy",
        "inline_explanation": "(klasa P - problem bardzo łatwy, złożoność $O(\\log n)$)",
        "correct": false
      },
      {
        "text": "problem spełnialności formuł logicznych (SAT)",
        "inline_explanation": "(pierwszy problem udowodniony jako NP-zupełny - twierdzenie Cooka)",
        "correct": true
      },
      {
        "text": "sortowanie ciągu liczb",
        "inline_explanation": "(klasa P - np. MergeSort, HeapSort)",
        "correct": false
      }
    ],
    "explanation": "Problemy **NP-trudne** to takie, które są co najmniej tak trudne jak najtrudniejsze problemy w klasie NP. Nie znamy dla nich algorytmów wielomianowych (przy założeniu $P \\neq NP$). Przykłady: Problem Komiwojażera (odwiedzenie miast najkrótszą drogą), Problem Plecakowy (upakowanie plecaka) czy SAT. Problemy takie jak sortowanie, MST czy wyszukiwanie binarne należą do klasy **P** (Polynomial) i są łatwo rozwiązywalne przez współczesne komputery."
  },
  {
    "id": 20,
    "question": "Graf może być reprezentowany w pamięci komputera przez:",
    "options": [
      {
        "text": "macierz incydencji",
        "inline_explanation": "(relacja węzeł-krawędź; wiersze to wierzchołki, kolumny to krawędzie)",
        "correct": true
      },
      {
        "text": "listy sąsiedztwa",
        "inline_explanation": "(dla każdego wierzchołka przechowujemy listę jego sąsiadów; oszczędne dla grafów rzadkich $O(V+E)$)",
        "correct": true
      },
      {
        "text": "macierz sąsiedztwa",
        "inline_explanation": "(macierz kwadratowa $V \\times V$; szybka weryfikacja czy krawędź istnieje ($O(1)$), ale pamięciożerna $O(V^2)$)",
        "correct": true
      },
      {
        "text": "zwykłą kolejkę FIFO",
        "inline_explanation": "(kolejka to struktura pomocnicza używana np. w algorytmie BFS, ale sama w sobie nie definiuje topologii grafu)",
        "correct": false
      },
      {
        "text": "listę krawędzi (Edge List)",
        "inline_explanation": "(prosta tablica lub lista przechowująca pary połączonych wierzchołków)",
        "correct": true
      }
    ],
    "explanation": "Wybór reprezentacji grafu zależy od jego gęstości i wykonywanych operacji. **Macierz sąsiedztwa** jest idealna dla grafów gęstych (dużo krawędzi), pozwalając na błyskawiczne sprawdzenie połączenia. **Listy sąsiedztwa** są standardem dla grafów rzadkich (oszczędność pamięci). **Macierz incydencji** jest rzadziej stosowana, ale przydatna w hipergrafach lub obwodach elektrycznych."
  },
  {
    "id": 21,
    "question": "Jakie czynniki należy wziąć pod uwagę przy wyborze lub tworzeniu struktur danych?",
    "options": [
      {
        "text": "które operacje będą operacjami częstymi, a jakie rzadkimi",
        "inline_explanation": "(kluczowe kryterium; np. tablica jest świetna do odczytu, a lista wiązana do wstawiania)",
        "correct": true
      },
      {
        "text": "ograniczenia pamięciowe i czasowe",
        "inline_explanation": "(analiza złożoności obliczeniowej kluczowych operacji w notacji Big O)",
        "correct": true
      },
      {
        "text": "wyłącznie estetykę kodu źródłowego",
        "inline_explanation": "(wygląd kodu jest wtórny wobec wydajności i poprawności struktury danych)",
        "correct": false
      },
      {
        "text": "dostępność bibliotek graficznych do wizualizacji",
        "inline_explanation": "(możliwość narysowania struktury nie wpływa na jej wydajność w systemie)",
        "correct": false
      },
      {
        "text": "łatwość implementacji i utrzymania",
        "inline_explanation": "(często prostsza struktura, np. `std::vector`, jest lepsza niż skomplikowane drzewo, jeśli zysk wydajności jest marginalny)",
        "correct": true
      }
    ],
    "explanation": "Projektowanie struktur danych to sztuka kompromisu (trade-off). Zawsze analizujemy: 1) **Profil operacji** (co robimy najczęściej?), 2) **Złożoność** (ile to potrwa?), 3) **Pamięć** (ile to zajmie?). Nie ma jednej idealnej struktury do wszystkiego."
  },
  {
    "id": 22,
    "question": "Algorytmem heurystycznym jest:",
    "options": [
      {
        "text": "algorytm Metropolisa (lub symulowane wyżarzanie)",
        "inline_explanation": "(probabilistyczna metoda szukania minimum globalnego, inspirowana procesem krystalizacji metalu)",
        "correct": true
      },
      {
        "text": "symulowane wyżarzanie",
        "inline_explanation": "(również probabilistyczna metoda szukania minimum globalnego, inspirowana procesem krystalizacji metalu)",
        "correct": true
      },
      {
        "text": "algorytm genetyczny",
        "inline_explanation": "(metoda ewolucyjna wykorzystująca selekcję, krzyżowanie i mutację)",
        "correct": true
      },
      {
        "text": "sortowanie bąbelkowe",
        "inline_explanation": "(to algorytm dokładny, deterministyczny o złożoności $O(n^2)$, a nie przybliżony)",
        "correct": false
      },
      {
        "text": "algorytm Dijkstry",
        "inline_explanation": "(to algorytm dokładny, zawsze znajduje optymalną najkrótszą ścieżkę)",
        "correct": false
      },
      {
        "text": "algorytm mrówkowy (Ant Colony Optimization)",
        "inline_explanation": "(heurystyka inspirowana zachowaniem mrówek zostawiających ślad feromonowy)",
        "correct": true
      }
    ],
    "explanation": "Algorytmy heurystyczne służą do znajdowania rozwiązań \"wystarczająco dobrych\" dla problemów trudnych obliczeniowo (np. NP-trudnych), gdzie przegląd wszystkich możliwości trwałby miliardy lat. Nie gwarantują one znalezienia najlepszego rozwiązania (optimum globalnego), ale znajdują dobre rozwiązanie w akceptowalnym czasie. Inne przykłady: Algorytm zachłanny, Tabu Search."
  },
  {
    "id": 23,
    "question": "Zaznacz prawdziwe zdania dotyczące Prawa Amdahla (wydajność systemów wieloprocesorowych).",
    "options": [
      {
        "text": "Zrównoleglając algorytm w 50% programu na 4 procesorach uzyskamy minimum 2-krotne przyspieszenia działania",
        "inline_explanation": "(fałsz, maksymalne przyspieszenie w tym przypadku wyniesie 1.6x)",
        "correct": false
      },
      {
        "text": "Zrównoleglając algorytm w 50% na 4 procesorach uzyskamy przyspieszenie wynoszące 1.6 raza",
        "inline_explanation": "(wynika to ze wzoru: $S(4) = \\frac{1}{(1-0.5) + \\frac{0.5}{4}} = 1.6$)",
        "correct": true
      },
      {
        "text": "Maksymalne teoretyczne przyspieszenie programu zależy od jego sekwencyjnej części",
        "inline_explanation": "(gdy $N \\to \\infty$, przyspieszenie dąży do $\\frac{1}{1-P}$)",
        "correct": true
      },
      {
        "text": "Zwiększanie liczby procesorów liniowo zwiększa wydajność każdego programu",
        "inline_explanation": "(nie, ogranicza nas część sekwencyjna, której nie da się przyspieszyć dokładaniem rdzeni)",
        "correct": false
      },
      {
        "text": "Dla programu w 90% zrównoleglonego, maksymalne przyspieszenie na nieskończonej liczbie procesorów wynosi 10x",
        "inline_explanation": "(prawda: $\\frac{1}{1-0.9} = \\frac{1}{0.1} = 10$)",
        "correct": true
      }
    ],
    "explanation": "Skorzystajmy z **Prawa Amdahla**: $$S(N) = \\frac{1}{(1-P) + \\frac{P}{N}}$$ Gdzie $P$ to część zrównoleglona (50% = 0.5), a $N$ to liczba procesorów (4). \n $$ S(4) = \\frac{1}{(1-0.5) + \\frac{0.5}{4}} = \\frac{1}{0.5 + 0.125} = \\frac{1}{0.625} = 1.6 $$ \n Przyspieszenie wynosi **1.6 razy**. Nawet przy nieskończonej liczbie procesorów ($N \\to \\infty$), granica wynosi $\\frac{1}{0.5} = 2$. Czyli 2-krotne przyspieszenie to teoretyczne maksimum absolutne (nieosiągalne dla skończonej liczby 4 procesorów)."
  },
  {
    "id": 24,
    "question": "Z jakimi korzyściami wiąże się używanie wirtualnych środowisk?",
    "options": [
      {
        "text": "Zmniejszenie zużycia miejsca na dysku",
        "inline_explanation": "(wirtualizacja zazwyczaj zwiększa zużycie dysku przez duplikację plików systemowych gościa)",
        "correct": false
      },
      {
        "text": "Izolacja uruchamianych aplikacji i ich zależności od systemu gospodarza",
        "inline_explanation": "(kluczowa cecha bezpieczeństwa i stabilności - awaria w VM nie kładzie hosta)",
        "correct": true
      },
      {
        "text": "Łatwiejsze przenoszenie i wdrażanie aplikacji (portability)",
        "inline_explanation": "(obraz VM lub kontenera można uruchomić na dowolnym sprzęcie z kompatybilnym hiperwizorem)",
        "correct": true
      },
      {
        "text": "Zawsze wyższa wydajność niż uruchamianie natywne na sprzęcie",
        "inline_explanation": "(wirtualizacja zawsze wprowadza pewien narzut/overhead na emulację sprzętu lub translację rozkazów)",
        "correct": false
      },
      {
        "text": "Możliwość tworzenia migawek (snapshots) całego stanu systemu",
        "inline_explanation": "(pozwala na szybkie przywrócenie systemu po nieudanej aktualizacji)",
        "correct": true
      }
    ],
    "explanation": "Wirtualne środowiska (maszyny wirtualne, kontenery, venv) służą przede wszystkim **izolacji**. \n ⚫ **Zalety:** Separacja zależności (różne projekty mają różne biblioteki), łatwość przenoszenia, bezpieczeństwo (piaskownica), testowanie. \n ⚫ **Wady:** Zazwyczaj większe zużycie dysku (duplikacja bibliotek, obrazów systemu) i narzut wydajnościowy (rzędu od 1% do kilkunastu % w zależności od technologii)."
  },
  {
    "id": 25,
    "question": "Cechą charakterystyczną zwinnych metod tworzenia oprogramowania (Agile) jest:",
    "options": [
      {
        "text": "Przeplatanie procesów specyfikacji, projektowania i implementacji (podejście iteracyjne)",
        "inline_explanation": "(zamiast robić to raz a dobrze, robimy to cyklicznie w każdym sprincie)",
        "correct": true
      },
      {
        "text": "Gotowość na zmiany wymagań w trakcie trwania projektu",
        "inline_explanation": "(reagowanie na zmiany ponad realizację założonego planu - manifest Agile)",
        "correct": true
      },
      {
        "text": "Szczegółowe zaplanowanie całego procesu i budżetu przed napisaniem pierwszej linijki kodu",
        "inline_explanation": "(to domena modelu kaskadowego / Waterfall, a nie Agile)",
        "correct": false
      },
      {
        "text": "Całkowity brak dokumentacji projektowej",
        "inline_explanation": "(Agile ceni działające oprogramowanie *ponad* dokumentację, ale jej nie eliminuje; niezbędne minimum jest tworzone)",
        "correct": false
      },
      {
        "text": "Ścisła współpraca z klientem (często włączenie go do zespołu projektowego)",
        "inline_explanation": "(klient widzi postępy na bieżąco i daje feedback po każdej iteracji)",
        "correct": true
      }
    ],
    "explanation": "Metodyki zwinne (Agile, np. Scrum, Kanban) przeciwstawiają się sztywnemu modelowi kaskadowemu (Waterfall). W Agile: \n ⚫ Pracuje się w krótkich iteracjach (sprintach). \n ⚫ Fazy (analiza, projekt, kodowanie, testy) **przeplatają się** w każdej iteracji, zamiast następować po sobie jednorazowo dla całego projektu. \n ⚫ Kluczowa jest adaptacja do zmian i ciągłe dostarczanie wartości biznesowej."
  },
  {
    "id": 26,
    "question": "Wskaż poprawne zdania dotyczące architektury oprogramowania:",
    "options": [
      {
        "text": "Nie istnieje związek pomiędzy architekturą, a wymaganiami systemu teleinformatycznego",
        "inline_explanation": "(jest odwrotnie - architektura jest odpowiedzią na wymagania, zwłaszcza te niefunkcjonalne)",
        "correct": false
      },
      {
        "text": "Architektura oprogramowania wynika w dużej mierze z wymagań niefunkcjonalnych (np. wydajności, bezpieczeństwa)",
        "inline_explanation": "(tzw. Quality Attributes determinują wybór technologii i wzorców, np. mikroserwisy dla skalowalności)",
        "correct": true
      },
      {
        "text": "Wzorce architektoniczne (np. MVC, Klient-Serwer) to sprawdzone rozwiązania typowych problemów projektowych",
        "inline_explanation": "(ułatwiają projektowanie, dostarczając gotowe szablony struktury aplikacji)",
        "correct": true
      },
      {
        "text": "Architektura dotyczy tylko wyglądu interfejsu użytkownika",
        "inline_explanation": "(nie, to domena UX/UI; architektura to struktura wewnętrzna: komponenty, bazy danych, komunikacja)",
        "correct": false
      },
      {
        "text": "Dobra architektura powinna być udokumentowana (np. diagramy UML, C4 model), aby ułatwić komunikację w zespole",
        "inline_explanation": "(dokumentacja architektoniczna jest kluczowa dla zrozumienia systemu przez nowych programistów)",
        "correct": true
      }
    ],
    "explanation": "Architektura oprogramowania to fundament systemu. Jest ona ściśle powiązana z wymaganiami, zwłaszcza wymaganiami niefunkcjonalnymi (Jakościowymi - ang. NFR: Non-Functional Requirements), takimi jak: wydajność, skalowalność, bezpieczeństwo, dostępność. Jeśli system ma być bezpieczny i skalowalny (wymagania), architektura musi to uwzględniać (np. przez load balancery, szyfrowanie, mikroserwisy). Podana odpowiedź (\"Nie istnieje związek...\") jest FAŁSZYWA. Związek jest kluczowy."
  },
  {
    "id": 27,
    "question": "Wskaż poprawne zdania dotyczące architektury systemu teleinformatycznego:",
    "options": [
      {
        "text": "Architektura systemu teleinformatycznego nie ma wpływu na jego bezpieczeństwo",
        "inline_explanation": "(ma fundamentalny wpływ; błędy architektoniczne są najtrudniejsze i najdroższe do naprawienia)",
        "correct": false
      },
      {
        "text": "Decyzje architektoniczne mają fundamentalny wpływ na poziom bezpieczeństwa systemu (np. poprzez izolację komponentów)",
        "inline_explanation": "(np. podział na strefy sieciowe, użycie DMZ, separacja uprawnień)",
        "correct": true
      },
      {
        "text": "Architektura powinna uwzględniać wymagania niefunkcjonalne, takie jak niezawodność, skalowalność i bezpieczeństwo",
        "inline_explanation": "(bez tego system może działać poprawnie funkcjonalnie, ale być niestabilny lub podatny na ataki)",
        "correct": true
      },
      {
        "text": "Architektura dotyczy tylko sprzętu, a nie oprogramowania",
        "inline_explanation": "(nie, architektura systemu to połączenie sprzętu, sieci i oprogramowania)",
        "correct": false
      },
      {
        "text": "Wybór modelu architektonicznego (np. monolit vs mikroserwisy) wpływa na łatwość wdrażania i skalowania systemu",
        "inline_explanation": "(mikroserwisy łatwiej skalować niezależnie, ale są trudniejsze w utrzymaniu)",
        "correct": true
      }
    ],
    "explanation": "Architektura systemu to fundamentalna organizacja systemu, obejmująca jego komponenty, relacje między nimi oraz zasady projektowania. Bezpieczeństwo systemu jest ściśle powiązane z architekturą (koncepcja Security by Design). Decyzje architektoniczne (np. separacja warstw, brak pojedynczych punktów awarii, minimalizacja powierzchni ataku) determinują odporność systemu. Źle zaprojektowana architektura może uniemożliwić skuteczne zabezpieczenie systemu w późniejszych fazach."
  },
  {
    "id": 28,
    "question": "Wskaż poprawne zdania dotyczące ewolucji oprogramowania:",
    "options": [
      {
        "text": "Ewolucja oprogramowania może zostać wymuszona przez zmianę wymagań po oddaniu finalnej wersji oprogramowania",
        "inline_explanation": "(zmienność biznesu wymusza ciągłe dostosowywanie oprogramowania)",
        "correct": true
      },
      {
        "text": "Koszty ewolucji i utrzymania oprogramowania często przekraczają koszty jego pierwotnego wytworzenia",
        "inline_explanation": "(reguła 60/60 lub nawet 80/20 - utrzymanie to większość kosztów w cyklu życia systemu)",
        "correct": true
      },
      {
        "text": "Ewolucja oprogramowania kończy się w momencie wdrożenia wersji 1.0 na produkcję",
        "inline_explanation": "(fałsz, wdrożenie to początek najdłuższej fazy cyklu życia - eksploatacji i pielęgnacji)",
        "correct": false
      },
      {
        "text": "Zmiany w oprogramowaniu po wdrożeniu wynikają wyłącznie z błędów programistów",
        "inline_explanation": "(nie, wynikają też z nowych funkcji, zmian prawnych, aktualizacji systemów operacyjnych)",
        "correct": false
      },
      {
        "text": "Refaktoryzacja to technika ułatwiająca ewolucję poprzez poprawę struktury kodu bez zmiany jego zachowania",
        "inline_explanation": "(czysty kod łatwiej modyfikować w przyszłości)",
        "correct": true
      }
    ],
    "explanation": "Ewolucja oprogramowania (często utożsamiana z utrzymaniem) to proces zmian zachodzących w oprogramowaniu po jego wdrożeniu. Zgodnie z prawami ewolucji oprogramowania (prawa Lehmana), program używany w rzeczywistym środowisku musi się zmieniać, w przeciwnym razie staje się coraz mniej użyteczny. Zmiany te są wymuszane przez:\n ⚫ Zmiany w wymaganiach biznesowych (nowe funkcje).\n ⚫ Zmiany w środowisku (nowy system operacyjny, sprzęt).\n ⚫ Konieczność naprawy błędów.\nPodane zdanie jest prawdziwe."
  },
  {
    "id": 29,
    "question": "Wskaż poprawne zdania dotyczące implementacji oprogramowania:",
    "options": [
      {
        "text": "Implementacja oprogramowania jest zawsze najdłuższym i najbardziej kosztownym etapem tworzenia oprogramowania",
        "inline_explanation": "(fałsz, zazwyczaj faza utrzymania trwa latami i kosztuje znacznie więcej)",
        "correct": false
      },
      {
        "text": "Faza utrzymania i ewolucji oprogramowania generuje zazwyczaj największe koszty w całkowitym cyklu życia systemu",
        "inline_explanation": "(szacuje się, że to nawet 60-80% całkowitego kosztu posiadania - TCO)",
        "correct": true
      },
      {
        "text": "Wytworzenie kodu (implementacja) jest tylko jednym z etapów procesu inżynierii oprogramowania",
        "inline_explanation": "(obok analizy, projektowania, testowania i wdrażania)",
        "correct": true
      },
      {
        "text": "Testowanie oprogramowania wykonuje się zawsze tylko po zakończeniu całej implementacji",
        "inline_explanation": "(w nowoczesnych podejściach, np. TDD/Agile, testy pisze się równolegle lub nawet przed kodem)",
        "correct": false
      },
      {
        "text": "Współczesna implementacja często obejmuje pisanie automatycznych testów jednostkowych (Unit Tests)",
        "inline_explanation": "(programista nie tylko pisze kod funkcjonalny, ale też kod weryfikujący jego poprawność)",
        "correct": true
      }
    ],
    "explanation": "W cyklu życia oprogramowania (SDLC), faza implementacji (kodowania) jest kluczowa, ale rzadko jest najdłuższa czy najdroższa.\n ⚫ **Najdroższa** jest zazwyczaj faza utrzymania (maintenance/ewolucja), trwająca przez cały okres życia produktu.\n ⚫ W nowoczesnych metodykach (Agile, DevOps) dużo czasu zajmują testy, projektowanie architektury i zbieranie wymagań, a sam kod powstaje iteracyjnie."
  },
  {
    "id": 30,
    "question": "Protokoły rutingu typu wektor odległości (Distance Vector):",
    "options": [
      {
        "text": "przesyłają do swoich sąsiadów tylko listę podsieci, które są podłączone do nich bezpośrednio",
        "inline_explanation": "(nie, to opis bliższy protokołom Link State wysyłającym LSA; Distance Vector wysyła wszystko co wie)",
        "correct": false
      },
      {
        "text": "okresowo przesyłają całą swoją tablicę routingu do bezpośrednich sąsiadów",
        "inline_explanation": "(np. `RIP` wysyła pełną tablicę co 30 sekund, co generuje duży ruch w dużych sieciach)",
        "correct": true
      },
      {
        "text": "wykorzystują algorytm Bellmana-Forda do wyznaczania tras",
        "inline_explanation": "(obliczają najlepszą trasę na podstawie wektorów otrzymanych od sąsiadów)",
        "correct": true
      },
      {
        "text": "posiadają pełną mapę topologii całej sieci",
        "inline_explanation": "(to cecha protokołów Stanu Łącza / Link State jak `OSPF`; DV zna tylko kierunek i odległość)",
        "correct": false
      },
      {
        "text": "Są podatne na problem zliczania do nieskończoności (Count-to-Infinity) przy awarii łączy",
        "inline_explanation": "(dlatego stosuje się mechanizmy obronne jak Split Horizon czy Route Poisoning)",
        "correct": true
      }
    ],
    "explanation": "Protokoły wektora odległości (np. `RIP`, `IGRP`) działają na zasadzie \"plotkowania\" z sąsiadami. Cechy charakterystyczne:\n ⚫ Każdy router wysyła sąsiadom **całą swoją tablicę routingu** (wszystko co wie o sieci).\n ⚫ Działają okresowo (np. `RIP` co 30 sekund).\n ⚫ Router zna tylko kierunek (wektor) i odległość do celu, nie zna topologii całej sieci (nie ma mapy)."
  },
  {
    "id": 31,
    "question": "Pole Czas Życia (Time to live - TTL) w nagłówku protokołu IPv4:",
    "options": [
      {
        "text": "przeciwdziała skutkom wystąpienia pętli w sieci (zapobiega nieskończonemu krążeniu pakietów)",
        "inline_explanation": "(gdyby nie TTL, pakiet w pętli routingowej krążyłby w nieskończoność, zapychając łącze)",
        "correct": true
      },
      {
        "text": "jest zmniejszane o 1 przez każdy router na ścieżce przesyłu",
        "inline_explanation": "(router dekrementuje TTL przed przekazaniem pakietu dalej)",
        "correct": true
      },
      {
        "text": "określa dokładny czas w sekundach, po którym pakiet zostanie usunięty",
        "inline_explanation": "(współcześnie to liczba skoków; historycznie w RFC miały to być sekundy, ale routery przetwarzają pakiety szybciej)",
        "correct": false
      },
      {
        "text": "służy do priorytetyzacji ruchu w sieci",
        "inline_explanation": "(do tego służy pole ToS / DS Field)",
        "correct": false
      },
      {
        "text": "Gdy osiągnie wartość 0, router odrzuca pakiet i wysyła komunikat `ICMP Time Exceeded`",
        "inline_explanation": "(na tym mechanizmie opiera się działanie narzędzia `traceroute`)",
        "correct": true
      }
    ],
    "explanation": "Pole TTL (8 bitów) służy do ograniczenia czasu przebywania pakietu w sieci. Każdy router, przez który przechodzi pakiet, zmniejsza wartość TTL o 1. Gdy TTL osiągnie 0, pakiet jest odrzucany, a do nadawcy wysyłany jest komunikat `ICMP Time Exceeded`. Zapobiega to nieskończonemu krążeniu pakietów w pętlach routingowych."
  },
  {
    "id": 32,
    "question": "Które zdania dotyczące programu traceroute są prawdziwe:",
    "options": [
      {
        "text": "wykorzystuje do działania usługę PING",
        "inline_explanation": "(nieprecyzyjne; `traceroute` to osobny program, a `ping` służy tylko do sprawdzenia dostępności, choć w Windows oba używają ICMP Echo)",
        "correct": false
      },
      {
        "text": "działa poprzez wysyłanie pakietów ze stopniowo zwiększaną wartością pola TTL",
        "inline_explanation": "(TTL=1 dla pierwszego routera, TTL=2 dla drugiego itd.)",
        "correct": true
      },
      {
        "text": "identyfikuje routery pośrednie na podstawie otrzymanych komunikatów ICMP 'Time Exceeded'",
        "inline_explanation": "(to właśnie adres źródłowy tego komunikatu jest adresem routera na ścieżce)",
        "correct": true
      },
      {
        "text": "służy do sprawdzenia adresu fizycznego MAC karty sieciowej",
        "inline_explanation": "(do tego służy polecenie `arp -a` lub `ip neigh`)",
        "correct": false
      },
      {
        "text": "zawsze wysyła pakiety na port 80 (HTTP)",
        "inline_explanation": "(w implementacji Linux/UDP używa wysokich portów >30000, które są prawdopodobnie zamknięte u celu)",
        "correct": false
      }
    ],
    "explanation": "Program `traceroute` (Windows: `tracert`) służy do śledzenia trasy pakietów. Mechanizm: wysyła pakiety z polem TTL=1, 2, 3... Routery po drodze odrzucają je (bo TTL wygasa) i odsyłają `ICMP Time Exceeded`. Program zbiera te odpowiedzi i wyświetla listę routerów.\n ⚫ Windows: używa `ICMP Echo Request`.\n ⚫ Linux: domyślnie używa pakietów UDP na losowe, wysokie porty."
  },
  {
    "id": 33,
    "question": "Który z poniższych protokołów routingu jest protokołem stanu łącza (Link State):",
    "options": [
      {
        "text": "RIPv1",
        "inline_explanation": "(klasyczny protokół wektora odległości - Distance Vector)",
        "correct": false
      },
      {
        "text": "OSPF (Open Shortest Path First)",
        "inline_explanation": "(najpopularniejszy protokół Link State w sieciach korporacyjnych)",
        "correct": true
      },
      {
        "text": "IS-IS (Intermediate System to Intermediate System)",
        "inline_explanation": "(protokół Link State używany głównie przez dostawców usług ISP)",
        "correct": true
      },
      {
        "text": "BGP",
        "inline_explanation": "(protokół wektora ścieżki - Path Vector, fundament Internetu)",
        "correct": false
      },
      {
        "text": "Routing statyczny",
        "inline_explanation": "(to nie jest protokół dynamiczny; trasy są wpisywane ręcznie przez administratora)",
        "correct": false
      }
    ],
    "explanation": "Protokoły routingu dzielimy na:\n ⚫ **Distance Vector (Wektor odległości):** `RIP`, `IGRP`. Routery wymieniają się informacją 'co widzą' (plotkowanie).\n ⚫ **Link State (Stan łącza):** `OSPF`, `IS-IS`. Routery budują pełną mapę sieci (graf) i liczą najkrótsze ścieżki algorytmem Dijkstry.\n ⚫ **Hybrydowe:** `EIGRP`."
  },
  {
    "id": 34,
    "question": "Do których sieci należą wszystkie następujące adresy IP: 192.168.1.200, 192.168.1.210, 192.168.1.220?",
    "options": [
      {
        "text": "192.168.1.192 /26",
        "inline_explanation": "(zakres użyteczny: .193 - .254; wszystkie adresy się mieszczą)",
        "correct": true
      },
      {
        "text": "192.168.1.0 /24",
        "inline_explanation": "(zakres użyteczny: .1 - .254; to standardowa sieć domowa, adresy się mieszczą)",
        "correct": true
      },
      {
        "text": "192.168.1.128 /26",
        "inline_explanation": "(zakres: .129 - .190; adresy są zbyt wysokie i wypadają poza tę podsieć)",
        "correct": false
      },
      {
        "text": "192.168.1.200 /28",
        "inline_explanation": "(zakres: .201 - .214; adres .220 się nie mieści, a .200 to adres sieci)",
        "correct": false
      },
      {
        "text": "192.168.0.0 /16",
        "inline_explanation": "(ogromna sieć obejmująca 192.168.0.0 - 192.168.255.255; adresy oczywiście się mieszczą)",
        "correct": true
      }
    ],
    "explanation": "Analiza dla **192.168.1.192 /26**:\n Maska /26 to `255.255.255.192`. Krok podsieci (block size) to 64. \n Podsieci: `.0`, `.64`, `.128`, **`.192`**. \n Zakres ostatniej podsieci: `192` (sieć) do `255` (broadcast). Adresy 200, 210, 220 mieszczą się w tym przedziale."
  },
  {
    "id": 35,
    "question": "Proszę wskazać zdania prawdziwe odnoszące się do protokołu DHCP:",
    "options": [
      {
        "text": "Serwer DHCP nasłuchuje zapytań na porcie 67 protokołu UDP",
        "inline_explanation": "(jest to port docelowy dla komunikatów wysyłanych przez klientów)",
        "correct": true
      },
      {
        "text": "Klient DHCP nasłuchuje odpowiedzi na porcie 68 protokołu UDP",
        "inline_explanation": "(na ten port serwer wysyła ofertę i potwierdzenie)",
        "correct": true
      },
      {
        "text": "DHCP wykorzystuje protokół TCP do gwarantowanego dostarczania adresów",
        "inline_explanation": "(nie, DHCP opiera się na `UDP` ze względu na szybkość i bezpołączeniowy charakter w fazie rozgłoszeniowej)",
        "correct": false
      },
      {
        "text": "Serwer DHCP przydziela adresy IP na stałe i nie mogą one ulec zmianie",
        "inline_explanation": "(adresy są dzierżawione na określony czas - Lease Time; po jego upływie klient musi odnowić dzierżawę)",
        "correct": false
      },
      {
        "text": "Typowa komunikacja przebiega w 4 krokach: Discover, Offer, Request, Acknowledge (DORA)",
        "inline_explanation": "(Klient szuka serwera, Serwer oferuje IP, Klient prosi o ten IP, Serwer potwierdza)",
        "correct": true
      }
    ],
    "explanation": "DHCP (Dynamic Host Configuration Protocol) służy do automatycznej konfiguracji ustawień sieciowych (IP, Maska, Brama, DNS). Działa w oparciu o protokół **UDP**. \n ⚫ **Serwer DHCP:** Nasłuchuje na porcie `UDP 67`. \n ⚫ **Klient DHCP:** Nasłuchuje (odbiera odpowiedzi) na porcie `UDP 68`. \nProces uzyskiwania adresu to tzw. DORA: DHCPDiscover (broadcast), DHCPOffer, DHCPRequest, DHCPAck."
  },
  {
    "id": 36,
    "question": "Które z następujących stwierdzeń dotyczących protokołu IPv4 są prawdziwe:",
    "options": [
      {
        "text": "jest protokołem bezpołączeniowym (connectionless)",
        "inline_explanation": "(nie wymaga nawiązania sesji/handshake'u przed wysyłką danych; każdy pakiet idzie niezależnie)",
        "correct": true
      },
      {
        "text": "działa w modelu \"best effort\"",
        "inline_explanation": "(nie gwarantuje dostarczenia danych, ich kolejności ani braku duplikatów)",
        "correct": true
      },
      {
        "text": "zapewnia bezbłędną i uporządkowaną transmisję danych",
        "inline_explanation": "(to rola protokołu warstwy transportowej, np. `TCP`, a nie warstwy sieciowej IP)",
        "correct": false
      },
      {
        "text": "jest protokołem warstwy łącza danych (Layer 2)",
        "inline_explanation": "(nie, IP to protokół warstwy 3 - Sieci, służący do adresowania logicznego i routingu)",
        "correct": false
      },
      {
        "text": "Nagłówek IPv4 zawiera sumę kontrolną obejmującą nagłówek i dane użytkownika (payload)",
        "inline_explanation": "(fałsz, `Header Checksum` w IPv4 chroni *tylko* nagłówek IP; poprawność danych weryfikują warstwy wyższe, np. TCP/UDP)",
        "correct": false
      }
    ],
    "explanation": "Protokół IP (Internet Protocol) w wersji 4 jest protokołem warstwy sieciowej (Layer 3). Jego główne cechy to:\n ⚫ **Bezpołączeniowość:** Nie nawiązuje sesji przed wysłaniem danych.\n ⚫ **Best Effort:** Nie daje gwarancji dostarczenia (pakiety mogą ginąć).\n ⚫ **Adresowanie:** Używa 32-bitowych adresów zapisywanych dziesiętnie (np. `192.168.1.1`)."
  },
  {
    "id": 37,
    "question": "Proszę wskazać zdania prawdziwe odnoszące się do systemu DNS:",
    "options": [
      {
        "text": "DNS dokonuje konwersji nazw domenowych na adresy IP (i odwrotnie)",
        "inline_explanation": "(tzw. Forward Lookup i Reverse Lookup)",
        "correct": true
      },
      {
        "text": "Jest to rozproszona, hierarchiczna baza danych",
        "inline_explanation": "(system składa się z tysięcy serwerów: Root, TLD, Authoritative; nie ma jednego centralnego komputera)",
        "correct": true
      },
      {
        "text": "Służy do dynamicznego przydzielania adresów IP komputerom w sieci",
        "inline_explanation": "(to zadanie protokołu `DHCP`; DNS to \"książka telefoniczna\", a nie \"urząd meldunkowy\")",
        "correct": false
      },
      {
        "text": "Działa wyłącznie w oparciu o protokół TCP",
        "inline_explanation": "(nie, standardowe zapytania używają `UDP 53` dla szybkości; `TCP 53` używane jest do transferu stref i dużych odpowiedzi)",
        "correct": false
      },
      {
        "text": "Rekord typu MX (Mail Exchange) w DNS wskazuje serwery pocztowe dla danej domeny",
        "inline_explanation": "(dzięki temu wysyłając e-mail na @firma.pl, serwer wie gdzie dostarczyć wiadomość)",
        "correct": true
      }
    ],
    "explanation": "DNS (Domain Name System) to hierarchiczny system nazw. Jego głównym zadaniem jest tłumaczenie nazw zrozumiałych dla człowieka (np. `google.com`) na adresy IP (np. `142.250.1.1`). Działa na porcie **53**, wykorzystując głównie **UDP** do zapytań (dla zapytań < 512 bajtów) oraz **TCP** do transferu stref (Zone Transfer) lub gdy odpowiedź jest zbyt duża."
  },
  {
    "id": 38,
    "question": "Protokół DHCP pozwala (zaznacz prawdziwe):",
    "options": [
      {
        "text": "uzyskać adres MAC i adres IP w komputerze podłączonym do sieci",
        "inline_explanation": "(fałsz, adres MAC jest fizycznie przypisany do karty sieciowej przez producenta, DHCP go nie nadaje)",
        "correct": false
      },
      {
        "text": "automatycznie skonfigurować adres IP, maskę podsieci i bramę domyślną hosta",
        "inline_explanation": "(podstawowa funkcja protokołu)",
        "correct": true
      },
      {
        "text": "przekazać klientowi adresy serwerów DNS",
        "inline_explanation": "(zazwyczaj opcja DHCP nr 6)",
        "correct": true
      },
      {
        "text": "zamienić prywatny adres IP na publiczny",
        "inline_explanation": "(to zadanie mechanizmu `NAT` - Network Address Translation, a nie DHCP)",
        "correct": false
      },
      {
        "text": "wskazać klientowi adres serwera TFTP i nazwę pliku rozruchowego (dla PXE Boot)",
        "inline_explanation": "(opcje 66 i 67, umożliwiające uruchomienie systemu operacyjnego przez sieć)",
        "correct": true
      }
    ],
    "explanation": "DHCP (Dynamic Host Configuration Protocol) konfiguruje parametry sieciowe hosta. Dostarcza: Adres IP, Maskę podsieci, Bramę domyślną, Adresy DNS, nazwę domeny itp.\n **Ważne:** Adres MAC (Media Access Control) jest fizycznym adresem karty sieciowej, nadanym przez producenta. Protokół DHCP **nie nadaje** adresu MAC. Wręcz przeciwnie - serwer DHCP zazwyczaj rozpoznaje klienta właśnie po jego unikalnym adresie MAC, aby przydzielić mu odpowiednie (lub zarezerwowane) IP."
  },
  {
    "id": 39,
    "question": "Podczas zapisu liczby wielobajtowej do pamięci komputera w procesorze o organizacji Big Endian:",
    "options": [
      {
        "text": "najbardziej znaczący bajt (MSB) umieszczony jest jako pierwszy (pod najniższym adresem)",
        "inline_explanation": "(zapis zgodny z naturalnym sposobem czytania liczb przez człowieka od lewej do prawej)",
        "correct": true
      },
      {
        "text": "najmniej znaczący bajt (LSB) umieszczony jest jako pierwszy",
        "inline_explanation": "(to definicja Little Endian, stosowanego np. przez procesory Intel/AMD)",
        "correct": false
      },
      {
        "text": "jest to format natywnie wykorzystywany przez procesory rodziny x86",
        "inline_explanation": "(nie, architektura x86 i x64 wykorzystuje Little Endian)",
        "correct": false
      },
      {
        "text": "kolejność bajtów nie ma znaczenia dla interpretacji liczby",
        "inline_explanation": "(ma kluczowe znaczenie; odwrócenie kolejności drastycznie zmienia wartość liczby)",
        "correct": false
      },
      {
        "text": "zgodnie z konwencją jest to tzw. sieciowa kolejność bajtów (Network Byte Order)",
        "inline_explanation": "(protokoły TCP/IP wymagają przesyłania danych w formacie Big Endian)",
        "correct": true
      }
    ],
    "explanation": "Kolejność bajtów (Endianness):\n ⚫ **Big Endian:** \"Duży koniec\" pierwszy. Najbardziej znaczący bajt (MSB - Most Significant Byte) jest zapisywany pod najniższym adresem pamięci. Jest to standard przyjęty w transmisji sieciowej (Network Byte Order) oraz w starszych procesorach (np. Motorola 68k, SPARC).\n ⚫ **Little Endian:** Najmniej znaczący bajt (LSB) jest pierwszy. Używane powszechnie przez procesory Intel/AMD (architektura x86)."
  },
  {
    "id": 40,
    "question": "Pamięć podręczna procesora (Cache):",
    "options": [
      {
        "text": "jest pamięcią nieulotną",
        "inline_explanation": "(fałsz, cache traci dane po zaniku zasilania)",
        "correct": false
      },
      {
        "text": "jest pamięcią ulotną (traci zawartość po zaniku zasilania)",
        "inline_explanation": "(zbudowana jest zazwyczaj z komórek SRAM)",
        "correct": true
      },
      {
        "text": "służy do przyspieszenia dostępu do danych poprzez przechowywanie kopii często używanych danych z pamięci operacyjnej",
        "inline_explanation": "(minimalizuje opóźnienia w dostępie do wolniejszego RAM-u)",
        "correct": true
      },
      {
        "text": "posiada czas dostępu dłuższy niż pamięć RAM",
        "inline_explanation": "(jest wielokrotnie szybsza od pamięci RAM, dlatego znajduje się bliżej rdzenia CPU)",
        "correct": false
      },
      {
        "text": "działa w oparciu o zasady lokalności czasowej i przestrzennej",
        "inline_explanation": "(zakłada, że procesor będzie wkrótce potrzebował tych samych danych lub danych z nimi sąsiadujących)",
        "correct": true
      }
    ],
    "explanation": "Pamięć podręczna procesora (L1, L2, L3) jest zbudowana z bardzo szybkich tranzystorów (pamięć **SRAM** - Static RAM). Jest to pamięć **ulotna** (volatile) - jej zawartość ginie po odłączeniu zasilania, tak samo jak w przypadku głównej pamięci operacyjnej (DRAM). Pamięcią nieulotną jest np. dysk twardy, SSD lub pamięć Flash (ROM/BIOS). Cache działa dzięki zasadzie lokalności odwołań, przewidując, jakie dane będą potrzebne procesorowi."
  },
  {
    "id": 41,
    "question": "Przetwarzanie potokowe (pipelining) w procesorach:",
    "options": [
      {
        "text": "dzieli cykl przetwarzania instrukcji na odrębne etapy (np. `fetch`, `decode`, `execute`)",
        "inline_explanation": "(dzięki temu różne układy procesora pracują jednocześnie nad różnymi instrukcjami)",
        "correct": true
      },
      {
        "text": "pozwala na zwiększenie przepustowości procesora (throughput)",
        "inline_explanation": "(zwiększa się liczba instrukcji kończonych w jednostce czasu)",
        "correct": true
      },
      {
        "text": "sprawia, że czas wykonania pojedynczej instrukcji (latency) ulega skróceniu",
        "inline_explanation": "(fałsz, czas wykonania jednej instrukcji jest taki sam lub nawet dłuższy przez narzut sterowania potokiem)",
        "correct": false
      },
      {
        "text": "umożliwia wykonywanie tylko jednej instrukcji na raz w całym procesorze",
        "inline_explanation": "(to opis procesora sekwencyjnego bez potoku)",
        "correct": false
      },
      {
        "text": "wymaga mechanizmów przewidywania skoków (Branch Prediction) dla zachowania wydajności",
        "inline_explanation": "(błędne przewidzenie skoku wymusza opróżnienie całego potoku, co kosztuje wiele cykli zegara)",
        "correct": true
      }
    ],
    "explanation": "Przetwarzanie potokowe to technika analogiczna do linii montażowej w fabryce. Proces wykonywania instrukcji dzielony jest na etapy (np. Pobranie, Dekodowanie, Wykonanie, Zapis). W jednym cyklu zegara procesor może kończyć jedną instrukcję, mimo że jej pełne wykonanie trwa kilka cykli. Kluczowe jest rozróżnienie: potokowość zwiększa **przepustowość** (ile instrukcji zrobimy w sekundę), ale nie skraca czasu wykonania pojedynczej instrukcji."
  },
  {
    "id": 42,
    "question": "W jakim trybie procesor rodziny x86 rozpoczyna pracę (po włączeniu zasilania lub twardym restarcie)?",
    "options": [
      {
        "text": "SMM (System Management Mode)",
        "inline_explanation": "(to tryb specjalny do zarządzania energią i sprzętem, niewidoczny dla OS)",
        "correct": false
      },
      {
        "text": "Tryb rzeczywisty (Real Mode)",
        "inline_explanation": "(tryb 16-bitowy zgodny z procesorem 8086, z dostępem do 1 MB pamięci)",
        "correct": true
      },
      {
        "text": "Tryb chroniony (Protected Mode)",
        "inline_explanation": "(tryb 32-bitowy z ochroną pamięci, do którego przełącza się bootloader/OS)",
        "correct": false
      },
      {
        "text": "Tryb wirtualny 8086 (Virtual 8086 Mode)",
        "inline_explanation": "(tryb emulacji starego procesora wewnątrz trybu chronionego)",
        "correct": false
      },
      {
        "text": "Tryb 64-bitowy (Long Mode)",
        "inline_explanation": "(nawet nowoczesne procesory i9/Ryzen startują w trybie 16-bitowym dla zachowania kompatybilności wstecznej)",
        "correct": false
      }
    ],
    "explanation": "Procesory z rodziny x86 (nawet najnowsze 64-bitowe) ze względu na kompatybilność wsteczną zawsze uruchamiają się w trybie **Rzeczywistym (Real Mode)**. W tym trybie zachowują się jak stary procesor 8086 (adresowanie 20-bitowe, brak ochrony pamięci). Dopiero system operacyjny (lub bootloader typu GRUB) programowo przełącza procesor w tryb Chroniony (Protected Mode), a następnie w tryb Long Mode (64-bit)."
  },
  {
    "id": 43,
    "question": "Do zmiany rozmiaru bufora odbiorczego dla gniazda sieciowego służy funkcja:",
    "options": [
      {
        "text": "`ioctl()`",
        "inline_explanation": "(służy głównie do sterowania urządzeniami wejścia/wyjścia, rzadziej do parametrów gniazd)",
        "correct": false
      },
      {
        "text": "`setsockopt()` z parametrem `SO_RCVBUF`",
        "inline_explanation": "(standardowa funkcja POSIX do konfiguracji opcji gniazd)",
        "correct": true
      },
      {
        "text": "`bind()`",
        "inline_explanation": "(służy do przypisania adresu IP i portu do gniazda)",
        "correct": false
      },
      {
        "text": "`socket()`",
        "inline_explanation": "(służy do utworzenia nowego deskryptora gniazda)",
        "correct": false
      },
      {
        "text": "`fcntl()`",
        "inline_explanation": "(służy do manipulacji deskryptorami plików, np. ustawiania trybu non-blocking `O_NONBLOCK`)",
        "correct": false
      }
    ],
    "explanation": "W standardowym API gniazd (Berkeley Sockets) do ustawiania opcji gniazda służy funkcja `setsockopt()` (Set Socket Option). Aby zmienić rozmiar bufora odbiorczego, używa się poziomu `SOL_SOCKET` i opcji `SO_RCVBUF` (a dla nadawczego `SO_SNDBUF`). Odpowiednie ustawienie buforów jest kluczowe dla wydajności w sieciach o dużym iloczynie przepustowości i opóźnienia (BDP)."
  },
  {
    "id": 44,
    "question": "W modelu komunikacji \"klient-serwer\" (TCP/IP), funkcja `bind()` musi być wywołana w procesie:",
    "options": [
      {
        "text": "klienta",
        "inline_explanation": "(klient zazwyczaj korzysta z automatycznego przydziału portu przez system podczas `connect`)",
        "correct": false
      },
      {
        "text": "serwera",
        "inline_explanation": "(serwer musi \"związać się\" z konkretnym portem, np. 80, aby klienci wiedzieli, gdzie się łączyć)",
        "correct": true
      },
      {
        "text": "zarówno klienta jak i serwera",
        "inline_explanation": "(klient może użyć `bind`, ale nie jest to wymagane i zazwyczaj się tego unika)",
        "correct": false
      },
      {
        "text": "nie jest wymagana w żadnym z procesów",
        "inline_explanation": "(bez `bind` serwer otrzymałby losowy port i nikt by go nie znalazł)",
        "correct": false
      },
      {
        "text": "tylko jeśli używamy protokołu UDP, w TCP jest zbędna",
        "inline_explanation": "(fałsz, w TCP jest niezbędna na serwerze przed wywołaniem `listen`)",
        "correct": false
      }
    ],
    "explanation": "Funkcja `bind()` przypisuje gniazdu konkretny adres IP i numer portu lokalnego.\n  \n ⚫ **Serwer:** **MUSI** wywołać `bind()`, aby nasłuchiwać na znanym porcie (np. HTTP na 80), do którego będą łączyć się klienci.\n ⚫ **Klient:** Zazwyczaj **NIE** wywołuje `bind()`. System operacyjny automatycznie przydziela mu wolny port (tzw. port efemeryczny) w momencie wywołania funkcji `connect()` (TCP) lub pierwszego `sendto()` (UDP). Ręczne bindowanie klienta stosuje się rzadko (np. gdy wymagają tego reguły firewalla)."
  },
  {
    "id": 45,
    "question": "Zakres adresów rozsyłania grupowego (multicast) dla protokołu IPv6 jest określony przez:",
    "options": [
      {
        "text": "pole TTL w nagłówku pakietu",
        "inline_explanation": "(w IPv6 pole to nazywa się `Hop Limit` i nie definiuje typu adresu)",
        "correct": false
      },
      {
        "text": "prefiks `ff00::/8`",
        "inline_explanation": "(pierwsze 8 bitów to same jedynki: `1111 1111` -> `FF`)",
        "correct": true
      },
      {
        "text": "prefiks `fe80::/10`",
        "inline_explanation": "(to adresy łącza lokalnego - Link-Local Unicast)",
        "correct": false
      },
      {
        "text": "ustawienie flagi M w nagłówku TCP",
        "inline_explanation": "(nagłówek warstwy 4 nie definiuje adresacji warstwy 3)",
        "correct": false
      },
      {
        "text": "prefiks `2000::/3`",
        "inline_explanation": "(to zakres adresów publicznych - Global Unicast)",
        "correct": false
      }
    ],
    "explanation": "W protokole IPv6 typ adresu rozpoznajemy po jego prefiksie (początkowych bitach). \n  \n Adresy **Multicast** (służące do wysyłania pakietów do grupy odbiorców) zawsze zaczynają się od oktetu `FF` (binarnie `1111 1111`). Zapis formalny to `ff00::/8`. Kolejne 4 bity to zazwyczaj flagi, a następne 4 to zakres (Scope, np. link-local, site-local, global)."
  },
  {
    "id": 46,
    "question": "Z czego wynikają interferencje międzysymbolowe (ISI - Inter-Symbol Interference) w radiowych sieciach dostępowych?",
    "options": [
      {
        "text": "z niedoskonałości filtrów częstotliwości",
        "inline_explanation": "(jest to możliwe źródło ISI, ale w kontekście kanału radiowego dominującym czynnikiem jest otoczenie)",
        "correct": false
      },
      {
        "text": "z propagacji wielodrogowej sygnału (Multipath Propagation)",
        "inline_explanation": "(odbicia sygnału od przeszkód powodują, że \"echa\" symbolu nakładają się na kolejny symbol)",
        "correct": true
      },
      {
        "text": "ze zbyt małej mocy nadajnika stacji bazowej",
        "inline_explanation": "(to wpływa na stosunek sygnału do szumu - SNR, a nie na ISI)",
        "correct": false
      },
      {
        "text": "z wykorzystania modulacji amplitudy zamiast częstotliwości",
        "inline_explanation": "(rodzaj modulacji analogowej nie jest bezpośrednią przyczyną zjawiska w transmisji cyfrowej)",
        "correct": false
      },
      {
        "text": "z efektu Dopplera",
        "inline_explanation": "(Doppler powoduje przesunięcie częstotliwości przy ruchu, a nie nakładanie się symboli w czasie)",
        "correct": false
      }
    ],
    "explanation": "W komunikacji radiowej (np. Wi-Fi, LTE) sygnał dociera do anteny odbiorczej różnymi drogami (odbicia od budynków, ziemi). \n  \n Powoduje to, że kopie tego samego sygnału docierają z różnym opóźnieniem. Jeśli opóźnienie (delay spread) jest duże, \"ogon\" (echo) poprzedniego symbolu $N-1$ nakłada się na początek aktualnie odbieranego symbolu $N$, zakłócając jego odczyt. Aby temu zapobiec, stosuje się np. **Cyclic Prefix** w modulacji OFDM."
  },
  {
    "id": 47,
    "question": "Jakie dodatkowe zjawiska, w porównaniu z łącznością radiową dla łączy stałych typu punkt-punkt, należy uwzględnić dla łączności mobilnej?",
    "options": [
      {
        "text": "efekt Dopplera",
        "inline_explanation": "(zmiana częstotliwości fali nośnej wynikająca z ruchu nadajnika lub odbiornika)",
        "correct": true
      },
      {
        "text": "szybkie zaniki sygnału (Fast Fading) oraz konieczność realizacji procedury handover",
        "inline_explanation": "(sygnał zmienia się dynamicznie co milisekundy; terminal musi płynnie przełączać się między stacjami)",
        "correct": true
      },
      {
        "text": "tłumienie sygnału w wolnej przestrzeni (Free Space Path Loss)",
        "inline_explanation": "(to zjawisko występuje w każdym typie łączności radiowej, również stacjonarnej)",
        "correct": false
      },
      {
        "text": "zjawisko załamania fal (refrakcja)",
        "inline_explanation": "(również występuje w obu typach łączności)",
        "correct": false
      },
      {
        "text": "zjawisko cienia (Shadowing)",
        "inline_explanation": "(nagły spadek mocy sygnału gdy użytkownik wejdzie za przeszkodę, np. budynek)",
        "correct": true
      }
    ],
    "explanation": "W łączności mobilnej (komórkowej) co najmniej jedna ze stron (terminal) się porusza. Ruch ten wprowadza specyficzne problemy:\n ⚫ **Efekt Dopplera:** Zmiana częstotliwości fali proporcjonalna do prędkości (istotne np. w szybkich pociągach).\n ⚫ **Fast Fading:** Gwałtowne zmiany siły sygnału na krótkich odcinkach.\n ⚫ **Handover:** Konieczność programowego przełączania aktywnej sesji między komórkami (BTS) bez zrywania połączenia."
  },
  {
    "id": 48,
    "question": "Minimalna wielkość ramki standardu Ethernet (bez preambuły) wynosi:",
    "options": [
      {
        "text": "48 bitów",
        "inline_explanation": "(to długość adresu MAC, a nie całej ramki)",
        "correct": false
      },
      {
        "text": "64 bajty (512 bitów)",
        "inline_explanation": "(wynika to z wymogów mechanizmu wykrywania kolizji CSMA/CD)",
        "correct": true
      },
      {
        "text": "1500 bajtów",
        "inline_explanation": "(to typowe MTU - Maximum Transmission Unit, czyli max. ilość danych w ramce)",
        "correct": false
      },
      {
        "text": "1518 bajtów",
        "inline_explanation": "(to maksymalna całkowita wielkość ramki standardowej: 1500 danych + 18 nagłówka)",
        "correct": false
      },
      {
        "text": "9000 bajtów",
        "inline_explanation": "(to rozmiar tzw. Jumbo Frames, niestandardowego rozszerzenia dla gigabitowych sieci)",
        "correct": false
      }
    ],
    "explanation": "Aby mechanizm wykrywania kolizji (CSMA/CD) działał poprawnie w klasycznym Ethernecie, nadajnik musi nadawać ramkę przez czas wystarczający na dotarcie sygnału do najdalszego punktu sieci i powrót ewentualnego sygnału kolizji (Slot Time). Minimalna długość ramki została ustalona na **64 bajty** (512 bitów). Jeśli danych użytkownika jest mniej (np. 10 bajtów), sterownik karty sieciowej musi dopełnić ramkę zerami (padding) do 64 bajtów."
  },
  {
    "id": 49,
    "question": "Serwer DHCP przydziela adresy z sieci 192.168.0.0. Jaką najdłuższą maskę należy przypisać sieci, aby obsłużyć 512 hostów?",
    "options": [
      {
        "text": "255.255.255.128 (/25)",
        "inline_explanation": "(tylko 126 hostów; za mało)",
        "correct": false
      },
      {
        "text": "255.255.252.0 (/22)",
        "inline_explanation": "(1022 hosty; wystarczy i jest najbardziej dopasowana z poprawnych)",
        "correct": true
      },
      {
        "text": "255.255.254.0 (/23)",
        "inline_explanation": "(510 hostów; pułapka - brakuje dokładnie 2 adresów dla wymaganych 512 urządzeń)",
        "correct": false
      },
      {
        "text": "255.255.0.0 (/16)",
        "inline_explanation": "(65534 hosty; pomieści, ale pytanie wymagało \"najdłuższej możliwej maski\", czyli najmniejszej sieci spełniającej wymogi)",
        "correct": false
      },
      {
        "text": "/22 (zapis CIDR)",
        "inline_explanation": "(to samo co 255.255.252.0)",
        "correct": true
      }
    ],
    "explanation": "Potrzebujemy adresów dla **512 urządzeń**. Wzór na liczbę hostów: $2^h - 2$ (adres sieci i broadcastu).\n ⚫ Maska `/23` (9 bitów hosta): $2^9 - 2 = 512 - 2 = 510$ adresów użytecznych. (Za mało).\n ⚫ Maska `/22` (10 bitów hosta): $2^{10} - 2 = 1024 - 2 = 1022$ adresy użyteczne. (Wystarczy).\nNajdłuższa maska (czyli dająca najmniejszą podsieć), która pomieści 512 hostów to **/22** (255.255.252.0)."
  },
  {
    "id": 50,
    "question": "Protokół ARP (Address Resolution Protocol):",
    "options": [
      {
        "text": "jest stosowany w przypadku maszyn bezdyskowych do pobrania adresu IP",
        "inline_explanation": "(to opis protokołu `RARP` - Reverse ARP)",
        "correct": false
      },
      {
        "text": "służy do mapowania adresu IP (warstwa 3) na adres fizyczny MAC (warstwa 2)",
        "inline_explanation": "(kluczowa funkcja umożliwiająca komunikację w sieci Ethernet)",
        "correct": true
      },
      {
        "text": "działa w warstwie aplikacji modelu ISO/OSI",
        "inline_explanation": "(nie, ARP to protokół pomocniczy działający na styku warstwy 2 i 3)",
        "correct": false
      },
      {
        "text": "służy do routingu pakietów między różnymi sieciami WAN",
        "inline_explanation": "(ARP działa tylko w obrębie lokalnej domeny rozgłoszeniowej - LAN)",
        "correct": false
      },
      {
        "text": "wykorzystuje mechanizm Gratuitous ARP do wykrywania konfliktów adresów IP",
        "inline_explanation": "(urządzenie ogłasza swój adres, by sprawdzić, czy ktoś inny go nie używa)",
        "correct": true
      }
    ],
    "explanation": "ARP służy do mapowania adresu logicznego (IP) na adres fizyczny (MAC). Gdy komputer chce wysłać pakiet do `192.168.1.5`, musi znać adres MAC karty sieciowej tego urządzenia. Wysyła więc zapytanie ARP Broadcast (\"Kto ma 192.168.1.5?\"). Właściwy komputer odpowiada swoim MAC-iem. Dla maszyn bezdyskowych (bootowanie) stosuje się odwrotny protokół: RARP (lub DHCP)."
  },
  {
    "id": 51,
    "question": "Jakie metody wielodostępu są wykorzystywane w interfejsie radiowym sieci LTE?",
    "options": [
      {
        "text": "OFDMA (w łączu \"w dół\" - Downlink)",
        "inline_explanation": "(podział pasma na wiele ortogonalnych podnośnych, co niweluje problem interferencji międzysymbolowych)",
        "correct": true
      },
      {
        "text": "SC-FDMA (w łączu \"w górę\" - Uplink)",
        "inline_explanation": "(zmodyfikowana wersja OFDMA z mniejszym wskaźnikiem PAPR, co oszczędza baterię w telefonie)",
        "correct": true
      },
      {
        "text": "CSMA/CD",
        "inline_explanation": "(mechanizm wykrywania kolizji stosowany w sieciach Ethernet, a nie komórkowych)",
        "correct": false
      },
      {
        "text": "TDMA (Time Division Multiple Access)",
        "inline_explanation": "(główna metoda wielodostępu w sieciach 2G GSM)",
        "correct": false
      },
      {
        "text": "CDMA (Code Division Multiple Access)",
        "inline_explanation": "(technologia z rozpraszaniem widma, charakterystyczna dla sieci 3G UMTS)",
        "correct": false
      }
    ],
    "explanation": "Standard LTE (Long Term Evolution) wykorzystuje różne techniki dla łącza w dół i w górę: \n  \n ⚫ **Downlink (DL):** **OFDMA**. Zapewnia wysoką odporność na wielodrogowość. \n ⚫ **Uplink (UL):** **SC-FDMA** (Single Carrier FDMA). Został wybrany ze względu na mniejszy stosunek mocy szczytowej do średniej (PAPR - Peak-to-Average Power Ratio). Dzięki temu wzmacniacz w telefonie pracuje wydajniej i bateria wystarcza na dłużej."
  },
  {
    "id": 52,
    "question": "Przepływność bitowa strumienia danych dla usługi głosowej w systemie GSM zwiększa się przez:",
    "options": [
      {
        "text": "kodowanie źródłowe (Source Coding)",
        "inline_explanation": "(cel to kompresja mowy, np. kodek RPE-LTP; zmniejsza ilość danych)",
        "correct": false
      },
      {
        "text": "kodowanie kanałowe (Channel Coding)",
        "inline_explanation": "(dodanie nadmiarowości/bitów parzystości w celu korekcji błędów transmisji)",
        "correct": true
      },
      {
        "text": "zastosowanie modulacji wyższego rzędu",
        "inline_explanation": "(to pozwala przesłać więcej bitów w symbolu, ale nie zmienia rozmiaru samego strumienia danych przed modulacją)",
        "correct": false
      },
      {
        "text": "szyfrowanie algorytmem A5/1",
        "inline_explanation": "(szyfrowanie strumieniowe zazwyczaj zachowuje długość ciągu bitów)",
        "correct": false
      },
      {
        "text": "zastosowanie przeplotu (Interleaving)",
        "inline_explanation": "(zmienia kolejność bitów, aby uodpornić transmisję na błędy seryjne, ale nie dodaje nowych bitów)",
        "correct": false
      }
    ],
    "explanation": "W telekomunikacji proces przetwarzania mowy przebiega etapami: \n  \n 1. **Kodowanie źródłowe:** Kompresja (zmniejsza bitrate, np. do 13 kbit/s). \n 2. **Kodowanie kanałowe:** Ochrona przed błędami. Dodaje nadmiarowe bity (redundancję), co **zwiększa** całkowitą przepływność (w GSM z 13 kbit/s do 22.8 kbit/s). \n Pytanie dotyczy zwiększenia przepływności, więc poprawną odpowiedzią jest kodowanie kanałowe."
  },
  {
    "id": 53,
    "question": "Realna pojemność (przepustowość) komórki w systemie LTE zależy od:",
    "options": [
      {
        "text": "średniej efektywności widmowej realizowanych transmisji",
        "inline_explanation": "(zależy od warunków radiowych SINR, co pozwala na użycie gęstszej modulacji np. 64QAM)",
        "correct": true
      },
      {
        "text": "szerokości dostępnego pasma częstotliwości (Bandwidth)",
        "inline_explanation": "(np. kanał 20 MHz oferuje 2x większą przepływność niż 10 MHz)",
        "correct": true
      },
      {
        "text": "konfiguracji antenowej MIMO (Multiple Input Multiple Output)",
        "inline_explanation": "(wysyłanie wielu strumieni danych równolegle na tej samej częstotliwości)",
        "correct": true
      },
      {
        "text": "wyłącznie od odległości użytkownika od stacji bazowej",
        "inline_explanation": "(odległość wpływa na jakość sygnału, ale nie jest jedynym czynnikiem determinującym pojemność)",
        "correct": false
      },
      {
        "text": "częstotliwości nośnej (np. 800 MHz vs 2600 MHz)",
        "inline_explanation": "(częstotliwość wpływa na zasięg/tłumienie, ale 20 MHz pasma na 800 MHz daje teoretycznie taką samą pojemność jak 20 MHz na 2600 MHz)",
        "correct": false
      }
    ],
    "explanation": "Pojemność sieci komórkowej wynika z twierdzenia Shannona-Hartleya: $C = B \\cdot \\log_2(1 + \\frac{S}{N})$. \n  \n Kluczowe czynniki to: \n ⚫ **Szerokość pasma (B):** Im szerszy kanał, tym szybciej. \n ⚫ **MIMO:** Pozwala pomnożyć przepływność przez liczbę anten (przestrzenne multipleksowanie). \n ⚫ **Efektywność widmowa:** Zależna od jakości sygnału (SINR) i użytej modulacji."
  },
  {
    "id": 54,
    "question": "W systemie Unix/Linux, narzędziem służącym do konfiguracji interfejsu sieciowego jest:",
    "options": [
      {
        "text": "`ipconfig`",
        "inline_explanation": "(to standardowe polecenie w systemach rodziny Windows)",
        "correct": false
      },
      {
        "text": "`ifconfig`",
        "inline_explanation": "(klasyczne narzędzie z pakietu `net-tools`, obecnie często zastępowane przez `ip`)",
        "correct": true
      },
      {
        "text": "`ip`",
        "inline_explanation": "(nowoczesne narzędzie z pakietu `iproute2`, np. polecenie `ip addr show`)",
        "correct": true
      },
      {
        "text": "`winipcfg`",
        "inline_explanation": "(graficzne narzędzie z historycznych systemów Windows 95/98)",
        "correct": false
      },
      {
        "text": "`netstat`",
        "inline_explanation": "(służy do wyświetlania statystyk połączeń i otwartych portów, a nie do konfiguracji IP)",
        "correct": false
      }
    ],
    "explanation": "Należy rozróżnić narzędzia Windowsowe od Linuxowych. \n  \n ⚫ **Windows:** `ipconfig`. \n ⚫ **Linux (Legacy):** `ifconfig` (nadal powszechne, ale uznane za przestarzałe). \n ⚫ **Linux (Modern):** Polecenie `ip` (np. `ip link`, `ip addr`, `ip route`). Jest potężniejsze i obsługuje nowsze funkcje kernela."
  },
  {
    "id": 55,
    "question": "Ścieżka w sieci MPLS (LSP - Label Switched Path) jest:",
    "options": [
      {
        "text": "obiektem o losowo zmiennych parametrach",
        "inline_explanation": "(ścieżka jest deterministyczna, ustalona przez protokoły routingu lub inżynierię ruchu)",
        "correct": false
      },
      {
        "text": "jednokierunkowa (unidirectional)",
        "inline_explanation": "(to kluczowa cecha; ruch powrotny musi iść osobną ścieżką LSP)",
        "correct": true
      },
      {
        "text": "zawsze dwukierunkowa",
        "inline_explanation": "(aby uzyskać dwukierunkowość, routery muszą zestawić parę ścieżek LSP)",
        "correct": false
      },
      {
        "text": "zestawiana wyłącznie manualnie przez administratora",
        "inline_explanation": "(może być dynamiczna dzięki protokołom takim jak LDP czy RSVP-TE)",
        "correct": false
      },
      {
        "text": "ścieżką działającą w warstwie aplikacji (Layer 7)",
        "inline_explanation": "(MPLS działa między warstwą 2 a 3, stąd nazwa \"Layer 2.5\")",
        "correct": false
      }
    ],
    "explanation": "MPLS (Multiprotocol Label Switching) tworzy ścieżki zwane LSP. \n  \n Kluczową cechą LSP jest to, że jest ona **jednokierunkowa**. Routery na brzegu sieci (LER) nadają etykiety, a routery wewnątrz (LSR) przełączają pakiety wyłącznie na ich podstawie, bez zaglądania w nagłówek IP."
  },
  {
    "id": 56,
    "question": "Poprawiać skuteczność działania sieci neuronowej (tuning hiperparametrów) można zmieniając m.in.:",
    "options": [
      {
        "text": "Funkcje aktywacji, liczbę klastrów, typ optymalizatora",
        "inline_explanation": "(błąd: liczba klastrów to parametr algorytmów uczenia nienadzorowanego, np. K-means, a nie sieci neuronowych)",
        "correct": false
      },
      {
        "text": "Funkcje aktywacji, liczbę warstw ukrytych, współczynnik uczenia (learning rate)",
        "inline_explanation": "(to kluczowe hiperparametry wpływające na zdolność sieci do aproksymacji funkcji)",
        "correct": true
      },
      {
        "text": "Architekturę sieci, typ optymalizatora, rozmiar wsadu (batch size)",
        "inline_explanation": "(zmiana wielkości batcha wpływa na stabilność i szybkość zbieżności procesu uczenia)",
        "correct": true
      },
      {
        "text": "Jedynie kolor obudowy komputera na którym prowadzone są obliczenia",
        "inline_explanation": "(aspekt wizualny sprzętu nie ma wpływu na matematykę sieci)",
        "correct": false
      },
      {
        "text": "Współczynnik odrzucenia (Dropout rate) oraz techniki augmentacji danych",
        "inline_explanation": "(techniki te zapobiegają przeuczeniu się sieci - overfittingowi)",
        "correct": true
      }
    ],
    "explanation": "Aby \"dostroić\" sieć neuronową, manipulujemy hiperparametrami. \n  \n Do najważniejszych należą: \n ⚫ **Learning Rate:** Jak duże kroki robimy podczas optymalizacji. \n ⚫ **Architektura:** Liczba warstw i neuronów. \n ⚫ **Funkcje aktywacji:** np. ReLU, Sigmoid. \n Pojęcie \"liczby klastrów\" dotyczy analizy skupień (clustering), co jest inną dziedziną uczenia maszynowego."
  },
  {
    "id": 57,
    "question": "Które z poniższych poleceń SQL spowodują całkowite usunięcie tabeli `tblname` (struktury i danych) z bazy?",
    "options": [
      {
        "text": "`DELETE FROM tblname ;`",
        "inline_explanation": "(usuwa wszystkie wiersze, ale pusta tabela pozostaje w bazie)",
        "correct": false
      },
      {
        "text": "`DROP TABLE tblname ;`",
        "inline_explanation": "(usuwa trwale definicję tabeli oraz wszystkie zgromadzone w niej dane)",
        "correct": true
      },
      {
        "text": "`TRUNCATE TABLE tblname ;`",
        "inline_explanation": "(szybkie usunięcie wierszy poprzez zwolnienie stron pamięci, ale struktura tabeli zostaje)",
        "correct": false
      },
      {
        "text": "`ERASE tblname ;`",
        "inline_explanation": "(niepoprawna składnia w standardzie SQL)",
        "correct": false
      },
      {
        "text": "`REMOVE TABLE tblname ;`",
        "inline_explanation": "(błąd składniowy; słowo kluczowe `REMOVE` nie służy do usuwania tabel)",
        "correct": false
      }
    ],
    "explanation": "W SQL mamy rozróżnienie na usuwanie danych (DML) i struktur (DDL): \n ⚫ `DELETE` i `TRUNCATE` czyszczą zawartość, ale \"szkielet\" tabeli zostaje. \n ⚫ `DROP` to polecenie niszczące obiekt - usuwa tabelę całkowicie z systemu."
  },
  {
    "id": 58,
    "question": "Jeżeli polecenie `SELECT * FROM tblname ...` zwraca jeden wiersz, to (wg standardu SQL) kolejność zwróconych kolumn:",
    "options": [
      {
        "text": "pokrywa się z kolejnością definicji kolumn w poleceniu `CREATE TABLE`",
        "inline_explanation": "(silnik bazy zwraca kolumny w kolejności ich fizycznego/logicznego utworzenia w schemacie)",
        "correct": true
      },
      {
        "text": "jest losowa i zależy od aktualnego obciążenia serwera",
        "inline_explanation": "(kolejność kolumn jest deterministyczna, w przeciwieństwie do kolejności wierszy)",
        "correct": false
      },
      {
        "text": "jest zawsze alfabetyczna według nazw kolumn",
        "inline_explanation": "(nie, chyba że tabela została tak specyficznie utworzona)",
        "correct": false
      },
      {
        "text": "zależy od typów danych (najpierw liczbowe, potem tekstowe)",
        "inline_explanation": "(standard SQL nie grupuje kolumn typami przy wyświetlaniu)",
        "correct": false
      },
      {
        "text": "zależy od tego, która kolumna jest kluczem głównym (Primary Key)",
        "inline_explanation": "(klucz główny nie wymusza bycia pierwszą kolumną w wynikach, choć często jest tak definiowany)",
        "correct": false
      }
    ],
    "explanation": "Użycie gwiazdki (`*`) w zapytaniu `SELECT` oznacza pobranie wszystkich kolumn. Standard SQL określa, że kolumny zostaną zwrócone w kolejności, w jakiej zostały zdefiniowane w strukturze tabeli (czyli w kolejności z polecenia `CREATE TABLE`, chyba że użyto `ALTER TABLE` zmieniającego ten porządek w silniku)."
  },
  {
    "id": 59,
    "question": "W bazie istnieje tabela `osoby` z kolumną `imie`. Które z zapytań są poprawne składniowo?",
    "options": [
      {
        "text": "`SELECT * FROM osoby p WHERE imie = 'Jan';`",
        "inline_explanation": "(poprawne; mimo aliasu `p`, kolumna `imie` jest jednoznaczna)",
        "correct": true
      },
      {
        "text": "`SELECT p.imie FROM osoby p WHERE p.imie = 'Jan';`",
        "inline_explanation": "(poprawne i zalecane; pełna kwalifikacja z użyciem zdefiniowanego aliasu)",
        "correct": true
      },
      {
        "text": "`SELECT * FROM osoby p WHERE osoby.imie = 'Jan';`",
        "inline_explanation": "(często błąd; w wielu dialektach SQL zdefiniowanie aliasu `p` ukrywa oryginalną nazwę `osoby`)",
        "correct": false
      },
      {
        "text": "`SELECT \"imie\" FROM osoby;`",
        "inline_explanation": "(ryzykowne; cudzysłowy oznaczają identyfikator wrażliwy na wielkość liter, co może nie zadziałać w zależności od bazy)",
        "correct": false
      },
      {
        "text": "`SELECT imie FROM osoby AS p WHERE p.imie = 'Jan';`",
        "inline_explanation": "(poprawne; słowo kluczowe `AS` jest opcjonalne, ale zwiększa czytelność)",
        "correct": true
      }
    ],
    "explanation": "Nadawanie aliasów (np. `FROM osoby p`) służy skróceniu zapisu. Warto pamiętać, że w większości silników SQL, gdy nadasz tabeli alias, powinieneś go używać. Odwoływanie się przez oryginalną nazwę tabeli (`osoby.imie`) w zapytaniu, które zdefiniowało alias (`osoby p`), często kończy się błędem \"Table not found\", ponieważ alias \"przykrywa\" oryginalną nazwę w zakresie tego zapytania."
  },
  {
    "id": 60,
    "question": "Które z poniższych stwierdzeń dotyczących wartości `NULL` w SQL są prawdziwe?",
    "options": [
      {
        "text": "wyrażenie `40 + 60 + NULL` zwraca `100`",
        "inline_explanation": "(każda operacja arytmetyczna z NULL daje w wyniku NULL)",
        "correct": false
      },
      {
        "text": "wyrażenie `40 + 60 + NULL` zwraca `NULL`",
        "inline_explanation": "(NULL oznacza wartość nieznaną, więc wynik dodawania też jest nieznany)",
        "correct": true
      },
      {
        "text": "porównanie `NULL = NULL` zwraca `UNKNOWN` (lub fałsz)",
        "inline_explanation": "(do sprawdzania NULL używa się operatora `IS NULL`, a nie `=`)",
        "correct": true
      },
      {
        "text": "funkcja `count(*)` ignoruje wiersze z wartościami NULL",
        "inline_explanation": "(nie, `count(*)` liczy wszystkie wiersze; to `count(kolumna)` ignoruje NULL-e w tej kolumnie)",
        "correct": false
      },
      {
        "text": "porównanie `NULL != NULL` zwraca `TRUE`",
        "inline_explanation": "(nie, wynik każdego porównania z NULL to UNKNOWN/NULL)",
        "correct": false
      }
    ],
    "explanation": "W SQL obowiązuje **logika trójwartościowa** (3VL). \n  \n Wartość logiczna może być: Prawdą (`TRUE`), Fałszem (`FALSE`) lub Nieznaną (`UNKNOWN`). \n `NULL` oznacza brak danych. Operacja `NULL = NULL` nie jest prawdą, bo nie wiemy, czy jedna nieznana wartość jest równa drugiej. Dlatego wynik to `UNKNOWN` (w `WHERE` traktowany jak fałsz)."
  },
  {
    "id": 61,
    "question": "W zapytaniu: `SELECT imie, zarobki FROM osoby WHERE zarobki > (SELECT avg(zarobki) FROM osoby);`",
    "options": [
      {
        "text": "zastosowano podzapytanie proste (nieskorelowane)",
        "inline_explanation": "(podzapytanie wykonuje się raz, zwraca jedną wartość i nie zależy od zapytania głównego)",
        "correct": true
      },
      {
        "text": "zastosowano podzapytanie skorelowane (correlated subquery)",
        "inline_explanation": "(fałsz, podzapytanie nie odwołuje się do aliasu tabeli z zapytania zewnętrznego)",
        "correct": false
      },
      {
        "text": "zapytanie jest błędne, nie można używać funkcji agregujących w podzapytaniach",
        "inline_explanation": "(można, pod warunkiem że podzapytanie zwraca pojedynczą wartość - skalar, co tutaj zachodzi)",
        "correct": false
      },
      {
        "text": "zastosowano złączenie typu `OUTER JOIN`",
        "inline_explanation": "(brak słowa kluczowego JOIN; to jest filtrowanie w klauzuli WHERE)",
        "correct": false
      },
      {
        "text": "podzapytanie zwróci błąd, jeśli tabela `osoby` jest pusta",
        "inline_explanation": "(funkcja `AVG` na pustym zbiorze zwraca `NULL`, co sprawi, że porównanie `>` zwróci `UNKNOWN`, a wynik będzie po prostu pusty - bez błędu)",
        "correct": false
      }
    ],
    "explanation": "Mamy tu podzapytanie: `(SELECT avg(zarobki) FROM osoby)`. \n To podzapytanie: \n 1. Może zostać wykonane niezależnie od zapytania zewnętrznego. \n 2. Zwraca pojedynczą wartość (średnią pensję wszystkich osób). \n 3. Jest wykonywane tylko raz dla całego zapytania. \nJest to definicja **podzapytania prostego** (nieskorelowanego). Gdyby podzapytanie odwoływało się do wiersza z zapytania zewnętrznego (np. `WHERE oddzial = o.oddzial`), byłoby to podzapytanie skorelowane (wykonywane dla każdego wiersza)."
  },
  {
    "id": 62,
    "question": "Które deklaracje zmiennej w języku PL/SQL są poprawne?",
    "options": [
      {
        "text": "`ilosc int NOT NULL ;`",
        "inline_explanation": "(błąd: zmienna z ograniczeniem `NOT NULL` musi zostać zainicjalizowana od razu)",
        "correct": false
      },
      {
        "text": "`ilosc int NOT NULL := 0 ;`",
        "inline_explanation": "(poprawne: zadeklarowano typ, ograniczenie i wartość początkową)",
        "correct": true
      },
      {
        "text": "`ilosc int ;`",
        "inline_explanation": "(poprawne: zmienna otrzyma domyślną wartość `NULL`)",
        "correct": true
      },
      {
        "text": "`ilosc number(5) DEFAULT 10 ;`",
        "inline_explanation": "(poprawne: `DEFAULT` działa analogicznie do operatora przypisania `:=`)",
        "correct": true
      },
      {
        "text": "`ilosc int = 10 ;`",
        "inline_explanation": "(błąd składni: w PL/SQL do przypisania służy operator `:=`, a pojedyncze `=` służy do porównania)",
        "correct": false
      }
    ],
    "explanation": "PL/SQL (język proceduralny Oracle). Deklaracja: `ilosc int NOT NULL;` jest błędna. Jeśli nakładamy na zmienną ograniczenie `NOT NULL`, zmienna ta **musi** zostać zainicjalizowana w momencie deklaracji. Domyślnie zmienne otrzymują wartość `NULL`, co naruszyłoby ten warunek."
  },
  {
    "id": 63,
    "question": "Utworzenie indeksu (np. B-Tree) na kolumnie tabeli:",
    "options": [
      {
        "text": "zazwyczaj przyspiesza wszystkie operacje na bazie danych",
        "inline_explanation": "(mit; przyspiesza odczyt, ale spowalnia zapis)",
        "correct": false
      },
      {
        "text": "przyspiesza operacje odczytu (`SELECT`), ale spowalnia operacje modyfikacji (`INSERT`, `UPDATE`, `DELETE`)",
        "inline_explanation": "(baza musi aktualizować strukturę drzewa indeksu przy każdej zmianie danych)",
        "correct": true
      },
      {
        "text": "zwiększa zajętość przestrzeni dyskowej",
        "inline_explanation": "(indeks to dodatkowa struktura danych, która zajmuje miejsce na dysku)",
        "correct": true
      },
      {
        "text": "nie ma wpływu na wydajność bazy danych",
        "inline_explanation": "(ma kluczowy wpływ na wydajność zapytań)",
        "correct": false
      },
      {
        "text": "pozwala na szybsze sortowanie wyników (`ORDER BY`) po zaindeksowanej kolumnie",
        "inline_explanation": "(indeks przechowuje dane w sposób uporządkowany, więc silnik bazy nie musi ich sortować w locie)",
        "correct": true
      }
    ],
    "explanation": "Indeks w bazie danych  działa jak skorowidz w książce. \n ⚫ **Zaleta:** Znacznie przyspiesza operacje wyszukiwania (`SELECT ... WHERE`), sortowania i łączenia tabel. \n ⚫ **Wada:** Spowalnia operacje modyfikacji danych (`INSERT`, `UPDATE`, `DELETE`). \nDlaczego? Ponieważ przy każdym dodaniu lub usunięciu wiersza, baza danych musi nie tylko zaktualizować samą tabelę, ale też przebudować lub zbalansować strukturę indeksu."
  },
  {
    "id": 64,
    "question": "Przed którymi zjawiskami chroni poziom izolacji transakcji \"Read Committed\" (domyślny w PostgreSQL/Oracle)?",
    "options": [
      {
        "text": "Dirty Read (Brudny odczyt)",
        "inline_explanation": "(gwarantuje, że czytamy tylko dane, które zostały już zatwierdzone przez inne transakcje)",
        "correct": true
      },
      {
        "text": "Non-repeatable Read (Niepowtarzalny odczyt)",
        "inline_explanation": "(przed tym chroni dopiero wyższy poziom: `Repeatable Read`)",
        "correct": false
      },
      {
        "text": "Phantom Read (Odczyt widmo)",
        "inline_explanation": "(przed tym chroni najwyższy poziom: `Serializable` lub snapshot isolation)",
        "correct": false
      },
      {
        "text": "Utrata danych w wyniku awarii zasilania",
        "inline_explanation": "(to zadanie dziennika transakcyjnego WAL/Redo Log, a nie poziomu izolacji)",
        "correct": false
      },
      {
        "text": "Lost Update (Utracona aktualizacja)",
        "inline_explanation": "(Read Committed zazwyczaj nie chroni przed nadpisaniem zmian, jeśli dwie transakcje edytują ten sam wiersz jednocześnie bez blokad)",
        "correct": false
      }
    ],
    "explanation": "Poziomy izolacji transakcji (wg standardu SQL)  chronią przed różnymi anomaliami: \n ⚫ **Dirty Read:** Czytanie danych, które inna transakcja zmieniła, ale jeszcze nie zatwierdziła (`COMMIT`). \n ⚫ **Non-repeatable Read:** W ramach jednej transakcji to samo zapytanie zwraca inne wartości, bo ktoś inny zmienił dane w międzyczasie. \n ⚫ **Phantom Read:** Pojawienie się nowych wierszy spełniających warunek zapytania. \n Tryb `Read Committed` gwarantuje tylko to pierwsze."
  },
  {
    "id": 65,
    "question": "Jaki znacznik HTML definiuje wewnętrzny arkusz styli CSS?",
    "options": [
      {
        "text": "`<style>`",
        "inline_explanation": "(umieszczany w sekcji `<head>`, zawiera reguły CSS dla bieżącego dokumentu)",
        "correct": true
      },
      {
        "text": "`<css>`",
        "inline_explanation": "(taki znacznik nie istnieje w specyfikacji HTML)",
        "correct": false
      },
      {
        "text": "`<script>`",
        "inline_explanation": "(służy do osadzania skryptów, głownie JavaScript)",
        "correct": false
      },
      {
        "text": "`<link>`",
        "inline_explanation": "(służy do dołączania **zewnętrznych** zasobów, np. plików .css)",
        "correct": false
      },
      {
        "text": "`@import`",
        "inline_explanation": "(to dyrektywa CSS używana wewnątrz arkusza stylów, a nie znacznik HTML)",
        "correct": false
      }
    ],
    "explanation": "Sposoby dołączania CSS do HTML: \n 1. **Zewnętrzny:** Znacznik `<link rel=\"stylesheet\" href=\"style.css\">` (najlepsza praktyka). \n 2. **Wewnętrzny:** Znacznik `<style> ... </style>` w sekcji head. \n 3. **Liniowy (Inline):** Atrybut `style=\"...\"` w konkretnym elemencie HTML (np. `<p style=\"color: red;\">`)."
  },
  {
    "id": 66,
    "question": "Jakie jest właściwe miejsce w dokumencie HTML na umiejscowienie odwołania do zewnętrznego arkusza styli?",
    "options": [
      {
        "text": "początek sekcji ciała dokumentu (`<body>`)",
        "inline_explanation": "(może powodować efekt FOUC - Flash of Unstyled Content)",
        "correct": false
      },
      {
        "text": "sekcja nagłówkowa dokumentu (`<head>`)",
        "inline_explanation": "(przeglądarka wczytuje style przed wyrenderowaniem treści strony)",
        "correct": true
      },
      {
        "text": "koniec sekcji body (przed `</body>`)",
        "inline_explanation": "(tam zazwyczaj umieszcza się skrypty JS dla wydajności, ale nie CSS)",
        "correct": false
      },
      {
        "text": "dowolne miejsce w dokumencie",
        "inline_explanation": "(choć przeglądarki mogą to obsłużyć, jest to niezgodne ze standardem i dobrą praktyką)",
        "correct": false
      },
      {
        "text": "wewnątrz znacznika `<style>` przy użyciu dyrektywy `@import`",
        "inline_explanation": "(to alternatywna, choć wolniejsza metoda dołączania stylów)",
        "correct": true
      }
    ],
    "explanation": "Zgodnie ze standardami W3C i dobrą praktyką, odwołania do arkuszy styli (znaczniki `<link>`) umieszcza się w sekcji nagłówkowej dokumentu, czyli wewnątrz `<head>`. Umieszczenie ich w `<body>` jest błędem, który może powodować **FOUC** (Flash of Unstyled Content) - użytkownik przez ułamek sekundy widzi \"gołą\" stronę bez stylów, zanim te się załadują."
  },
  {
    "id": 67,
    "question": "Skrypt napisany w języku JavaScript dołączany do struktury dokumentu HTML w postaci zewnętrznego pliku (np. `skrypt.js`):",
    "options": [
      {
        "text": "musi zawierać znaczniki `<script>` i `</script>`",
        "inline_explanation": "(nie, te znaczniki wpisuje się w pliku HTML, a nie w pliku .js)",
        "correct": false
      },
      {
        "text": "nie może zawierać znaczników HTML (powinien zawierać czysty kod JS)",
        "inline_explanation": "(interpreter JS zgłosiłby błąd składni widząc tagi HTML)",
        "correct": true
      },
      {
        "text": "musi zaczynać się od deklaracji `<!DOCTYPE html>`",
        "inline_explanation": "(to nagłówek dokumentu HTML, nie ma zastosowania w plikach skryptowych)",
        "correct": false
      },
      {
        "text": "jest dołączany za pomocą znacznika `<link>`",
        "inline_explanation": "(nie, znacznik `<link>` służy do CSS; do JS używa się `<script src=...>` )",
        "correct": false
      },
      {
        "text": "musi być zakodowany w formacie binarnym",
        "inline_explanation": "(pliki .js są plikami tekstowymi, zazwyczaj w kodowaniu UTF-8)",
        "correct": false
      }
    ],
    "explanation": "Zewnętrzny plik JavaScript (z rozszerzeniem `.js`) powinien zawierać **wyłącznie kod JavaScript**. Nie wpisuje się w nim znaczników HTML takich jak `<script>` czy `</script>`. Znaczniki te znajdują się w pliku HTML, który importuje ten skrypt (instrukcją `<script src=\"plik.js\"></script>`)."
  },
  {
    "id": 68,
    "question": "Format zapisu wykorzystywany w maszynach wirtualnych to:",
    "options": [
      {
        "text": "OVF (Open Virtualization Format)",
        "inline_explanation": "(otwarty standard XML opisujący konfigurację maszyny wirtualnej)",
        "correct": true
      },
      {
        "text": "VMDK (Virtual Machine Disk)",
        "inline_explanation": "(format dysku wirtualnego stworzony przez firmę VMware)",
        "correct": true
      },
      {
        "text": "VHD / VHDX (Virtual Hard Disk)",
        "inline_explanation": "(format dysku wirtualnego używany przez Microsoft Hyper-V)",
        "correct": true
      },
      {
        "text": "JPEG",
        "inline_explanation": "(to format kompresji obrazów)",
        "correct": false
      },
      {
        "text": "OVA (Open Virtualization Appliance)",
        "inline_explanation": "(pojedynczy plik archiwum zawierający deskryptor OVF i pliki dysków)",
        "correct": true
      }
    ],
    "explanation": "W wirtualizacji spotykamy formaty opisu maszyny (metadane) oraz formaty dysków. \n ⚫ **OVF:** Otwarty standard pakowania i dystrybucji (przenośny między różnymi hiperwizorami, np. z VMware do VirtualBox). \n ⚫ **VMDK:** Format dysku VMware. \n ⚫ **VHDX:** Nowoczesny format dysku Microsoftu. \n ⚫ **QCOW2:** Popularny format w świecie Linux/KVM (obsługuje snapshoty i kompresję)."
  },
  {
    "id": 69,
    "question": "Pamięci masowe wykorzystywane w środowisku zwirtualizowanym (jako Datastore):",
    "options": [
      {
        "text": "NFS (Network File System)",
        "inline_explanation": "(popularny protokół plikowy, łatwy w konfiguracji dla VMware/KVM)",
        "correct": true
      },
      {
        "text": "iSCSI (Internet Small Computer Systems Interface)",
        "inline_explanation": "(protokół blokowy działający po sieci Ethernet/IP)",
        "correct": true
      },
      {
        "text": "Fibre Channel (FC)",
        "inline_explanation": "(dedykowana, szybka sieć optyczna do przesyłania danych blokowych w sieciach SAN)",
        "correct": true
      },
      {
        "text": "SMTP",
        "inline_explanation": "(protokół pocztowy Simple Mail Transfer Protocol)",
        "correct": false
      },
      {
        "text": "vSAN / Ceph (Software Defined Storage)",
        "inline_explanation": "(rozwiązania klastrowe, które agregują dyski lokalne wielu serwerów w jedną wspólną przestrzeń)",
        "correct": true
      }
    ],
    "explanation": "Hiperwizory (jak ESXi, Proxmox, Hyper-V) potrzebują miejsca do składowania plików maszyn wirtualnych. Mogą korzystać z: \n ⚫ **DAS:** Dyski lokalne. \n ⚫ **SAN (Storage Area Network):** Blokowy dostęp przez sieć (FC, iSCSI). \n ⚫ **NAS (Network Attached Storage):** Plikowy dostęp przez sieć (głównie NFS, rzadziej SMB). \n ⚫ **SDS:** Programowe macierze rozproszone (Ceph, vSAN)."
  },
  {
    "id": 70,
    "question": "Hiperwizor typu 1 (Bare-metal):",
    "options": [
      {
        "text": "pracuje bezpośrednio na systemie operacyjnym gospodarza",
        "inline_explanation": "(to definicja Typu 2 - Hosted, np. VirtualBox zainstalowany na Windowsie)",
        "correct": false
      },
      {
        "text": "pracuje bezpośrednio na sprzęcie fizycznym komputera",
        "inline_explanation": "(ma bezpośredni dostęp do CPU i RAM bez pośrednictwa innego systemu operacyjnego)",
        "correct": true
      },
      {
        "text": "cechuje się wyższą wydajnością niż hiperwizor typu 2",
        "inline_explanation": "(brak narzutu systemu gospodarza)",
        "correct": true
      },
      {
        "text": "przykładem jest Oracle VirtualBox",
        "inline_explanation": "(to klasyczny przykład hiperwizora typu 2)",
        "correct": false
      },
      {
        "text": "przykładem jest VMware ESXi lub Microsoft Hyper-V Server",
        "inline_explanation": "(systemy te instaluje się na czystym serwerze)",
        "correct": true
      }
    ],
    "explanation": "Podział hiperwizorów: \n  \n ⚫ **Typ 1 (Bare-metal):** Instalowany na \"gołym metalu\". Przykłady: VMware ESXi, Hyper-V, Xen, KVM (KVM jest hybrydą, ale działa jak Typ 1). Używany w serwerowniach i chmurach. \n ⚫ **Typ 2 (Hosted):** Aplikacja uruchamiana na systemie (Windows/Linux/macOS). Przykłady: VMware Workstation, VirtualBox. Używany do testów i nauki na laptopach."
  },
  {
    "id": 71,
    "question": "Jakimi znacznikami ogranicza się skrypty PHP?",
    "options": [
      {
        "text": "`<? php ?>`",
        "inline_explanation": "(błąd składniowy - spacja po znaku zapytania jest niedozwolona)",
        "correct": false
      },
      {
        "text": "`<?php ... ?>`",
        "inline_explanation": "(standardowy, zalecany i zawsze dostępny sposób otwierania bloku PHP)",
        "correct": true
      },
      {
        "text": "`<script language=\"php\"> ... </script>`",
        "inline_explanation": "(forma przestarzała, usunięta całkowicie w PHP 7.0)",
        "correct": false
      },
      {
        "text": "`<php> ... </php>`",
        "inline_explanation": "(niepoprawne; PHP nie używa składni XML-owej w ten sposób)",
        "correct": false
      },
      {
        "text": "`<?= ... ?>`",
        "inline_explanation": "(tzw. short echo tag; równoważnik `<?php echo ... ?>`, dostępny domyślnie w nowszych wersjach)",
        "correct": true
      }
    ],
    "explanation": "Standardowym sposobem otwarcia bloku kodu PHP jest znacznik: `<?php`, a zamknięcia: `?>`. Istnieją też formy skrócone (`<? ... ?>`), ale ich obsługa zależy od konfiguracji serwera (`short_open_tag` w php.ini) i nie jest zalecana w kodzie przenośnym. Wyjątkiem jest `<?= ... ?>`, który służy do szybkiego wypisywania zmiennych."
  },
  {
    "id": 72,
    "question": "Poufność danych cyfrowych (Confidentiality) jest zapewniana przede wszystkim dzięki:",
    "options": [
      {
        "text": "kryptografii (szyfrowaniu danych)",
        "inline_explanation": "(sprawia, że dane są nieczytelne dla osób nieposiadających klucza)",
        "correct": true
      },
      {
        "text": "sumom kontrolnym i funkcjom skrótu",
        "inline_explanation": "(to zapewnia integralność - wykrywanie zmian, a nie ukrywanie treści)",
        "correct": false
      },
      {
        "text": "redundancji sprzętowej (RAID, klastry)",
        "inline_explanation": "(to zapewnia dostępność - Availability)",
        "correct": false
      },
      {
        "text": "wyłącznie jawnym protokołom transmisji",
        "inline_explanation": "(protokoły jawne, jak HTTP czy Telnet, nie zapewniają poufności)",
        "correct": false
      },
      {
        "text": "steganografii",
        "inline_explanation": "(technika ta ukrywa samo istnienie informacji, np. w obrazku, ale nie jest to synonim kryptografii)",
        "correct": false
      }
    ],
    "explanation": "Poufność to gwarancja, że dane są dostępne jedynie dla uprawnionych. W modelu **CIA** (Confidentiality, Integrity, Availability) głównym mechanizmem zapewniającym poufność jest **szyfrowanie** (np. AES, RSA). Inne mechanizmy wspierające to kontrola dostępu (ACL), ale to szyfrowanie jest ostatnią linią obrony."
  },
  {
    "id": 73,
    "question": "Kontrola integralności danych cyfrowych polega na sprawdzeniu czy nie zostały one:",
    "options": [
      {
        "text": "odczytane przez osoby niepowołane",
        "inline_explanation": "(to naruszenie poufności, a nie integralności)",
        "correct": false
      },
      {
        "text": "zmodyfikowane w sposób nieautoryzowany (przypadkowo lub celowo)",
        "inline_explanation": "(kluczowa definicja integralności)",
        "correct": true
      },
      {
        "text": "zaszyfrowane kluczem publicznym",
        "inline_explanation": "(szyfrowanie to normalna operacja kryptograficzna)",
        "correct": false
      },
      {
        "text": "skopiowane na inny nośnik",
        "inline_explanation": "(samo skopiowanie bit w bit zachowuje integralność kopii)",
        "correct": false
      },
      {
        "text": "sfałszowane (np. poprzez weryfikację podpisu cyfrowego)",
        "inline_explanation": "(podpis cyfrowy gwarantuje zarówno integralność, jak i autentyczność)",
        "correct": true
      }
    ],
    "explanation": "Integralność (Integrity) oznacza, że dane są spójne, kompletne i niezmienione. Kontrola integralności (np. przy użyciu sum kontrolnych CRC, funkcji skrótu SHA-256 lub podpisów cyfrowych) weryfikuje, czy dane są dokładnie takie same, jak w momencie ich utworzenia/wysłania."
  },
  {
    "id": 74,
    "question": "Szyfr monoalfabetyczny (np. Szyfr Cezara):",
    "options": [
      {
        "text": "zachowuje statystykę (częstość występowania znaków) języka szyfrowanej wiadomości",
        "inline_explanation": "(np. litera 'E' w tekście jawnym zawsze zamienia się na ten sam znak w szyfrogramie)",
        "correct": true
      },
      {
        "text": "jest odporny na ataki statystyczne",
        "inline_explanation": "(jest bardzo podatny; można go łatwo złamać analizą częstości liter)",
        "correct": false
      },
      {
        "text": "wykorzystuje wiele alfabetów do szyfrowania jednej wiadomości",
        "inline_explanation": "(to definicja szyfru polialfabetycznego, np. Vigenère)",
        "correct": false
      },
      {
        "text": "jest obecnie uznawany za bezpieczny standard w bankowości",
        "inline_explanation": "(współcześnie używa się szyfrów blokowych jak AES, a nie prostych podstawień)",
        "correct": false
      },
      {
        "text": "jest przykładem prostego szyfru podstawieniowego (substytucyjnego)",
        "inline_explanation": "(każdy znak jest zastępowany innym wg stałej reguły)",
        "correct": true
      }
    ],
    "explanation": "Szyfr monoalfabetyczny polega na stałym przyporządkowaniu znaku tekstu jawnego do znaku szyfrogramu. Ponieważ relacja jest 1:1 i stała, histogram znaków w szyfrogramie wygląda tak samo jak w języku naturalnym (tylko przesunięty/pomieszany). Ułatwia to kryptoanalizę (np. najczęstszy znak w szyfrogramie to prawdopodobnie 'A' lub 'I' w języku polskim)."
  },
  {
    "id": 75,
    "question": "Bezpieczne szyfry powinny charakteryzować się:",
    "options": [
      {
        "text": "spełnianiem kryterium lawinowości (Avalanche Effect)",
        "inline_explanation": "(zmiana 1 bitu wejścia powinna zmieniać średnio 50% bitów wyjścia)",
        "correct": true
      },
      {
        "text": "liniowością funkcji szyfrującej",
        "inline_explanation": "(szyfry muszą być silnie nieliniowe, by utrudnić kryptoanalizę algebraiczną i różnicową)",
        "correct": false
      },
      {
        "text": "możliwością łatwego odwrócenia procesu bez znajomości klucza",
        "inline_explanation": "(to przeczyłoby idei szyfrowania; powinno to być obliczeniowo niemożliwe)",
        "correct": false
      },
      {
        "text": "generowaniem zawsze takiego samego szyfrogramu dla różnych kluczy",
        "inline_explanation": "(klucz musi determinować unikalny wynik)",
        "correct": false
      },
      {
        "text": "oparciem bezpieczeństwa o utajnienie algorytmu (Security by Obscurity)",
        "inline_explanation": "(zgodnie z Zasadą Kerckhoffsa, bezpieczeństwo powinno zależeć tylko od tajności klucza, a nie algorytmu)",
        "correct": false
      }
    ],
    "explanation": "Współczesna kryptografia wymaga dwóch cech zdefiniowanych przez Shannona: **dyfuzji** i **konfuzji**. Kryterium lawinowości jest kluczowe dla dyfuzji - mała zmiana na wejściu (tekst jawny lub klucz) powoduje ogromną, nieprzewidywalną zmianę na wyjściu, zamazując wszelkie statystyczne zależności."
  },
  {
    "id": 76,
    "question": "Bezpieczna funkcja skrótu kryptograficznego musi być odporna na:",
    "options": [
      {
        "text": "faktoryzację",
        "inline_explanation": "(to problem matematyczny leżący u podstaw algorytmu asymetrycznego RSA, a nie funkcji skrótu)",
        "correct": false
      },
      {
        "text": "występowanie kolizji",
        "inline_explanation": "(trudność obliczeniowa znalezienia dwóch różnych danych wejściowych dających ten sam hash)",
        "correct": true
      },
      {
        "text": "ataki typu preimage (odwracanie)",
        "inline_explanation": "(niemożność odtworzenia oryginalnej wiadomości na podstawie samego skrótu)",
        "correct": true
      },
      {
        "text": "deszyfrację",
        "inline_explanation": "(funkcje skrótu są z definicji jednokierunkowe i nieodwracalne, więc pojęcie deszyfracji nie ma tu zastosowania)",
        "correct": false
      },
      {
        "text": "atak urodzinowy (Birthday Attack)",
        "inline_explanation": "(funkcja musi mieć odpowiednio długi skrót, np. 256 bitów, by ten atak był niepraktyczny)",
        "correct": true
      }
    ],
    "explanation": "Funkcja skrótu (hash function) przekształca dane o dowolnej długości w ciąg o stałej długości (np. SHA-256). \n  \n Musi być odporna na: \n ⚫ **Kolizje (Collision resistance):** Trudność w znalezieniu dwóch dowolnych wiadomości $m1$ i $m2$, które dają ten sam skrót. \n ⚫ **Odwracanie (Preimage resistance):** Trudność w znalezieniu wiadomości pasującej do danego skrótu."
  },
  {
    "id": 77,
    "question": "Szyfry symetryczne charakteryzują się tym, że:",
    "options": [
      {
        "text": "dane wejściowe algorytmu dzielone są na symetryczne części",
        "inline_explanation": "(nieprecyzyjny opis, który może dotyczyć struktury Feistela, ale nie definiuje całej klasy szyfrów)",
        "correct": false
      },
      {
        "text": "do szyfrowania i deszyfrowania wykorzystywany jest ten sam tajny klucz",
        "inline_explanation": "(kluczowa cecha; nadawca i odbiorca muszą posiadać identyczną kopię klucza)",
        "correct": true
      },
      {
        "text": "używają pary kluczy: publicznego i prywatnego",
        "inline_explanation": "(to definicja szyfrów asymetrycznych)",
        "correct": false
      },
      {
        "text": "są wolniejsze obliczeniowo od szyfrów asymetrycznych",
        "inline_explanation": "(nie, są zazwyczaj 100-1000x szybsze, dlatego szyfruje się nimi duże ilości danych)",
        "correct": false
      },
      {
        "text": "wymagają bezpiecznego kanału do wymiany klucza przed rozpoczęciem komunikacji",
        "inline_explanation": "(problem dystrybucji kluczy jest główną wadą kryptografii symetrycznej)",
        "correct": true
      }
    ],
    "explanation": "Kluczową cechą kryptografii symetrycznej jest to, że **ten sam klucz** służy zarówno do szyfrowania, jak i deszyfrowania wiadomości. \n  \n Strony komunikacji muszą ten klucz wcześniej bezpiecznie uzgodnić. Przykłady: AES, DES, ChaCha20."
  },
  {
    "id": 78,
    "question": "Załóżmy że Ania i Bartek używają kryptografii asymetrycznej (RSA). Jeżeli Ania zaszyfruje tajną wiadomość kluczem publicznym Bartka, to wiadomość taką można odszyfrować za pomocą:",
    "options": [
      {
        "text": "klucza prywatnego Ani",
        "inline_explanation": "(służyłby do podpisywania wiadomości przez Anię, a nie do odczytu wiadomości dla Bartka)",
        "correct": false
      },
      {
        "text": "klucza prywatnego Bartka",
        "inline_explanation": "(tylko Bartek ma swój klucz prywatny, więc tylko on może otworzyć wiadomość zaszyfrowaną jego kluczem publicznym)",
        "correct": true
      },
      {
        "text": "klucza publicznego Ani",
        "inline_explanation": "(służy do weryfikacji podpisu Ani)",
        "correct": false
      },
      {
        "text": "klucza publicznego Bartka",
        "inline_explanation": "(służy do szyfrowania, a nie deszyfrowania)",
        "correct": false
      },
      {
        "text": "wspólnego klucza sesyjnego",
        "inline_explanation": "(w czystym modelu asymetrycznym nie ma klucza sesyjnego, choć w hybrydowym bywa używany)",
        "correct": false
      }
    ],
    "explanation": "W kryptografii asymetrycznej (klucz publiczny/prywatny): \n ⚫ **Poufność:** Nadawca szyfruje **Kluczem Publicznym Odbiorcy**. Tylko Odbiorca posiada pasujący **Klucz Prywatny**, którym może to odczytać. \n ⚫ **Podpis cyfrowy:** Nadawca szyfruje (podpisuje) swoim **Kluczem Prywatnym**, a każdy może zweryfikować Kluczem Publicznym Nadawcy."
  },
  {
    "id": 79,
    "question": "Co łączy szyfry AES i RSA?",
    "options": [
      {
        "text": "klucze publiczne dla obu algorytmów są jawne",
        "inline_explanation": "(fałsz, AES jest szyfrem symetrycznym i w ogóle nie posiada kluczy publicznych)",
        "correct": false
      },
      {
        "text": "są to algorytmy powszechnie stosowane w nowoczesnych systemach kryptograficznych (często w układzie hybrydowym)",
        "inline_explanation": "(np. w TLS: RSA/ECC służy do uzgodnienia klucza, a AES do szyfrowania właściwych danych)",
        "correct": true
      },
      {
        "text": "oba są szyframi symetrycznymi",
        "inline_explanation": "(RSA jest asymetryczny)",
        "correct": false
      },
      {
        "text": "oba opierają swoje bezpieczeństwo na problemie faktoryzacji liczb pierwszych",
        "inline_explanation": "(tylko RSA; AES opiera się na złożoności operacji substytucji i permutacji)",
        "correct": false
      },
      {
        "text": "oba są uznane przez NIST za standardy",
        "inline_explanation": "(RSA jest standardem de facto, AES jest standardem rządowym USA)",
        "correct": true
      }
    ],
    "explanation": "AES (symetryczny, szybki) i RSA (asymetryczny, wolny) różnią się mechanizmem działania, ale uzupełniają się w **systemach hybrydowych** (np. HTTPS). Asymetryczny RSA służy do bezpiecznej wymiany klucza symetrycznego, który potem jest używany przez AES do szybkiego szyfrowania transmisji."
  },
  {
    "id": 80,
    "question": "W praktyce podpis elektroniczny bazuje na:",
    "options": [
      {
        "text": "szyfrowaniu asymetrycznym i funkcjach skrótu",
        "inline_explanation": "(skrót dokumentu jest szyfrowany kluczem prywatnym nadawcy)",
        "correct": true
      },
      {
        "text": "wyłącznie szyfrowaniu symetrycznym",
        "inline_explanation": "(brak cechy niezaprzeczalności - obie strony mają ten sam klucz, więc każda mogła wygenerować podpis)",
        "correct": false
      },
      {
        "text": "tylko funkcjach skrótu",
        "inline_explanation": "(zapewnia integralność, ale nie wskazuje autora)",
        "correct": false
      },
      {
        "text": "steganografii",
        "inline_explanation": "(ukrywanie danych nie jest metodą uwierzytelniania)",
        "correct": false
      },
      {
        "text": "infrastrukturze klucza publicznego (PKI)",
        "inline_explanation": "(PKI dostarcza certyfikaty wiążące tożsamość z kluczem publicznym)",
        "correct": true
      }
    ],
    "explanation": "Podpis elektroniczny wykorzystuje dwa mechanizmy: \n  \n 1. **Funkcje skrótu (Hash):** Aby zapewnić integralność i wydajność (podpisuje się krótki \"odcisk\" dokumentu, a nie cały wielki plik). \n 2. **Kryptografię asymetryczną:** Aby zapewnić autentyczność i niezaprzeczalność. Skrót jest szyfrowany **kluczem prywatnym** nadawcy."
  },
  {
    "id": 81,
    "question": "Certyfikat klucza publicznego w standardzie X.509 zawiera:",
    "options": [
      {
        "text": "identyfikator (Distinguished Name) centrum certyfikacyjnego, które wystawiło certyfikat",
        "inline_explanation": "(pole Issuer DN)",
        "correct": true
      },
      {
        "text": "klucz publiczny podmiotu certyfikatu",
        "inline_explanation": "(to najważniejsza część certyfikatu - wiąże klucz z tożsamością)",
        "correct": true
      },
      {
        "text": "klucz prywatny podmiotu",
        "inline_explanation": "(nigdy! klucz prywatny musi pozostać tajny i nie opuszcza urządzenia właściciela)",
        "correct": false
      },
      {
        "text": "historię odwiedzanych stron internetowych",
        "inline_explanation": "(absurdalna odpowiedź; certyfikat służy do identyfikacji, a nie śledzenia)",
        "correct": false
      },
      {
        "text": "podpis cyfrowy wystawcy (CA)",
        "inline_explanation": "(gwarantuje, że nikt nie sfałszował zawartości certyfikatu)",
        "correct": true
      }
    ],
    "explanation": "Standard X.509 definiuje format certyfikatów w infrastrukturze PKI. \n  \n Certyfikat to cyfrowy dowód tożsamości. Zawiera: \n ⚫ **Subject:** Kto to jest? \n ⚫ **Public Key:** Jaki jest jego klucz publiczny? \n ⚫ **Issuer:** Kto to potwierdza (urząd CA)? \n ⚫ **Signature:** Podpis CA pod powyższymi danymi. \n Certyfikat **nigdy** nie zawiera klucza prywatnego."
  },
  {
    "id": 82,
    "question": "Bezpieczeństwo kryptografii kwantowej (np. protokołu QKD BB84) bazuje na:",
    "options": [
      {
        "text": "zjawisku, w którym pomiar zaburza stan kwantowy",
        "inline_explanation": "(próba podsłuchu przez Ewę wprowadza błędy w transmisji, które Alicja i Bob mogą wykryć)",
        "correct": true
      },
      {
        "text": "twierdzeniu o zakazie klonowania (No-cloning theorem)",
        "inline_explanation": "(nie da się stworzyć idealnej kopii nieznanego stanu kwantowego)",
        "correct": true
      },
      {
        "text": "wykorzystaniu splątania kwantowego do przesyłania danych szybciej niż światło",
        "inline_explanation": "(mit; splątanie nie pozwala na przesył informacji z prędkością nadświetlną)",
        "correct": false
      },
      {
        "text": "trudności rozkładu dużych liczb na czynniki pierwsze",
        "inline_explanation": "(to podstawa kryptografii klasycznej asymetrycznej, np. RSA, a nie kwantowej)",
        "correct": false
      },
      {
        "text": "szyfrowaniu samej wiadomości (payloadu) za pomocą stanów kwantowych",
        "inline_explanation": "(obecnie technologia QKD służy do uzgodnienia klucza, a sama wiadomość jest szyfrowana klasycznie, np. AES-em)",
        "correct": false
      }
    ],
    "explanation": "Kryptografia kwantowa opiera się na prawach fizyki, a nie matematyki. \n  \n Jeśli podsłuchiwacz (Ewa) spróbuje zmierzyć przesyłane fotony, zgodnie z **Zasadą Nieoznaczoności Heisenberga**, nieuchronnie zmieni ich stan. Legalni użytkownicy (Alicja i Bob) porównują próbkę danych i jeśli wykryją błędy (ber > 0), wiedzą, że kanał jest podsłuchiwany."
  },
  {
    "id": 83,
    "question": "Uwierzytelnianie typu wyzwanie-odpowiedź (Challenge-Response):",
    "options": [
      {
        "text": "wymaga komunikacji wyłącznie poprzez protokół UDP",
        "inline_explanation": "(mechanizm ten jest niezależny od warstwy transportowej; działa też na TCP, HTTP itd.)",
        "correct": false
      },
      {
        "text": "zapobiega przesyłaniu hasła jawnym tekstem przez sieć",
        "inline_explanation": "(przesyłany jest tylko wynik operacji kryptograficznej, a nie samo hasło)",
        "correct": true
      },
      {
        "text": "chroni przed atakami typu powtórzenie (Replay Attack)",
        "inline_explanation": "(dzięki unikalności losowego wyzwania - nonce - stara odpowiedź nie zadziała ponownie)",
        "correct": true
      },
      {
        "text": "wymaga, aby użytkownik posiadał fizyczny token sprzętowy",
        "inline_explanation": "(niekoniecznie, challenge-response jest też podstawą np. protokołów CRAM-MD5 czy NTLM opartych na hasłach)",
        "correct": false
      },
      {
        "text": "wymaga ustanowienia szyfrowanego tunelu (np. VPN) do działania",
        "inline_explanation": "(nie, ten mechanizm został zaprojektowany właśnie po to, by bezpiecznie logować się przez niezaufany, jawny kanał)",
        "correct": false
      }
    ],
    "explanation": "Mechanizm: \n 1. Serwer wysyła losowe wyzwanie (`Nonce`). \n 2. Klient łączy wyzwanie ze swoim hasłem i oblicza skrót/podpis (`Response = Hash(Password + Nonce)`). \n 3. Serwer robi to samo i porównuje wyniki. \n Dzięki temu hasło nigdy nie lata w sieci, a podsłuchanie `Response` nic nie daje atakującemu przy kolejnej próbie logowania (bo `Nonce` będzie inny)."
  },
  {
    "id": 84,
    "question": "Atak typu DDoS (Distributed Denial of Service):",
    "options": [
      {
        "text": "wymaga wcześniejszego złamania haseł administratora atakowanego systemu",
        "inline_explanation": "(nie, atakuje się dostępność z zewnątrz, nie trzeba wchodzić do środka)",
        "correct": false
      },
      {
        "text": "polega na wyczerpaniu zasobów systemu (pasma, CPU, tablicy stanów) poprzez generowanie sztucznego ruchu",
        "inline_explanation": "(cel to uniemożliwienie działania usługi dla legalnych użytkowników)",
        "correct": true
      },
      {
        "text": "jest realizowany najczęściej przy użyciu botnetu",
        "inline_explanation": "(sieci tysięcy zainfekowanych urządzeń zombie)",
        "correct": true
      },
      {
        "text": "skutkuje kradzieżą bazy danych użytkowników",
        "inline_explanation": "(to skutek ataku typu 'Data Breach', a nie DoS)",
        "correct": false
      },
      {
        "text": "może wykorzystywać mechanizm amplifikacji (np. DNS Amplification)",
        "inline_explanation": "(atakujący wysyła małe zapytanie ze sfałszowanym adresem źródłowym, a serwer odpowiada dużą porcją danych do ofiary)",
        "correct": true
      }
    ],
    "explanation": "Atak DDoS ma na celu zablokowanie dostępności usługi (Availability). Nie jest to włamanie w sensie kradzieży danych, ale \"zadeptanie\" serwera. Wykorzystuje się do tego **botnety** (przejęte komputery, kamery, routery IoT), które jednocześnie wysyłają żądania do ofiary."
  },
  {
    "id": 85,
    "question": "Który z podanych algorytmów **NIE** służy do testowania czy liczba jest pierwsza?",
    "options": [
      {
        "text": "Test Millera-Rabina",
        "inline_explanation": "(to najpopularniejszy probabilistyczny test pierwszości)",
        "correct": false
      },
      {
        "text": "Algorytm Euklidesa",
        "inline_explanation": "(służy do znajdowania Największego Wspólnego Dzielnika - NWD/GCD dwóch liczb)",
        "correct": true
      },
      {
        "text": "Test AKS (Agrawal-Kayal-Saxena)",
        "inline_explanation": "(pierwszy deterministyczny test pierwszości działający w czasie wielomianowym)",
        "correct": false
      },
      {
        "text": "Test Fermata",
        "inline_explanation": "(prosty probabilistyczny test pierwszości oparty na Małym Twierdzeniu Fermata)",
        "correct": false
      },
      {
        "text": "Test Solovaya-Strassena",
        "inline_explanation": "(historycznie ważny probabilistyczny test pierwszości)",
        "correct": false
      }
    ],
    "explanation": "Należy rozróżnić problemy matematyczne: \n ⚫ **Testowanie pierwszości:** Sprawdzamy, czy $N$ jest liczbą pierwszą (Millera-Rabina, Fermata, AKS). \n ⚫ **NWD:** Szukamy wspólnego dzielnika (Euklides). \n ⚫ **Faktoryzacja:** Szukamy dzielników liczby złożonej (Sito ciał liczbowych - GNFS)."
  },
  {
    "id": 86,
    "question": "Co to jest szyfr afiniczny?",
    "options": [
      {
        "text": "Dowolny szyfr wieloalfabetyczny",
        "inline_explanation": "(fałsz, jest to szyfr monoalfabetyczny, podobnie jak szyfr Cezara)",
        "correct": false
      },
      {
        "text": "Rodzaj szyfru podstawieniowego opartego na funkcji liniowej $f(x) = (ax + b) \\mod m$",
        "inline_explanation": "(gdzie $x$ to numer litery, a $a$ i $b$ to klucze)",
        "correct": true
      },
      {
        "text": "Szyfr blokowy używany w standardzie AES",
        "inline_explanation": "(AES to Rijndael, o wiele bardziej skomplikowana struktura)",
        "correct": false
      },
      {
        "text": "Algorytm asymetryczny oparty na krzywych eliptycznych",
        "inline_explanation": "(to ECC, zupełnie inna dziedzina matematyki)",
        "correct": false
      },
      {
        "text": "Szyfr, w którym klucz mnożący $a$ musi być względnie pierwszy z rozmiarem alfabetu $m$",
        "inline_explanation": "(warunek konieczny, aby funkcja szyfrująca była odwracalna, czyli żeby dało się odszyfrować wiadomość)",
        "correct": true
      }
    ],
    "explanation": "Szyfr afiniczny to klasyczny szyfr podstawieniowy. \n Każda litera o numerze $x$ jest zamieniana na literę o numerze: $$ E(x) = (ax + b) \\pmod m $$ \n Jest to uogólnienie szyfru Cezara (gdzie $a=1$). Aby deszyfracja była możliwa, liczba $a$ musi mieć odwrotność modulo $m$, czyli $NWD(a, m) = 1$."
  },
  {
    "id": 87,
    "question": "Odwrotność liczby $x$ modulo $N$ ($x^{-1} \\pmod N$):",
    "options": [
      {
        "text": "Można wyliczyć z użyciem Rozszerzonego Algorytmu Euklidesa",
        "inline_explanation": "(jest to standardowa metoda obliczania elementu odwrotnego w ciele skończonym)",
        "correct": true
      },
      {
        "text": "Istnieje dla każdej liczby całkowitej $x$",
        "inline_explanation": "(fałsz, istnieje tylko wtedy, gdy $x$ i $N$ są względnie pierwsze)",
        "correct": false
      },
      {
        "text": "Jest zawsze równa $1/x$",
        "inline_explanation": "(w arytmetyce modularnej operujemy na liczbach całkowitych, nie ma tu ułamków dziesiętnych)",
        "correct": false
      },
      {
        "text": "Można obliczyć za pomocą sita Eratostenesa",
        "inline_explanation": "(sito służy do znajdowania liczb pierwszych, a nie odwrotności)",
        "correct": false
      },
      {
        "text": "Jest to taka liczba $y$, że $x \\cdot y \\equiv 1 \\pmod N$",
        "inline_explanation": "(to jest matematyczna definicja odwrotności modulo)",
        "correct": true
      }
    ],
    "explanation": "Odwrotność modulo to kluczowe pojęcie w kryptografii asymetrycznej (RSA). \n  \n W arytmetyce \"zegarowej\" (modulo $N$), odwrotnością liczby $x$ jest taka liczba $y$, która po pomnożeniu przez $x$ daje resztę 1 z dzielenia przez $N$. Oblicza się ją Rozszerzonym Algorytmem Euklidesa."
  },
  {
    "id": 88,
    "question": "Aby utrudnić inżynierię wsteczną (Reverse Engineering) oprogramowania stosuje się:",
    "options": [
      {
        "text": "obfuskację (zaciemnianie kodu)",
        "inline_explanation": "(np. zamiana nazw zmiennych na losowe ciągi znaków, dodawanie martwego kodu)",
        "correct": true
      },
      {
        "text": "pakowanie kodu wykonywalnego (packers)",
        "inline_explanation": "(kompresja i szyfrowanie pliku .exe, który rozpakowuje się dopiero w pamięci RAM)",
        "correct": true
      },
      {
        "text": "kompilację z flagami debugowania (Debug Symbols)",
        "inline_explanation": "(to drastycznie ułatwia inżynierię wsteczną, udostępniając nazwy funkcji i zmiennych)",
        "correct": false
      },
      {
        "text": "dokumentowanie kodu zgodnie ze standardami",
        "inline_explanation": "(to dobra praktyka inżynierska, ale nie ma wpływu na skompilowany plik binarny)",
        "correct": false
      },
      {
        "text": "publikację kodu źródłowego na GitHubie",
        "inline_explanation": "(to zaprzeczenie utrudniania analizy - daje atakującemu pełną wiedzę)",
        "correct": false
      }
    ],
    "explanation": "Inżynieria wsteczna polega na analizie skompilowanego programu, by zrozumieć jak działa. Aby to utrudnić, programiści (i twórcy malware'u) stosują **obfuskację**. Zaciemniony kod działa tak samo, ale jest nieczytelny dla człowieka i trudny do analizy dla deasemblerów."
  },
  {
    "id": 89,
    "question": "Wirtualne sieci prywatne (VPN) można tworzyć przy wykorzystaniu protokołu:",
    "options": [
      {
        "text": "TLS (Transport Layer Security)",
        "inline_explanation": "(np. OpenVPN, SSL VPN - działa w warstwie aplikacji/sesji)",
        "correct": true
      },
      {
        "text": "IPsec (Internet Protocol Security)",
        "inline_explanation": "(standard działający w warstwie sieciowej - Layer 3)",
        "correct": true
      },
      {
        "text": "L2TP (Layer 2 Tunneling Protocol)",
        "inline_explanation": "(często używany w parze z IPsec jako L2TP/IPsec)",
        "correct": true
      },
      {
        "text": "SMTP",
        "inline_explanation": "(protokół pocztowy)",
        "correct": false
      },
      {
        "text": "WireGuard",
        "inline_explanation": "(nowoczesny, szybki i prosty protokół VPN wbudowany w jądro Linuxa)",
        "correct": true
      }
    ],
    "explanation": "VPN tworzy szyfrowany tunel przez publiczną sieć (Internet). Najpopularniejsze technologie to: \n 1. **IPsec:** Standard przemysłowy, trudniejszy w konfiguracji, często używany do łączenia oddziałów firm (Site-to-Site). \n 2. **SSL/TLS (OpenVPN):** Bardziej elastyczny, łatwo przechodzi przez firewalle i NAT, popularny w dostępie zdalnym (Client-to-Site). \n 3. **WireGuard:** Nowy standard, bardzo wydajny."
  },
  {
    "id": 90,
    "question": "W trybie tunelowym (Tunnel Mode) protokołu IPsec:",
    "options": [
      {
        "text": "szyfrowane jest tylko pole danych (payload) pakietu IP",
        "inline_explanation": "(to definicja trybu Transportowego, używanego w komunikacji Host-to-Host)",
        "correct": false
      },
      {
        "text": "szyfrowany jest cały oryginalny pakiet IP i umieszczany w nowym nagłówku",
        "inline_explanation": "(tzw. enkapsulacja; oryginalny adres IP jest ukryty)",
        "correct": true
      },
      {
        "text": "nie stosuje się szyfrowania, jedynie uwierzytelnianie",
        "inline_explanation": "(zależy to od użycia protokołu AH vs ESP, a nie samego trybu)",
        "correct": false
      },
      {
        "text": "nagłówki IP są zawsze przesyłane jawnym tekstem",
        "inline_explanation": "(zewnętrzny nagłówek tak, ale wewnętrzny - oryginalny - jest zaszyfrowany)",
        "correct": false
      },
      {
        "text": "jest to tryb domyślny dla połączeń typu Site-to-Site (Brama-Brama)",
        "inline_explanation": "(pozwala połączyć dwie sieci LAN przez Internet)",
        "correct": true
      }
    ],
    "explanation": "IPsec ma dwa tryby: \n  \n ⚫ **Tryb transportowy:** Chroni tylko dane (payload). Nagłówek IP jest oryginalny. \n ⚫ **Tryb tunelowy:** Szyfruje cały pakiet (wraz z nagłówkiem). Całość jest pakowana w nowy pakiet (\"kopertę\") z adresami bram VPN."
  },
  {
    "id": 91,
    "question": "Systemy wykrywania włamań (IDS) oparte na sygnaturach (Signature-based):",
    "options": [
      {
        "text": "działają z reguły szybciej niż systemy bazujące na wykrywaniu anomalii",
        "inline_explanation": "(porównanie wzorca jest operacją prostszą obliczeniowo niż analiza statystyczna)",
        "correct": true
      },
      {
        "text": "są nieskuteczne w przypadku ataków typu Zero-Day",
        "inline_explanation": "(jeśli nie ma sygnatury w bazie, atak przejdzie niezauważony)",
        "correct": true
      },
      {
        "text": "generują więcej fałszywych alarmów (False Positives) niż systemy anomalii",
        "inline_explanation": "(fałsz, zazwyczaj generują ich mniej, bo reagują na konkretny, znany wzorzec)",
        "correct": false
      },
      {
        "text": "uczą się zachowania sieci w czasie rzeczywistym",
        "inline_explanation": "(to domena systemów behawioralnych/anomalii)",
        "correct": false
      },
      {
        "text": "wymagają regularnych aktualizacji bazy wzorców",
        "inline_explanation": "(podobnie jak programy antywirusowe, muszą znać najnowsze definicje zagrożeń)",
        "correct": true
      }
    ],
    "explanation": "IDS-y dzielimy na: \n 1. **Oparte na sygnaturach:** Porównują pakiety z bazą znanych wzorców (jak antywirus). Szybkie, precyzyjne, ale ślepe na nowe ataki. \n 2. **Oparte na anomaliach:** Uczą się \"normalnego\" ruchu. Wykrywają nowości (Zero-Day), ale często generują fałszywe alarmy."
  },
  {
    "id": 92,
    "question": "Serwer AAA (np. RADIUS, TACACS+) realizuje usługi:",
    "options": [
      {
        "text": "Autoryzacja (Authorization)",
        "inline_explanation": "(określenie uprawnień: co użytkownik może zrobić?)",
        "correct": true
      },
      {
        "text": "Uwierzytelnianie (Authentication)",
        "inline_explanation": "(weryfikacja tożsamości: kim użytkownik jest?)",
        "correct": true
      },
      {
        "text": "Rozliczalność (Accounting)",
        "inline_explanation": "(rejestrowanie aktywności: co i jak długo robił?)",
        "correct": true
      },
      {
        "text": "Adresacja IP (Addressing)",
        "inline_explanation": "(przydziałem adresów zajmuje się DHCP, a nie framework AAA)",
        "correct": false
      },
      {
        "text": "Akceleracja sprzętowa",
        "inline_explanation": "(AAA to model bezpieczeństwa logicznego, nie ma związku z wydajnością sprzętu)",
        "correct": false
      }
    ],
    "explanation": "Akronim AAA w bezpieczeństwie sieciowym oznacza: \n ⚫ **Authentication:** Weryfikacja tożsamości (np. login/hasło). \n ⚫ **Authorization:** Przyznanie uprawnień (np. dostęp do VLAN-u HR). \n ⚫ **Accounting:** Logowanie użycia zasobów (np. czas sesji, ilość danych)."
  },
  {
    "id": 93,
    "question": "Hierarchiczny model zaufania do certyfikatów cyfrowych:",
    "options": [
      {
        "text": "jest fundamentem infrastruktury klucza publicznego (PKI)",
        "inline_explanation": "(opiera się na zaufaniu do głównego urzędu - Root CA)",
        "correct": true
      },
      {
        "text": "opiera się na modelu \"Web of Trust\" znanym z PGP",
        "inline_explanation": "(fałsz, WoT to model zdecentralizowany, gdzie użytkownicy ręczą za siebie nawzajem)",
        "correct": false
      },
      {
        "text": "nie wymaga istnienia zaufanej trzeciej strony (TTP)",
        "inline_explanation": "(wymaga; Urząd Certyfikacji - CA - pełni właśnie rolę TTP)",
        "correct": false
      },
      {
        "text": "pozwala każdemu użytkownikowi wystawiać powszechnie uznawane certyfikaty",
        "inline_explanation": "(nie, tylko autoryzowane centra CA mogą wystawiać zaufane certyfikaty)",
        "correct": false
      },
      {
        "text": "wykorzystuje technologię Blockchain do walidacji",
        "inline_explanation": "(klasyczne PKI X.509 nie korzysta z blockchaina, choć trwają nad tym prace badawcze)",
        "correct": false
      }
    ],
    "explanation": "Modele zaufania: \n ⚫ **Hierarchiczny (PKI):** Drzewiasta struktura. Ufamy Root CA (np. DigiCert), więc ufamy wszystkim certyfikatom, które on podpisał. \n ⚫ **Sieć zaufania (Web of Trust):** Model pajęczyny (PGP). Nie ma szefa; ufam Jankowi, a Janek ufa Zosi, więc ja też mogę zaufać Zosi."
  },
  {
    "id": 94,
    "question": "Algorytm Diffiego-Hellmana (DH) umożliwia:",
    "options": [
      {
        "text": "bezpieczne przesyłanie kluczy prywatnych",
        "inline_explanation": "(klucze prywatne nigdy nie powinny być przesyłane!)",
        "correct": false
      },
      {
        "text": "uzgodnienie wspólnego klucza sesji w niezabezpieczonym kanale",
        "inline_explanation": "(obie strony matematycznie generują ten sam klucz, nie przesyłając go fizycznie)",
        "correct": true
      },
      {
        "text": "uwierzytelnienie tożsamości stron",
        "inline_explanation": "(czysty DH nie zapewnia uwierzytelniania i jest podatny na atak Man-in-the-Middle; wymaga dodatkowych podpisów)",
        "correct": false
      },
      {
        "text": "szyfrowanie asymetryczne wiadomości email",
        "inline_explanation": "(do tego służy RSA lub ElGamal; DH służy do wymiany kluczy)",
        "correct": false
      },
      {
        "text": "sprawdzenie integralności plików",
        "inline_explanation": "(to zadanie funkcji skrótu)",
        "correct": false
      }
    ],
    "explanation": "Protokół Diffiego-Hellmana to rewolucyjny algorytm pozwalający dwóm stronom, które nigdy się nie spotkały, uzgodnić wspólny tajny klucz, mimo że cała ich komunikacja jest podsłuchiwana. \n  \n **Wada:** Bez dodatkowego uwierzytelnienia (np. certyfikatami), DH jest podatny na atak \"Człowiek pośrodku\" (MITM)."
  },
  {
    "id": 95,
    "question": "Wyrażana w bitach entropia Shannona dla źródła wiadomości:",
    "options": [
      {
        "text": "może wynosić -0,76 bita (jest ujemna)",
        "inline_explanation": "(fałsz, entropia jako miara informacji/niepewności jest zawsze nieujemna)",
        "correct": false
      },
      {
        "text": "jest zawsze wartością nieujemną (większą lub równą 0)",
        "inline_explanation": "(zero oznacza całkowitą pewność - brak informacji)",
        "correct": true
      },
      {
        "text": "osiąga maksimum, gdy wszystkie komunikaty są jednakowo prawdopodobne",
        "inline_explanation": "(rozkład jednostajny maksymalizuje niepewność)",
        "correct": true
      },
      {
        "text": "wynosi 1 bit dla rzutu uczciwą monetą",
        "inline_explanation": "($- (0.5 \\log_2 0.5 + 0.5 \\log_2 0.5) = 1$)",
        "correct": true
      },
      {
        "text": "określa dolną granicę kompresji bezstratnej",
        "inline_explanation": "(zgodnie z twierdzeniem o kodowaniu źródła, nie da się skompresować danych poniżej ich entropii)",
        "correct": true
      }
    ],
    "explanation": "Entropia Shannona $H(X)$ to miara nieokreśloności (ilości informacji). Ponieważ prawdopodobieństwa są ułamkami z przedziału $(0, 1]$, ich logarytmy są ujemne. Minus we wzorze $H(X) = - \\sum p(x) \\log_2 p(x)$ sprawia, że ostateczny wynik jest zawsze **nieujemny** ($H \\ge 0$). Ujemna informacja nie ma sensu fizycznego."
  },
  {
    "id": 96,
    "question": "Proszę wskazać zdanie **FAŁSZYWE** w odniesieniu do ciał skończonych (Galois Fields):",
    "options": [
      {
        "text": "Ciało na pewno zawiera element odwrotny dla elementu neutralnego dodawania (zera)",
        "inline_explanation": "(fałsz, zero jest jedynym elementem, który nie posiada odwrotności multiplikatywnej - nie można dzielić przez zero)",
        "correct": true
      },
      {
        "text": "Liczba elementów ciała skończonego jest zawsze potęgą liczby pierwszej ($p^n$)",
        "inline_explanation": "(prawda, np. $GF(2^8)$ ma 256 elementów)",
        "correct": false
      },
      {
        "text": "W ciele muszą być wykonalne działania dodawania, odejmowania, mnożenia i dzielenia (przez nie-zero)",
        "inline_explanation": "(prawda, to definicja ciała w algebrze)",
        "correct": false
      },
      {
        "text": "Ciała Galois są szeroko stosowane w kryptografii (np. w AES i Krzywych Eliptycznych)",
        "inline_explanation": "(prawda, pozwalają na wykonywanie obliczeń bez błędów zaokrągleń)",
        "correct": false
      },
      {
        "text": "Istnieją dwa elementy neutralne: 0 dla dodawania i 1 dla mnożenia",
        "inline_explanation": "(prawda, są to podstawowe elementy struktury)",
        "correct": false
      }
    ],
    "explanation": "Ciało (Field) w matematyce to zbiór, w którym można swobodnie dodawać, odejmować, mnożyć i dzielić. \n  \n Kluczowy wyjątek: **nie można dzielić przez zero**. Zatem zdanie, że zero (\"element neutralny dodawania\") ma odwrotność, jest fałszem matematycznym."
  },
  {
    "id": 97,
    "question": "Gdyby komputery kwantowe o dużej mocy stały się faktem, algorytm Shora wymusiłby rezygnację z:",
    "options": [
      {
        "text": "funkcji skrótu SHA-3",
        "inline_explanation": "(nie, SHA-3 jest odporne na algorytm Shora, choć algorytm Grovera wymusiłby użycie dłuższych skrótów)",
        "correct": false
      },
      {
        "text": "obecnie stosowanych algorytmów asymetrycznych takich jak RSA i ECC",
        "inline_explanation": "(algorytm Shora potrafi w czasie wielomianowym faktoryzować liczby i liczyć logarytmy dyskretne, łamiąc te systemy)",
        "correct": true
      },
      {
        "text": "protokołu wymiany kluczy Diffiego-Hellmana",
        "inline_explanation": "(również opiera się na problemie logarytmu dyskretnego, więc zostałby złamany)",
        "correct": true
      },
      {
        "text": "szyfrów symetrycznych z kluczami jednorazowymi (One-Time Pad)",
        "inline_explanation": "(OTP jest niemożliwy do złamania nawet teoretycznie, niezależnie od mocy obliczeniowej)",
        "correct": false
      },
      {
        "text": "wdrożenia algorytmów Kryptografii Postkwantowej (PQC)",
        "inline_explanation": "(wręcz przeciwnie, wymusiłby ich natychmiastowe wdrożenie)",
        "correct": false
      }
    ],
    "explanation": "Algorytm Shora to \"zabójca\" współczesnej kryptografii klucza publicznego. \n Potrafi on szybko rozwiązywać problemy, na których opiera się **RSA** (faktoryzacja) oraz **ECC/Diffie-Hellman** (logarytm dyskretny). Szyfry symetryczne (AES) są bezpieczniejsze - algorytm Grovera osłabia je tylko o połowę (AES-256 staje się jak AES-128)."
  },
  {
    "id": 98,
    "question": "Paradoks dnia urodzin (Birthday Paradox) to zjawisko matematyczne, które wykorzystuje się do ataku na:",
    "options": [
      {
        "text": "szyfry blokowe w trybie CBC",
        "inline_explanation": "(rzadziej, choć np. atak Sweet32 wykorzystuje kolizje bloków 64-bitowych)",
        "correct": false
      },
      {
        "text": "funkcje skrótu (poszukiwanie kolizji)",
        "inline_explanation": "(najczęstsze zastosowanie; pozwala znaleźć kolizję w czasie $O(2^{n/2})$ zamiast $O(2^n)$)",
        "correct": true
      },
      {
        "text": "podpisy cyfrowe",
        "inline_explanation": "(jeśli znajdę dwa dokumenty o tym samym skrócie, mogę podłożyć jeden za drugi pod podpisem)",
        "correct": true
      },
      {
        "text": "generatory liczb pseudolosowych",
        "inline_explanation": "(analiza powtarzalności sekwencji)",
        "correct": false
      },
      {
        "text": "szyfry strumieniowe typu RC4",
        "inline_explanation": "(RC4 ma inne słabości, np. biasy w początkowych bajtach)",
        "correct": false
      }
    ],
    "explanation": "Paradoks dnia urodzin mówi, że w grupie zaledwie 23 osób szansa, że dwie mają urodziny tego samego dnia, wynosi >50%. \n  \n W kryptografii oznacza to, że znalezienie **kolizji** (dwóch różnych wiadomości o tym samym hashu) jest znacznie łatwiejsze niż znalezienie konkretnej wiadomości pasującej do konkretnego hasha (preimage)."
  },
  {
    "id": 99,
    "question": "Który z podanych niżej szyfrów **NIE** jest szyfrem strumieniowym?",
    "options": [
      {
        "text": "ChaCha20",
        "inline_explanation": "(nowoczesny szyfr strumieniowy, następca Salsa20)",
        "correct": false
      },
      {
        "text": "RC4",
        "inline_explanation": "(klasyczny, choć już niebezpieczny szyfr strumieniowy, znany z WEP)",
        "correct": false
      },
      {
        "text": "AES (Rijndael)",
        "inline_explanation": "(standardowy szyfr blokowy, operujący na macierzach 4x4 bajty)",
        "correct": true
      },
      {
        "text": "A5/1",
        "inline_explanation": "(szyfr strumieniowy używany w sieciach GSM do szyfrowania rozmów)",
        "correct": false
      },
      {
        "text": "Salsa20",
        "inline_explanation": "(szyfr strumieniowy zaprojektowany przez Daniela Bernsteina)",
        "correct": false
      }
    ],
    "explanation": "Podział szyfrów: \n  \n ⚫ **Szyfry strumieniowe:** Szyfrują bit po bicie (lub bajt po bajcie) przy użyciu generatora pseudolosowego (XOR z tekstem jawnym). Przykłady: RC4, ChaCha20. \n ⚫ **Szyfry blokowe:** Szyfrują ustalone porcje danych (bloki, np. 128 bitów) naraz. Przykłady: AES, DES, Twofish."
  },
  {
    "id": 100,
    "question": "Funkcja skrótu SHA-3 jest oparta na konstrukcji:",
    "options": [
      {
        "text": "ElGamal",
        "inline_explanation": "(to asymetryczny schemat szyfrowania)",
        "correct": false
      },
      {
        "text": "Gąbki (Sponge construction)",
        "inline_explanation": "(innowacyjna struktura algorytmu Keccak, pozwalająca na wchłanianie danych i wyciskanie skrótu)",
        "correct": true
      },
      {
        "text": "Merkle-Damgård",
        "inline_explanation": "(na tej klasycznej strukturze oparte są MD5, SHA-1 i SHA-2)",
        "correct": false
      },
      {
        "text": "Krzywych eliptycznych",
        "inline_explanation": "(stosowane w ECC, a nie w hashowaniu)",
        "correct": false
      },
      {
        "text": "Sieci Feistela",
        "inline_explanation": "(struktura używana w szyfrach blokowych jak DES, Blowfish)",
        "correct": false
      }
    ],
    "explanation": "SHA-3 (algorytm Keccak) zerwał z tradycją Merkle-Damgård (podatną na ataki typu length extension). Zamiast tego używa **konstrukcji gąbki** (sponge). \n  \n Proces składa się z fazy **absorpcji** (wchłaniania danych wejściowych) i fazy **wyciskania** (generowania skrótu o dowolnej długości)."
  },
  {
    "id": 101,
    "question": "Jakie ramki zarządzające są wymieniane w standardowym procesie przyłączania stacji do punktu dostępowego (Access Point) w sieci Wi-Fi?",
    "options": [
      {
        "text": "Authentication Request / Authentication Response",
        "inline_explanation": "(drugi etap: 'Open System Authentication' to formalność w sieciach z WPA2, ale jest wymagana przez standard)",
        "correct": true
      },
      {
        "text": "Association Request / Association Response",
        "inline_explanation": "(trzeci etap: faktyczne logiczne przyłączenie do sieci)",
        "correct": true
      },
      {
        "text": "Probe Request / Probe Response",
        "inline_explanation": "(pierwszy etap: aktywne skanowanie w poszukiwaniu sieci)",
        "correct": true
      },
      {
        "text": "Routing Information Protocol (RIP) Update",
        "inline_explanation": "(to protokół routingu warstwy 3, nie bierze udziału w nawiązywaniu połączenia warstwy 2)",
        "correct": false
      },
      {
        "text": "DHCP Discover / Offer",
        "inline_explanation": "(to następuje dopiero PO udanym przyłączeniu radiowym i zestawieniu łącza)",
        "correct": false
      }
    ],
    "explanation": "Proces przyłączania do sieci Wi-Fi składa się z trzech faz: \n  \n 1. **Skanowanie:** Stacja szuka sieci (Probe). \n 2. **Uwierzytelnianie 802.11:** Wymiana ramek Auth (w WPA2 to tylko \"dzień dobry\", właściwe uwierzytelnianie kluczem następuje później w EAPOL). \n 3. **Asocjacja:** Stacja prosi o przyłączenie (Assoc Req), a AP przydziela jej identyfikator (Association ID)."
  },
  {
    "id": 102,
    "question": "Jaką długość może mieć w sieciach IEEE 802.11 tzw. 'secret key' (np. PMK w WPA2)?",
    "options": [
      {
        "text": "256 bitów",
        "inline_explanation": "(standardowa długość klucza Pairwise Master Key w WPA2-Personal, wyliczanego z hasła)",
        "correct": true
      },
      {
        "text": "128 bitów",
        "inline_explanation": "(typowa długość klucza szyfrującego dane w algorytmie AES-CCMP)",
        "correct": true
      },
      {
        "text": "40 bitów",
        "inline_explanation": "(długość klucza w starym, złamanym standardzie WEP-64; 40 bitów klucza + 24 bity wektora inicjującego)",
        "correct": false
      },
      {
        "text": "4 bity",
        "inline_explanation": "(zbyt mało dla jakiejkolwiek kryptografii)",
        "correct": false
      },
      {
        "text": "512 bitów (jako standardowy klucz WEP)",
        "inline_explanation": "(nie istniał taki standard WEP; WEP kończył się na 104/128 bitach)",
        "correct": false
      }
    ],
    "explanation": "W standardzie WPA2/WPA3-Personal używamy hasła (passphrase), ale jest ono przekształcane funkcją PBKDF2 (z użyciem SSID jako soli) w 256-bitowy klucz zwany **PMK (Pairwise Master Key)**. Ten klucz jest podstawą do generowania kluczy tymczasowych szyfrujących transmisję."
  },
  {
    "id": 103,
    "question": "Atak DoS w sieciach Wi-Fi polegający na manipulacji ramkami RTS/CTS (tzw. NAV Attack) opiera się na:",
    "options": [
      {
        "text": "fizycznym zagłuszaniu częstotliwości szumem (Jamming)",
        "inline_explanation": "(to atak fizyczny, a nie na poziomie protokołu)",
        "correct": false
      },
      {
        "text": "manipulacji wartością pola Duration w nagłówku MAC",
        "inline_explanation": "(atakujący wpisuje tam maksymalną wartość, okłamując inne stacje)",
        "correct": true
      },
      {
        "text": "rezerwowaniu kanału na maksymalny możliwy czas, zmuszając inne stacje do milczenia",
        "inline_explanation": "(mechanizm Virtual Carrier Sensing)",
        "correct": true
      },
      {
        "text": "wysyłaniu ramek Deauthentication",
        "inline_explanation": "(to inny typ ataku DoS, polegający na rozłączaniu klientów)",
        "correct": false
      },
      {
        "text": "wydłużaniu czasu szczeliny (Slot Time)",
        "inline_explanation": "(parametr ten jest stały dla standardu, np. 9µs w 802.11n, i nie można go zmienić ramką)",
        "correct": false
      }
    ],
    "explanation": "Mechanizm CSMA/CA w WiFi wykorzystuje wirtualne wykrywanie nośnika. \n  \n Ramki RTS/CTS zawierają pole `Duration`. Inne stacje, słysząc taką ramkę, ustawiają swój licznik **NAV (Network Allocation Vector)** i milczą przez ten czas, oszczędzając energię i unikając kolizji. Atakujący wysyła fałszywe rezerwacje na maksymalny czas (ok. 32 ms), blokując kanał dla wszystkich."
  },
  {
    "id": 104,
    "question": "Atak ARP Poisoning (ARP Spoofing) w sieciach lokalnych:",
    "options": [
      {
        "text": "polega na przypisaniu wielu adresów IP do jednej karty sieciowej",
        "inline_explanation": "(to legalna technika zwana IP Aliasing)",
        "correct": false
      },
      {
        "text": "polega na rozsyłaniu fałszywych odpowiedzi ARP (ARP Reply)",
        "inline_explanation": "(odpowiedzi te wiążą MAC atakującego z IP ofiary lub bramy)",
        "correct": true
      },
      {
        "text": "umożliwia atak typu Man-in-the-Middle w sieciach przełączanych (switch)",
        "inline_explanation": "(przełącznik kieruje ruch do atakującego, myśląc, że to właściwy odbiorca)",
        "correct": true
      },
      {
        "text": "służy do łamania hasła WPA2",
        "inline_explanation": "(ARP działa w warstwie 2/3 już po nawiązaniu połączenia Wi-Fi)",
        "correct": false
      },
      {
        "text": "zatruwa pamięć podręczną (cache) ARP na komputerach ofiar",
        "inline_explanation": "(ofiary aktualizują swoje tablice błędnymi danymi)",
        "correct": true
      }
    ],
    "explanation": "ARP Poisoning polega na \"zatruwaniu\" tablic ARP innych urządzeń w sieci LAN. \n  \n Atakujący wysyła komunikat: \"Ja mam adres IP bramy (np. 192.168.1.1)!\". Komputery ofiar zapisują MAC atakującego jako MAC bramy i cały ruch internetowy wysyłają do niego."
  },
  {
    "id": 105,
    "question": "W przełączniku (switch) odebrano ramkę, w której adres źródłowy MAC jest nieznany, a adres docelowy MAC również jest nieznany. Tablica adresów MAC:",
    "options": [
      {
        "text": "zostanie zwiększona o 2 adresy",
        "inline_explanation": "(fałsz, switch nie uczy się adresu docelowego z tej ramki, bo nie wie, gdzie on jest)",
        "correct": false
      },
      {
        "text": "zostanie zwiększona o 1 adres (adres nadawcy)",
        "inline_explanation": "(switch uczy się: \"na tym porcie jest nadawca o takim MAC\")",
        "correct": true
      },
      {
        "text": "nie ulegnie zmianie",
        "inline_explanation": "(fałsz, proces uczenia następuje przy każdej ramce przychodzącej z nowym źródłem)",
        "correct": false
      },
      {
        "text": "zostanie wyczyszczona",
        "inline_explanation": "(nie ma powodu do czyszczenia tablicy)",
        "correct": false
      },
      {
        "text": "ramka zostanie odrzucona (dropped)",
        "inline_explanation": "(nie, ramka zostanie rozgłoszona - flood - na wszystkie porty poza źródłowym)",
        "correct": false
      }
    ],
    "explanation": "Algorytm działania przełącznika: \n  \n 1. **Learning (Uczenie):** Patrzy na Source MAC. Nie zna go? Dopisuje do tablicy (MAC + Port). Tablica rośnie o 1. \n 2. **Forwarding (Przekazywanie):** Patrzy na Destination MAC. Nie zna go? Robi **Flooding** (wysyła wszędzie), ale nie dopisuje go do tablicy, bo nie wie, na którym porcie jest odbiorca."
  },
  {
    "id": 106,
    "question": "Sieci VLAN (Virtual LAN) stosuje się m.in. w celu:",
    "options": [
      {
        "text": "ograniczenia domeny rozgłoszeniowej (broadcast domain)",
        "inline_explanation": "(ramki broadcast nie \"wyciekają\" poza obręb danego VLAN-u, co zmniejsza zbędny ruch w sieci)",
        "correct": true
      },
      {
        "text": "zastąpienia routerów w sieci",
        "inline_explanation": "(nie, do komunikacji *pomiędzy* VLAN-ami nadal potrzebny jest router lub switch L3)",
        "correct": false
      },
      {
        "text": "zwiększenia fizycznej przepustowości łącza (Bandwidth)",
        "inline_explanation": "(VLAN to podział logiczny, nie dodaje magicznie nowych kabli ani nie przyspiesza łącza)",
        "correct": false
      },
      {
        "text": "zwiększenia zasięgu sieci bezprzewodowej",
        "inline_explanation": "(to zadanie Access Pointów i anten, a nie logicznej segmentacji)",
        "correct": false
      },
      {
        "text": "separacji ruchu sieciowego (Security)",
        "inline_explanation": "(np. oddzielenie sieci gości od sieci księgowości, co zwiększa bezpieczeństwo)",
        "correct": true
      }
    ],
    "explanation": "VLAN dzieli fizyczną sieć LAN na mniejsze, odseparowane logicznie podsieci. \n ⚫ **Główny cel:** Ograniczenie domeny rozgłoszeniowej (Broadcast Domain). \n ⚫ **Zalety:** Bezpieczeństwo (separacja), wydajność (mniej śmieciowego ruchu), łatwiejsze zarządzanie strukturą logiczną niezależnie od fizycznego rozmieszczenia gniazdek."
  },
  {
    "id": 107,
    "question": "Jakie nowe techniki zostały wprowadzone w standardzie IEEE 802.11ax (Wi-Fi 6)?",
    "options": [
      {
        "text": "Kolorowanie obszarów BSS (BSS Coloring)",
        "inline_explanation": "(oznaczanie ramek \"kolorem\" własnej sieci, aby ignorować zakłócenia od sąsiadów)",
        "correct": true
      },
      {
        "text": "OFDMA (Orthogonal Frequency-Division Multiple Access)",
        "inline_explanation": "(podział kanału na mniejsze podnośne przypisane różnym użytkownikom, co zmniejsza opóźnienia)",
        "correct": true
      },
      {
        "text": "Modulacja 1024-QAM",
        "inline_explanation": "(jeszcze gęstsze upakowanie danych w symbolu, wymagające jednak bardzo dobrego sygnału)",
        "correct": true
      },
      {
        "text": "Technologia MIMO",
        "inline_explanation": "(to rozwiązanie było już obecne w starszych standardach 802.11n/ac)",
        "correct": false
      },
      {
        "text": "Target Wake Time (TWT)",
        "inline_explanation": "(mechanizm oszczędzania energii w urządzeniach IoT, które mogą \"spać\" przez ustalony czas)",
        "correct": true
      }
    ],
    "explanation": "Wi-Fi 6 (802.11ax) skupia się na wydajności w tłoku (High Efficiency). \n  \n **BSS Coloring** pozwala na lepsze wykorzystanie przestrzenne pasma w zatłoczonych biurach. Zamiast czekać, aż sąsiad skończy nadawać na tym samym kanale, urządzenie ignoruje jego transmisję, jeśli ma inny \"kolor\"."
  },
  {
    "id": 108,
    "question": "Jaki algorytm szyfrowania jest obowiązkowo stosowany w standardzie WPA2 (zgodnym z IEEE 802.11i)?",
    "options": [
      {
        "text": "RC5",
        "inline_explanation": "(nie jest używany w standardach Wi-Fi)",
        "correct": false
      },
      {
        "text": "AES (w trybie CCMP)",
        "inline_explanation": "(Advanced Encryption Standard - to podstawa bezpieczeństwa WPA2)",
        "correct": true
      },
      {
        "text": "RC4",
        "inline_explanation": "(był używany w starym WEP i przejściowym WPA/TKIP, obecnie uznany za niebezpieczny)",
        "correct": false
      },
      {
        "text": "3DES",
        "inline_explanation": "(nieużywany w Wi-Fi, zbyt wolny i przestarzały)",
        "correct": false
      },
      {
        "text": "ChaCha20",
        "inline_explanation": "(pojawia się dopiero w WPA3 jako opcja, w WPA2 standardem jest AES)",
        "correct": false
      }
    ],
    "explanation": "Historia szyfrowania w Wi-Fi: \n ⚫ **WEP:** RC4 (złamany). \n ⚫ **WPA (TKIP):** RC4 z rotacją kluczy (tymczasowe). \n ⚫ **WPA2 (CCMP):** **AES** (bezpieczny standard). \n ⚫ **WPA3:** AES-GCMP (jeszcze bezpieczniejszy)."
  },
  {
    "id": 109,
    "question": "Protokół TLS (Transport Layer Security) w procesie nawiązywania połączenia (Handshake) korzysta z:",
    "options": [
      {
        "text": "Infrastruktury Klucza Publicznego (PKI) i certyfikatów X.509",
        "inline_explanation": "(serwer musi wylegitymować się zaufanym certyfikatem, aby potwierdzić tożsamość)",
        "correct": true
      },
      {
        "text": "wyłącznie z symetrycznych kluczy PSK (Pre-Shared Keys)",
        "inline_explanation": "(rzadko używane w publicznym internecie, standardem są certyfikaty)",
        "correct": false
      },
      {
        "text": "protokołu UDP bez kontroli przepływu",
        "inline_explanation": "(TLS działa na TCP; wersja dla UDP to DTLS)",
        "correct": false
      },
      {
        "text": "algorytmów bezkluczowych",
        "inline_explanation": "(niemożliwe; kryptografia wymaga kluczy)",
        "correct": false
      },
      {
        "text": "szyfrowania asymetrycznego do wymiany klucza sesji",
        "inline_explanation": "(np. RSA lub Diffie-Hellman)",
        "correct": true
      }
    ],
    "explanation": "Protokół TLS (następca SSL) działa hybrydowo. \n  \n 1. **Uwierzytelnianie:** Serwer wysyła certyfikat X.509 (PKI). Przeglądarka sprawdza jego podpis. \n 2. **Wymiana kluczy:** Strony używają kryptografii asymetrycznej (RSA/DH), by uzgodnić wspólny klucz. \n 3. **Szyfrowanie danych:** Właściwa transmisja jest szyfrowana szybko (symetrycznie, np. AES)."
  },
  {
    "id": 110,
    "question": "Atak typu MAC Flooding na przełącznik sieciowy (switch) ma na celu:",
    "options": [
      {
        "text": "przesłanie tablic adresów MAC do administratora",
        "inline_explanation": "(nie, to atak ofensywny, a nie audyt)",
        "correct": false
      },
      {
        "text": "przepełnienie tablicy adresów (CAM Table)",
        "inline_explanation": "(tablica ma ograniczony rozmiar, np. 8000 wpisów)",
        "correct": true
      },
      {
        "text": "wymuszenie na przełączniku przejścia w tryb \"Fail-Open\" (działania jak Hub)",
        "inline_explanation": "(gdy tablica jest pełna, switch rozsyła nieznany ruch na wszystkie porty, umożliwiając podsłuch)",
        "correct": true
      },
      {
        "text": "zablokowanie portów protokołem STP",
        "inline_explanation": "(to inny mechanizm)",
        "correct": false
      },
      {
        "text": "szyfrowanie ruchu sieciowego",
        "inline_explanation": "(wręcz przeciwnie, ułatwia jego podsłuchanie)",
        "correct": false
      }
    ],
    "explanation": "MAC Flooding polega na zalaniu przełącznika tysiącami fałszywych ramek z losowymi źródłowymi adresami MAC. \n Switch szybko zapełnia swoją pamięć CAM (Content Addressable Memory). Gdy brakuje miejsca na nowe wpisy, urządzenie z bezpieczeństwa (lub wady) zaczyna traktować nowe ramki jak ruch broadcastowy (flood), wysyłając je do wszystkich. Atakujący może wtedy podsłuchać ruch innych użytkowników."
  },
  {
    "id": 111,
    "question": "Kryptoanaliza szyfru przestawieniowego (Transposition Cipher) opiera się na fakcie, że:",
    "options": [
      {
        "text": "histogram (rozkład częstości) znaków w szyfrogramie jest identyczny jak w języku naturalnym",
        "inline_explanation": "(szyfr zmienia tylko kolejność liter, a nie same litery, więc statystyka 'A', 'E' itd. pozostaje bez zmian)",
        "correct": true
      },
      {
        "text": "przestrzeń kluczy jest zazwyczaj bardzo mała (np. 8 bitów)",
        "inline_explanation": "(zależy od długości bloku permutacji, ale dla długich bloków $n!$ jest ogromne)",
        "correct": false
      },
      {
        "text": "wymaga on analizy różnicowej",
        "inline_explanation": "(metoda ta służy głównie do łamania nowoczesnych szyfrów blokowych)",
        "correct": false
      },
      {
        "text": "opiera się na problemie faktoryzacji liczb",
        "inline_explanation": "(to domena RSA)",
        "correct": false
      },
      {
        "text": "szyfrogram ma zupełnie inny rozkład liter niż tekst jawny (wygładzony histogram)",
        "inline_explanation": "(fałsz, to cecha szyfrów polialfabetycznych, a nie przestawieniowych)",
        "correct": false
      }
    ],
    "explanation": "Szyfr przestawieniowy to po prostu anagramowanie. \n Jeśli zaszyfrujesz słowo \"KAJAK\", otrzymasz np. \"AAKJK\". Liczba liter 'A' i 'K' się nie zmienia. Kryptoanalityk, widząc tekst o normalnym rozkładzie liter (dużo samogłosek), ale nieczytelny, od razu wie, że to szyfr przestawieniowy."
  },
  {
    "id": 112,
    "question": "Jakie kluczowe ulepszenie bezpieczeństwa wprowadza standard WPA3 w sieciach Wi-Fi?",
    "options": [
      {
        "text": "Wprowadza szyfrowanie oparte na algorytmie RC4",
        "inline_explanation": "(fałsz, RC4 jest przestarzały i niebezpieczny)",
        "correct": false
      },
      {
        "text": "Zastępuje mechanizm PSK protokołem SAE (Simultaneous Authentication of Equals)",
        "inline_explanation": "(SAE chroni przed atakami słownikowymi offline na hasło, nawet jeśli jest ono słabe)",
        "correct": true
      },
      {
        "text": "Wymusza stosowanie ochrony ramek zarządzających (Protected Management Frames - PMF)",
        "inline_explanation": "(zapobiega to prostym atakom rozłączeniowym - deauth attack)",
        "correct": true
      },
      {
        "text": "Rezygnuje z szyfrowania na rzecz samej autentykacji",
        "inline_explanation": "(nie, szyfrowanie jest nadal kluczowe; w WPA3 używa się AES-GCMP)",
        "correct": false
      },
      {
        "text": "Pozwala na używanie kluczy 40-bitowych dla kompatybilności z WEP",
        "inline_explanation": "(WPA3 zrywa kompatybilność z tak starymi i dziurawymi rozwiązaniami)",
        "correct": false
      }
    ],
    "explanation": "WPA3 naprawia główną wadę WPA2 - podatność na łamanie haseł metodą brute-force offline po przechwyceniu handshake'u. \n  \n Dzięki protokołowi **SAE** (Dragonfly), atakujący ma tylko jedną szansę na zgadnięcie hasła przy każdej próbie połączenia, co uniemożliwia masowe sprawdzanie haseł w domowym zaciszu."
  },
  {
    "id": 113,
    "question": "Własność Perfect Forward Secrecy (PFS) w protokołach kryptograficznych (np. TLS, IPsec) oznacza, że:",
    "options": [
      {
        "text": "ujawnienie klucza głównego (długoterminowego) pozwala odszyfrować wszystkie przeszłe rozmowy",
        "inline_explanation": "(to definicja BRAKU PFS)",
        "correct": false
      },
      {
        "text": "ujawnienie klucza głównego NIE pozwala na odszyfrowanie sesji, które odbyły się w przeszłości",
        "inline_explanation": "(klucze sesyjne były efemeryczne i zostały skasowane zaraz po rozmowie)",
        "correct": true
      },
      {
        "text": "dla każdej nowej sesji generowany jest nowy, tymczasowy zestaw kluczy",
        "inline_explanation": "(niezależny od klucza głównego serwera)",
        "correct": true
      },
      {
        "text": "system pozwala na odzyskanie zapomnianych haseł użytkowników",
        "inline_explanation": "(PFS dotyczy szyfrowania transmisji, a nie zarządzania tożsamością)",
        "correct": false
      },
      {
        "text": "wszystkie dane są archiwizowane na wypadek awarii",
        "inline_explanation": "(to backup, a nie PFS)",
        "correct": false
      }
    ],
    "explanation": "PFS to \"bezpiecznik\" na wypadek kradzieży klucza prywatnego serwera. \n  \n W systemach bez PFS (np. starym RSA key exchange), jeśli ktoś nagrywał Twój ruch przez rok i dziś ukradł klucz serwera - odczyta wszystko. Z PFS (np. DHE, ECDHE) - nie odczyta nic, bo klucze, które zabezpieczały tamte dane, istniały tylko przez chwilę i zniknęły."
  },
  {
    "id": 114,
    "question": "W protokole uzgadniania klucza Diffiego-Hellmana:",
    "options": [
      {
        "text": "jedna ze stron generuje klucz i przesyła go drugiej stronie w bezpiecznej kopercie",
        "inline_explanation": "(to model Key Transport, np. RSA, a nie Key Agreement jak DH)",
        "correct": false
      },
      {
        "text": "strony wymieniają się wyłącznie wartościami publicznymi, a wspólny sekret obliczają matematycznie",
        "inline_explanation": "(klucze prywatne nigdy nie są przesyłane przez sieć)",
        "correct": true
      },
      {
        "text": "bezpieczeństwo opiera się na trudności problemu logarytmu dyskretnego",
        "inline_explanation": "(znalezienie wykładnika $x$ mając $g^x \\mod p$ jest obliczeniowo trudne)",
        "correct": true
      },
      {
        "text": "algorytm służy bezpośrednio do szyfrowania plików",
        "inline_explanation": "(służy tylko do ustalenia klucza, którym potem szyfruje np. AES)",
        "correct": false
      },
      {
        "text": "system jest całkowicie odporny na komputery kwantowe",
        "inline_explanation": "(nie, algorytm Shora łamie DH w czasie wielomianowym)",
        "correct": false
      }
    ],
    "explanation": "Istotą DH jest to, że Alicja i Bob mogą uzgodnić kolor (klucz), krzycząc do siebie przez pokój pełen ludzi, a nikt inny nie będzie wiedział, jaki to kolor. \n Wymieniają się \"wymieszanymi\" danymi publicznymi, a klucz końcowy powstaje dopiero w ich głowach (komputerach) dzięki matematyce potęgowania modularnego."
  },
  {
    "id": 115,
    "question": "Przykładem uczenia nienadzorowanego (Unsupervised Learning) jest:",
    "options": [
      {
        "text": "wykrywanie spamu w poczcie",
        "inline_explanation": "(to klasyfikacja nadzorowana - algorytm uczy się na bazie maili oznaczonych jako 'spam' lub 'ham')",
        "correct": false
      },
      {
        "text": "grupowanie danych (Clustering), np. segmentacja klientów",
        "inline_explanation": "(algorytm sam znajduje podobieństwa i dzieli dane na grupy bez wcześniejszych etykiet)",
        "correct": true
      },
      {
        "text": "redukcja wymiarowości danych (np. PCA)",
        "inline_explanation": "(kompresja danych poprzez znalezienie najważniejszych cech)",
        "correct": true
      },
      {
        "text": "rozpoznawania pisma ręcznego",
        "inline_explanation": "(to klasyfikacja nadzorowana na podstawie bazy MNIST)",
        "correct": false
      },
      {
        "text": "wykrywanie anomalii (Anomaly Detection) w ruchu sieciowym",
        "inline_explanation": "(system uczy się co jest normą, a co odstępstwem, nie wiedząc z góry czym jest atak)",
        "correct": true
      }
    ],
    "explanation": "Rodzaje uczenia maszynowego: \n 1. **Nadzorowane (z nauczycielem):** Mamy dane i odpowiedzi (etykiety). Np. \"To jest zdjęcie kota\". Algorytm uczy się rozpoznawać koty. \n 2. **Nienadzorowane (bez nauczyciela):** Mamy tylko dane. Algorytm sam szuka w nich struktur, grup (klastrów) lub anomalii."
  },
  {
    "id": 116,
    "question": "Algorytm wykrywania anomalii w systemach IDS (Intrusion Detection System) jest szczególnie przydatny, gdy:",
    "options": [
      {
        "text": "chcemy wykrywać ataki typu Zero-Day (nieznane wcześniej)",
        "inline_explanation": "(anomalie to odchylenia od normy, więc system wykryje coś \"dziwnego\" nawet jeśli nie ma na to sygnatury)",
        "correct": true
      },
      {
        "text": "zależy nam na zerowym poziomie fałszywych alarmów (False Positives)",
        "inline_explanation": "(systemy anomalii generują dużo fałszywych alarmów, bo każdy nietypowy, ale legalny ruch jest podejrzany)",
        "correct": false
      },
      {
        "text": "nie posiadamy wystarczającej mocy obliczeniowej",
        "inline_explanation": "(analiza statystyczna/behawioralna wymaga więcej zasobów niż proste porównywanie sygnatur)",
        "correct": false
      },
      {
        "text": "chcemy, aby system działał szybciej niż ten oparty na sygnaturach",
        "inline_explanation": "(jest odwrotnie, analiza anomalii jest wolniejsza)",
        "correct": false
      },
      {
        "text": "dane wejściowe mają większy wymiar niż dane wyjściowe",
        "inline_explanation": "(to opis techniczny dotyczący np. kompresji danych, bez związku z logiką IDS)",
        "correct": false
      }
    ],
    "explanation": "Metody oparte na anomaliach uczą się profilu \"normalnego\" ruchu sieciowego. \n  \n Jeśli ruch odbiega od normy (np. nagły skok transferu o 3:00 w nocy), system wszczyna alarm. Dzięki temu wykrywa ataki **Zero-Day**, na które nie ma jeszcze sygnatur (szczepionek)."
  },
  {
    "id": 117,
    "question": "Termin SQL Injection (SQLi) oznacza:",
    "options": [
      {
        "text": "możliwość umieszczenia zapytania SQL w kodzie źródłowym strony",
        "inline_explanation": "(nieprecyzyjne; programista robi to celowo, a atak polega na manipulacji tym zapytaniem)",
        "correct": false
      },
      {
        "text": "atak polegający na wstrzyknięciu złośliwego kodu SQL poprzez dane wejściowe aplikacji",
        "inline_explanation": "(np. wpisanie `' OR '1'='1` w polu logowania, co zmienia logikę zapytania do bazy)",
        "correct": true
      },
      {
        "text": "wstrzyknięcie skryptu JavaScript do przeglądarki ofiary",
        "inline_explanation": "(to definicja ataku XSS - Cross-Site Scripting)",
        "correct": false
      },
      {
        "text": "atak na serwer DNS w celu przekierowania ruchu",
        "inline_explanation": "(to DNS Spoofing)",
        "correct": false
      },
      {
        "text": "metodę optymalizacji zapytań bazodanowych",
        "inline_explanation": "(SQL Injection to zagrożenie, a nie metoda optymalizacji)",
        "correct": false
      }
    ],
    "explanation": "SQL Injection to jeden z najgroźniejszych błędów bezpieczeństwa (OWASP Top 10). Polega na tym, że aplikacja nie filtruje danych od użytkownika i skleja je bezpośrednio z zapytaniem do bazy. \n Przykład: `SELECT * FROM users WHERE name = '` + `$userInput` + `'` \n Jeśli wpiszesz `x' OR '1'='1`, baza zwróci wszystkich użytkowników."
  },
  {
    "id": 118,
    "question": "Prawdziwe stwierdzenie dotyczące certyfikatów X.509:",
    "options": [
      {
        "text": "są wykorzystywane do weryfikacji tożsamości strony w procesie nawiązywania połączenia SSL/TLS",
        "inline_explanation": "(przeglądarka sprawdza certyfikat serwera, by upewnić się, że łączy się z właściwym bankiem)",
        "correct": true
      },
      {
        "text": "zawierają w sobie klucz prywatny użytkownika",
        "inline_explanation": "(klucz prywatny nigdy nie jest częścią publicznego certyfikatu)",
        "correct": false
      },
      {
        "text": "służą wyłącznie do szyfrowania dysków twardych",
        "inline_explanation": "(głównie służą do zabezpieczania komunikacji sieciowej i podpisu elektronicznego)",
        "correct": false
      },
      {
        "text": "są generowane przez użytkownika i nie wymagają podpisu zaufanej trzeciej strony",
        "inline_explanation": "(to tzw. Self-Signed Certificate, któremu przeglądarki domyślnie nie ufają)",
        "correct": false
      },
      {
        "text": "są tajne i nie mogą być udostępniane publicznie",
        "inline_explanation": "(certyfikat jest z definicji publiczny - jak wizytówka)",
        "correct": false
      }
    ],
    "explanation": "Certyfikat X.509 to cyfrowy dokument tożsamości. \n  \n Wiąże on **Klucz Publiczny** z **Tożsamością** (np. nazwą domeny `google.com`). Jest podpisany przez zaufany urząd (CA), co pozwala innym ufać, że ten klucz faktycznie należy do tej domeny."
  },
  {
    "id": 119,
    "question": "Głównym zadaniem zapory sieciowej (Firewall) jest:",
    "options": [
      {
        "text": "łączenie dwóch lub więcej odrębnych sieci ze sobą",
        "inline_explanation": "(to zadanie routera)",
        "correct": false
      },
      {
        "text": "filtrowanie ruchu sieciowego wchodzącego i wychodzącego na podstawie reguł",
        "inline_explanation": "(blokowanie niepożądanych połączeń, np. na porcie 445)",
        "correct": true
      },
      {
        "text": "przydzielanie adresów IP w sieci lokalnej",
        "inline_explanation": "(to zadanie serwera DHCP)",
        "correct": false
      },
      {
        "text": "skanowanie plików na dysku w poszukiwaniu wirusów",
        "inline_explanation": "(to zadanie programu antywirusowego, klasyczny firewall sieciowy tego nie robi)",
        "correct": false
      },
      {
        "text": "zamiana nazw domenowych na adresy IP",
        "inline_explanation": "(to zadanie serwera DNS)",
        "correct": false
      }
    ],
    "explanation": "Zapora sieciowa (Firewall) to strażnik sieci. Decyduje, które pakiety mogą przejść, a które należy zablokować. Decyzję podejmuje na podstawie: \n ⚫ Adresów IP (kto?) \n ⚫ Portów (jaka usługa?) \n ⚫ Protokołów (TCP/UDP) \n ⚫ Stanu połączenia (Stateful Inspection)."
  },
  {
    "id": 120,
    "question": "Uwierzytelnianie dwuskładnikowe (2FA) polega na:",
    "options": [
      {
        "text": "użyciu dwóch różnych haseł do jednego konta",
        "inline_explanation": "(to nadal jeden składnik - \"coś, co wiesz\")",
        "correct": false
      },
      {
        "text": "połączeniu dwóch różnych kategorii składników (np. hasło + kod SMS)",
        "inline_explanation": "(Wiedza + Posiadanie)",
        "correct": true
      },
      {
        "text": "logowaniu się tym samym hasłem do dwóch różnych serwisów",
        "inline_explanation": "(to zła praktyka bezpieczeństwa, a nie 2FA)",
        "correct": false
      },
      {
        "text": "szyfrowaniu danych dwoma różnymi kluczami",
        "inline_explanation": "(to inna dziedzina kryptografii)",
        "correct": false
      },
      {
        "text": "konieczności wpisania hasła dwa razy",
        "inline_explanation": "(to tylko potwierdzenie hasła, nie zwiększa bezpieczeństwa logowania)",
        "correct": false
      }
    ],
    "explanation": "Prawdziwe 2FA wymaga użycia składników z dwóch różnych grup: \n 1. **Coś, co wiesz** (hasło, PIN). \n 2. **Coś, co masz** (telefon, klucz YubiKey, karta). \n 3. **Coś, czym jesteś** (odcisk palca, skan twarzy). \n Hasło + PIN to nie jest 2FA (bo to dwa razy wiedza). Hasło + SMS to jest 2FA."
  },
  {
    "id": 121,
    "question": "Jaka jest podstawowa różnica między połączeniem VPN (Virtual Private Network) a serwerem Proxy?",
    "options": [
      {
        "text": "Serwer proxy tworzy w pełni zaszyfrowany tunel dla całego ruchu z systemu operacyjnego",
        "inline_explanation": "(fałsz, proxy zazwyczaj nie szyfruje ruchu i działa tylko dla konkretnej aplikacji, np. przeglądarki)",
        "correct": false
      },
      {
        "text": "VPN szyfruje cały ruch sieciowy wychodzący z urządzenia i działa na poziomie systemu (warstwa 3/4)",
        "inline_explanation": "(tworzy wirtualny interfejs sieciowy, przez który przechodzi każdy pakiet)",
        "correct": true
      },
      {
        "text": "Proxy szyfruje ruch, a VPN jedynie ukrywa adres IP",
        "inline_explanation": "(jest odwrotnie: VPN szyfruje, a zwykłe proxy HTTP często tylko przekazuje ruch)",
        "correct": false
      },
      {
        "text": "Nie ma żadnej różnicy, to synonimy",
        "inline_explanation": "(to dwie różne technologie o różnym poziomie izolacji)",
        "correct": false
      },
      {
        "text": "VPN działa tylko w przeglądarce internetowej",
        "inline_explanation": "(fałsz, VPN obejmuje cały system, np. gry, aktualizacje, pocztę)",
        "correct": false
      }
    ],
    "explanation": "Różnice: \n  \n ⚫ **VPN:** Szyfruje cały ruch z komputera (tunel). Dostawca internetu widzi tylko śmieci. \n ⚫ **Proxy:** Działa na poziomie aplikacji (np. Firefox). Zmienia Twój adres IP dla strony docelowej, ale często nie szyfruje transmisji (dostawca widzi, co robisz)."
  },
  {
    "id": 122,
    "question": "W jaki sposób przetwarzane są reguły na listach sterowania dostępem (ACL - Access Control List) w routerach/firewallach?",
    "options": [
      {
        "text": "Przeszukiwane są sekwencyjnie (od góry do dołu) do pierwszego dopasowania",
        "inline_explanation": "(tzw. First Match Wins - jeśli pakiet pasuje do reguły nr 5, reguły 6, 7... są ignorowane)",
        "correct": true
      },
      {
        "text": "Zawsze sprawdzane są wszystkie reguły, a decyzja podejmowana jest na końcu",
        "inline_explanation": "(nie, to byłoby nieefektywne; decyzja zapada przy pierwszym trafieniu)",
        "correct": false
      },
      {
        "text": "Są przeszukiwane losowo w celu rozłożenia obciążenia",
        "inline_explanation": "(nie deterministycznie)",
        "correct": false
      },
      {
        "text": "Kolejność reguł nie ma znaczenia",
        "inline_explanation": "(ma kluczowe znaczenie; ogólna reguła \"blokuj wszystko\" na początku zablokuje dostęp, nawet jeśli potem na liście jest \"pozwól Janowi\")",
        "correct": false
      },
      {
        "text": "Domyślnie na końcu listy znajduje się ukryta reguła \"Pozwól na wszystko\" (Implicit Permit)",
        "inline_explanation": "(jest odwrotnie: Implicit Deny - co nie jest dozwolone, jest zabronione)",
        "correct": false
      }
    ],
    "explanation": "ACL działają według logiki **First Match Wins**: \n  \n 1. Router sprawdza regułę nr 1. Pasuje? Wykonaj akcję i koniec. \n 2. Nie pasuje? Sprawdź regułę nr 2. \n 3. ... \n 4. Jeśli żadna nie pasuje, zadziała ukryta reguła ostatnia: **Deny All**."
  },
  {
    "id": 123,
    "question": "Który z wymienionych protokołów **NIE** wchodzi w skład pakietu IPsec (Internet Protocol Security)?",
    "options": [
      {
        "text": "SSL (Secure Sockets Layer)",
        "inline_explanation": "(to konkurencyjna technologia działająca w warstwie aplikacji/sesji, np. w HTTPS)",
        "correct": true
      },
      {
        "text": "AH (Authentication Header)",
        "inline_explanation": "(zapewnia integralność i uwierzytelnianie pakietu, ale nie szyfruje danych)",
        "correct": false
      },
      {
        "text": "ESP (Encapsulating Security Payload)",
        "inline_explanation": "(zapewnia szyfrowanie, integralność i uwierzytelnianie)",
        "correct": false
      },
      {
        "text": "IKE (Internet Key Exchange)",
        "inline_explanation": "(służy do negocjacji parametrów i wymiany kluczy w IPsec)",
        "correct": false
      },
      {
        "text": "IKEv2",
        "inline_explanation": "(nowsza wersja protokołu wymiany kluczy IPsec, obsługująca mobilność)",
        "correct": false
      }
    ],
    "explanation": "IPsec to zestaw protokołów warstwy sieciowej (Layer 3): **AH**, **ESP** i **IKE**. \n SSL (i jego następca TLS) to zupełnie inna technologia, działająca wyżej (Layer 4/7), używana do zabezpieczania stron WWW i aplikacji."
  },
  {
    "id": 124,
    "question": "Który opis najlepiej definiuje cechę niezaprzeczalności (Non-repudiation) w bezpieczeństwie informacji?",
    "options": [
      {
        "text": "Zdolność unikania sytuacji niepożądanych, takich jak awaria serwera",
        "inline_explanation": "(to definicja Dostępności - Availability)",
        "correct": false
      },
      {
        "text": "Gwarancja, że nadawca nie może wyprzeć się faktu wysłania komunikatu",
        "inline_explanation": "(dzięki podpisowi cyfrowemu mamy matematyczny dowód autorstwa)",
        "correct": true
      },
      {
        "text": "Zapewnienie, że dane nie zostały zmodyfikowane w trakcie przesyłu",
        "inline_explanation": "(to definicja Integralności)",
        "correct": false
      },
      {
        "text": "Ukrywanie treści wiadomości przed osobami postronnymi",
        "inline_explanation": "(to definicja Poufności)",
        "correct": false
      },
      {
        "text": "Możliwość odtworzenia systemu po katastrofie",
        "inline_explanation": "(to Disaster Recovery)",
        "correct": false
      }
    ],
    "explanation": "Niezaprzeczalność to prawno-techniczna cecha, która wiąże podmiot z działaniem. \n Jeśli podpiszesz e-mail swoim certyfikatem kwalifikowanym, nie możesz potem powiedzieć w sądzie \"to nie ja wysłałem\". To jest **Non-repudiation**."
  },
  {
    "id": 125,
    "question": "Jako inżynier bezpieczeństwa w chmurze wykryłeś, że klucz dostępu (Access Key) pracownika został upubliczniony na GitHubie. Jaka jest prawidłowa pierwsza reakcja?",
    "options": [
      {
        "text": "Natychmiast usuń całe konto użytkownika z systemu",
        "inline_explanation": "(zbyt radykalne; utrudni śledztwo i zablokuje pracownikowi dostęp do innych narzędzi)",
        "correct": false
      },
      {
        "text": "Dezaktywuj (lub usuń) skompromitowany klucz i rozpocznij analizę logów",
        "inline_explanation": "(odcięcie dostępu atakującemu to priorytet, a logi pozwolą ocenić szkody)",
        "correct": true
      },
      {
        "text": "Zignoruj zdarzenie, klucze wygasają same po 24 godzinach",
        "inline_explanation": "(klucze API zazwyczaj są ważne bezterminowo, dopóki się ich nie rotuje)",
        "correct": false
      },
      {
        "text": "Zmień hasło do konsoli webowej tego użytkownika",
        "inline_explanation": "(nie pomoże, bo atakujący ma klucz API, który działa niezależnie od hasła do konsoli)",
        "correct": false
      },
      {
        "text": "Wyślij e-mail do GitHuba z prośbą o usunięcie repozytorium",
        "inline_explanation": "(zanim zareagują, miną godziny; klucz trzeba unieważnić w sekundy)",
        "correct": false
      }
    ],
    "explanation": "Procedura **Incident Response** przy wycieku poświadczeń: \n 1. **Containment (Powstrzymanie):** Unieważnij (Revoke) wyciekły klucz. \n 2. **Analysis (Analiza):** Sprawdź w logach (np. CloudTrail), czy ktoś użył tego klucza i co zrobił (np. czy uruchomił koparki krypto). \n 3. **Remediation (Naprawa):** Cofnij nieautoryzowane zmiany. \n 4. **Rotation:** Wygeneruj nowy klucz dla pracownika."
  },
  {
    "id": 126,
    "question": "W modelu współdzielonej odpowiedzialności (Shared Responsibility Model) w chmurze typu IaaS (np. Amazon EC2), za które elementy odpowiada KLIENT?",
    "options": [
      {
        "text": "Fizyczne zabezpieczenie serwerowni i zasilanie",
        "inline_explanation": "(to domena dostawcy chmury - AWS/Azure/Google)",
        "correct": false
      },
      {
        "text": "Ochrona warstwy wirtualizacji (Hypervisor) przed atakami sprzętowymi",
        "inline_explanation": "(za bezpieczeństwo \"samej chmury\" odpowiada dostawca)",
        "correct": false
      },
      {
        "text": "Aktualizacja i łatanie systemu operacyjnego gościa (Guest OS) oraz aplikacji",
        "inline_explanation": "(dostawca daje tylko wirtualną maszynę, klient musi dbać o to, co w niej zainstaluje)",
        "correct": true
      },
      {
        "text": "Wymiana uszkodzonych dysków twardych w macierzach",
        "inline_explanation": "(to warstwa fizyczna, klient nawet nie wie, gdzie ten dysk jest)",
        "correct": false
      },
      {
        "text": "Zapewnienie łączności sieciowej między regionami chmury (Backbone)",
        "inline_explanation": "(to infrastruktura globalna dostawcy)",
        "correct": false
      }
    ],
    "explanation": "Model ten dzieli obowiązki: \n  \n ⚫ **Dostawca:** Odpowiada za bezpieczeństwo **CHMURY** (fizyka, prąd, sieć, hosty). \n ⚫ **Klient:** Odpowiada za bezpieczeństwo **W CHMURZE** (dane, systemy operacyjne, konfiguracja firewalli, szyfrowanie)."
  },
  {
    "id": 127,
    "question": "Systemy Wysokiej Dostępności (High Availability - HA) charakteryzują się:",
    "options": [
      {
        "text": "brakiem pojedynczych punktów awarii (SPOF - Single Point of Failure)",
        "inline_explanation": "(to kluczowa cecha; np. dwa zasilacze, dwa serwery, dwie drogi sieciowe)",
        "correct": true
      },
      {
        "text": "gwarancją dostępności na poziomie 90%",
        "inline_explanation": "(90% to ponad miesiąc przestoju rocznie; HA celuje w 99.9% i więcej)",
        "correct": false
      },
      {
        "text": "koniecznością cotygodniowego wyłączania w celu konserwacji",
        "inline_explanation": "(HA ma działać ciągle; konserwacja odbywa się na jednym węźle, gdy drugi pracuje)",
        "correct": false
      },
      {
        "text": "wykorzystaniem wyłącznie jednego, potężnego superkomputera",
        "inline_explanation": "(nawet superkomputer może się zepsuć; HA wymaga redundancji/klastra)",
        "correct": false
      },
      {
        "text": "brakiem konieczności robienia kopii zapasowych",
        "inline_explanation": "(HA to nie backup; awaria logiczna - np. usunięcie danych - replikuje się na obu węzłach)",
        "correct": false
      }
    ],
    "explanation": "Wysoka Dostępność (HA) to projektowanie systemów tak, aby zminimalizować przestoje. \n  \n Osiąga się to poprzez **redundancję** (nadmiarowość). Jeśli jeden serwer padnie, drugi przejmuje jego zadania (Failover). Kluczowe jest wyeliminowanie **SPOF**."
  },
  {
    "id": 128,
    "question": "Dobrą praktyką zapewniania bezpieczeństwa w chmurze jest:",
    "options": [
      {
        "text": "Bazowanie wyłącznie na własnych mechanizmach, ignorując narzędzia dostawcy",
        "inline_explanation": "(błąd; natywne narzędzia chmurowe są lepiej zintegrowane i skalowalne)",
        "correct": false
      },
      {
        "text": "Stosowanie zasady najmniejszych przywilejów (Least Privilege) w IAM",
        "inline_explanation": "(użytkownik/aplikacja ma tylko takie uprawnienia, jakie są niezbędne do działania, i nic więcej)",
        "correct": true
      },
      {
        "text": "Publiczne udostępnianie zasobników (S3 Buckets) dla ułatwienia pracy deweloperom",
        "inline_explanation": "(to jedna z najczęstszych przyczyn wycieków danych w chmurze)",
        "correct": false
      },
      {
        "text": "Używanie konta głównego (Root Account) do codziennych zadań administracyjnych",
        "inline_explanation": "(konto root powinno być zabezpieczone MFA i używane tylko w sytuacjach awaryjnych)",
        "correct": false
      },
      {
        "text": "Wyłączenie logowania audytowego (np. CloudTrail) w celu oszczędności miejsca",
        "inline_explanation": "(logi są niezbędne do analizy incydentów i compliance)",
        "correct": false
      }
    ],
    "explanation": "Bezpieczeństwo w chmurze opiera się na wielu warstwach. Zasada **Least Privilege** jest fundamentalna: jeśli aplikacja potrzebuje tylko czytać z bazy, nie dajemy jej uprawnień do zapisu ani do kasowania serwerów. Ogranicza to zasięg szkód w przypadku włamania (Lateral Movement)."
  },
  {
    "id": 129,
    "question": "W kontekście szyfrowania danych przesyłanych do chmury publicznej (Encryption in Transit), prawdą jest, że:",
    "options": [
      {
        "text": "Szyfrowanie jest możliwe tylko przy użyciu kluczy dostarczonych przez operatora chmury",
        "inline_explanation": "(fałsz, można używać własnych kluczy w modelu BYOK - Bring Your Own Key)",
        "correct": false
      },
      {
        "text": "Dane mogą być szyfrowane po stronie klienta (Client-side Encryption) przed wysłaniem",
        "inline_explanation": "(wtedy operator chmury widzi tylko zaszyfrowany blob i nie ma dostępu do treści)",
        "correct": true
      },
      {
        "text": "Szyfrowanie danych w chmurze jest niemożliwe ze względu na spadek wydajności",
        "inline_explanation": "(współczesne procesory sprzętowo wspierają szyfrowanie np. AES-NI, narzut jest pomijalny)",
        "correct": false
      },
      {
        "text": "Protokoły takie jak HTTPS/TLS są zbędne wewnątrz sieci VPC operatora",
        "inline_explanation": "(model Zero Trust zakłada szyfrowanie wszędzie, nawet w sieci wewnętrznej)",
        "correct": false
      },
      {
        "text": "Szyfrowanie chroni dane przed usunięciem",
        "inline_explanation": "(szyfrowanie chroni poufność, a nie dostępność; zaszyfrowany plik nadal można skasować)",
        "correct": false
      }
    ],
    "explanation": "Mamy dwa modele: \n 1. **Server-Side Encryption:** Chmura szyfruje dane po odebraniu (chroni przed kradzieżą dysków w data center). \n 2. **Client-Side Encryption:** Użytkownik szyfruje dane u siebie. To daje pełną kontrolę - nawet operator chmury ani rząd nie odczytają danych bez klucza, który posiada tylko klient."
  },
  {
    "id": 130,
    "question": "W chmurowym magazynie obiektowym (Object Storage, np. S3), funkcja Wersjonowania (Versioning):",
    "options": [
      {
        "text": "Jest niemożliwa do włączenia ze względów bezpieczeństwa",
        "inline_explanation": "(jest dostępna i zalecana)",
        "correct": false
      },
      {
        "text": "Pozwala na przechowywanie i odzyskiwanie wielu wariantów tego samego obiektu",
        "inline_explanation": "(chroni przed przypadkowym nadpisaniem lub usunięciem danych)",
        "correct": true
      },
      {
        "text": "Służy do instalowania systemów operacyjnych",
        "inline_explanation": "(do tego służy Block Storage, a nie Object Storage)",
        "correct": false
      },
      {
        "text": "Zmniejsza koszty przechowywania danych",
        "inline_explanation": "(zwiększa, bo przechowujemy każdą wersję pliku, zajmując więcej miejsca)",
        "correct": false
      },
      {
        "text": "Automatycznie szyfruje dane publiczne",
        "inline_explanation": "(wersjonowanie nie ma związku z szyfrowaniem ani uprawnieniami publicznymi)",
        "correct": false
      }
    ],
    "explanation": "Wersjonowanie w Object Storage działa jak \"Time Machine\". Jeśli nadpiszesz plik `raport.docx` nową wersją (nawet pustą lub zaszyfrowaną przez wirusa), chmura zachowa starą wersję w historii. Możesz ją w każdej chwili przywrócić. To kluczowa ochrona przed błędem ludzkim i ransomware."
  },
  {
    "id": 131,
    "question": "Które zdanie dotyczące bezpieczeństwa baz danych w chmurze (np. usługa RDS, Azure SQL) jest PRAWDZIWE?",
    "options": [
      {
        "text": "Korzystanie z usługi zarządzanej zwalnia użytkownika z obowiązku zabezpieczania dostępu do danych",
        "inline_explanation": "(fałsz, dostawca dba o infrastrukturę, ale to klient decyduje, kto ma hasło do bazy)",
        "correct": false
      },
      {
        "text": "Użytkownik nadal odpowiada za zarządzanie uprawnieniami (kto ma dostęp), szyfrowanie danych i ich klasyfikację",
        "inline_explanation": "(zgodnie z modelem współdzielonej odpowiedzialności w PaaS)",
        "correct": true
      },
      {
        "text": "Operator chmury automatycznie decyduje, którzy pracownicy firmy mają dostęp do konkretnych tabel",
        "inline_explanation": "(operator nie zna struktury organizacyjnej klienta ani jego polityki dostępu)",
        "correct": false
      },
      {
        "text": "Bazy danych w chmurze są domyślnie publicznie dostępne dla całego Internetu",
        "inline_explanation": "(domyślnie są izolowane w sieci prywatnej VPC i nie mają publicznego adresu IP)",
        "correct": false
      },
      {
        "text": "W modelu PaaS użytkownik musi samodzielnie instalować poprawki bezpieczeństwa systemu operacyjnego serwera bazy",
        "inline_explanation": "(w PaaS robi to dostawca; w IaaS robiłby to klient)",
        "correct": false
      }
    ],
    "explanation": "W usługach zarządzanych (PaaS) dostawca dba o \"hydraulikę\" (sprzęt, OS, silnik bazy). \n  \n Jednak to **klient** decyduje, co wlewa do tej bazy i komu pozwala z niej czerpać. Odpowiedzialność za **dane** i **dostęp** zawsze leży po stronie klienta."
  },
  {
    "id": 132,
    "question": "Ze względów bezpieczeństwa, sieć zarządzająca (Management Network) i sieć produkcyjna (Production Network) w wirtualnym centrum danych powinny być:",
    "options": [
      {
        "text": "połączone w jedną wspólną sieć dla ułatwienia komunikacji",
        "inline_explanation": "(to błąd krytyczny; atak na publiczną aplikację webową dałby atakującemu dostęp do paneli administracyjnych)",
        "correct": false
      },
      {
        "text": "ściśle odseparowane od siebie (np. oddzielne VLAN-y, osobne fizyczne karty sieciowe)",
        "inline_explanation": "(izolacja sprawia, że kompromitacja maszyny wirtualnej nie zagraża infrastrukturze zarządzającej)",
        "correct": true
      },
      {
        "text": "dostępne publicznie z Internetu bez konieczności stosowania VPN",
        "inline_explanation": "(interfejsy zarządzające jak vCenter czy SSH nigdy nie powinny być wystawione do sieci publicznej)",
        "correct": false
      },
      {
        "text": "skonfigurowane tak, aby ruch produkcyjny miał priorytet nad zarządzającym",
        "inline_explanation": "(często jest odwrotnie - utrata kontroli nad klastrem jest groźniejsza niż spowolnienie aplikacji)",
        "correct": false
      },
      {
        "text": "obsługiwane przez ten sam serwer DHCP w tej samej podsieci",
        "inline_explanation": "(łamie zasadę separacji)",
        "correct": false
      }
    ],
    "explanation": "Złota zasada bezpieczeństwa infrastruktury: **Separacja**. \n Ruch administracyjny (logowanie do hiperwizora, vMotion, Storage) musi być odizolowany od ruchu \"brudnego\" (aplikacje dostępne dla klientów). Dzięki temu, nawet jeśli haker przejmie serwer WWW, nie dostanie się do panelu sterowania całą chmurą."
  },
  {
    "id": 133,
    "question": "Migracja maszyn wirtualnych na żywo (np. vMotion, Live Migration) jest automatycznie inicjowana przez systemy klastrowe zazwyczaj w sytuacji:",
    "options": [
      {
        "text": "przeciążenia jednego z serwerów fizycznych (Load Balancing / DRS)",
        "inline_explanation": "(maszyny są przenoszone na mniej obciążone hosty, by wyrównać wydajność)",
        "correct": true
      },
      {
        "text": "wykrycia ataku hakerskiego na maszynę wirtualną",
        "inline_explanation": "(systemy wirtualizacji rzadko mają taką logikę; to rola IPS/IDS)",
        "correct": false
      },
      {
        "text": "gdy maszyna wirtualna jest wyłączona",
        "inline_explanation": "(vMotion dotyczy działających maszyn; wyłączone po prostu się uruchamia gdzie indziej)",
        "correct": false
      },
      {
        "text": "w celu zwiększenia pojemności wirtualnego dysku",
        "inline_explanation": "(to operacja na pamięci masowej - Storage vMotion - ale nie wynika z obciążenia CPU/RAM)",
        "correct": false
      },
      {
        "text": "podczas instalacji aktualizacji w systemie gościa",
        "inline_explanation": "(aktualizacja OS wewnątrz VM nie wymaga przenoszenia jej na inny host)",
        "correct": false
      }
    ],
    "explanation": "Migracja na żywo pozwala przenieść działającą maszynę między serwerami bez przerywania jej pracy (użytkownik nie zauważa różnicy). \n Stosuje się ją głównie do: \n 1. **Balansowania obciążenia (DRS):** Gdy jeden serwer się poci, przenosimy VM tam, gdzie jest luźniej. \n 2. **Konserwacji (Maintenance Mode):** Gdy administrator musi wyłączyć fizyczny serwer (np. by dołożyć RAM), \"ewakuuje\" z niego maszyny."
  },
  {
    "id": 134,
    "question": "W modelu IaaS (Infrastructure as a Service) chmury publicznej, za co odpowiada KLIENT?",
    "options": [
      {
        "text": "Za fizyczną utylizację uszkodzonych dysków twardych",
        "inline_explanation": "(to zadanie operatora chmury)",
        "correct": false
      },
      {
        "text": "Za zabezpieczenie i aktualizację systemu operacyjnego gościa (Guest OS)",
        "inline_explanation": "(klient dostaje \"czystą\" maszynę i sam musi dbać o to, co jest w środku)",
        "correct": true
      },
      {
        "text": "Za konfigurację sprzętowych firewalli brzegowych w serwerowni",
        "inline_explanation": "(klient konfiguruje tylko wirtualne Security Groups, nie ma dostępu do sprzętu)",
        "correct": false
      },
      {
        "text": "Za ochronę fizyczną budynku data center",
        "inline_explanation": "(znowu: domena operatora)",
        "correct": false
      },
      {
        "text": "Za patchowanie hiperwizora",
        "inline_explanation": "(to warstwa infrastruktury, zarządza nią dostawca)",
        "correct": false
      }
    ],
    "explanation": "Podział ról w IaaS: \n ⚫ **Operator:** Daje prąd, budynek, sprzęt i wirtualizację. \n ⚫ **Klient:** Bierze wirtualną maszynę i odpowiada za wszystko od poziomu systemu operacyjnego w górę (aplikacje, dane, antywirus, firewall systemowy)."
  },
  {
    "id": 135,
    "question": "Dlaczego należy ograniczać dostęp do metadanych maszyny wirtualnej (Instance Metadata Service) w chmurze?",
    "options": [
      {
        "text": "Ponieważ zużywa to zbyt dużo transferu sieciowego",
        "inline_explanation": "(metadane to znikome ilości tekstu, nie ma to wpływu na koszt)",
        "correct": false
      },
      {
        "text": "Aby zapobiec kradzieży tymczasowych poświadczeń (kluczy IAM) w przypadku ataku SSRF",
        "inline_explanation": "(Server-Side Request Forgery pozwala atakującemu \"poprosić\" serwer o wyświetlenie jego własnych haseł)",
        "correct": true
      },
      {
        "text": "Ponieważ metadane są publicznie dostępne w Internecie",
        "inline_explanation": "(są dostępne tylko z wnętrza maszyny pod adresem link-local 169.254.169.254)",
        "correct": false
      },
      {
        "text": "Jest to niemożliwe, metadane muszą być zawsze otwarte dla wszystkich procesów",
        "inline_explanation": "(można i trzeba to ograniczać, np. wymuszając IMDSv2 z tokenami sesji)",
        "correct": false
      },
      {
        "text": "Ponieważ spowalnia to uruchamianie systemu",
        "inline_explanation": "(nie ma wpływu na boot time)",
        "correct": false
      }
    ],
    "explanation": "Usługa metadanych (pod adresem `169.254.169.254`) to \"dowód tożsamości\" maszyny w chmurze. Często zawiera klucze dostępowe do innych usług (np. S3). \n  \n Jeśli aplikacja ma lukę **SSRF**, haker może zmusić ją do odczytania tych kluczy i przejęcia kontroli nad chmurą. Dlatego dostęp ten trzeba zabezpieczać (np. tokenami)."
  },
  {
    "id": 136,
    "question": "Który z poniższych mechanizmów w środowisku zwirtualizowanym służy przede wszystkim do zapewnienia ciągłości działania (Business Continuity) w przypadku awarii sprzętowej?",
    "options": [
      {
        "text": "Szyfrowanie dysków wirtualnych",
        "inline_explanation": "(zapewnia poufność danych w spoczynku, ale nie chroni przed awarią)",
        "correct": false
      },
      {
        "text": "Replikacja danych do innej lokalizacji (np. Data Center zapasowego)",
        "inline_explanation": "(pozwala na szybkie uruchomienie systemów w zapasowej lokalizacji - Disaster Recovery)",
        "correct": true
      },
      {
        "text": "Publiczne udostępnianie katalogów bez hasła",
        "inline_explanation": "(to luka bezpieczeństwa, a nie mechanizm ochronny)",
        "correct": false
      },
      {
        "text": "Kompresja pamięci RAM",
        "inline_explanation": "(optymalizuje wydajność, ale nie chroni przed utratą danych)",
        "correct": false
      },
      {
        "text": "Izolacja procesów w kontenerach",
        "inline_explanation": "(zwiększa bezpieczeństwo aplikacji, ale awaria serwera nadal kładzie kontener)",
        "correct": false
      }
    ],
    "explanation": "Bezpieczeństwo to nie tylko ochrona przed hakerem, ale też przed awarią (Dostępność). \n  \n **Replikacja** kopiuje dane w czasie rzeczywistym lub cyklicznie do innej macierzy/ośrodka. W razie pożaru głównej serwerowni, systemy wstają w zapasowej."
  },
  {
    "id": 137,
    "question": "Uwierzytelnianie użytkowników w chmurze publicznej przy użyciu istniejących kont firmowych (np. Active Directory on-premise) jest możliwe dzięki:",
    "options": [
      {
        "text": "Wyłącznie ręcznemu kopiowaniu haseł do chmury",
        "inline_explanation": "(nieefektywne i niebezpieczne)",
        "correct": false
      },
      {
        "text": "Federacji tożsamości (Identity Federation) z użyciem protokołów takich jak SAML 2.0",
        "inline_explanation": "(umożliwia logowanie do chmury poświadczeniami z lokalnego AD - Single Sign-On)",
        "correct": true
      },
      {
        "text": "Użyciu wyłącznie kluczy API generowanych przez operatora",
        "inline_explanation": "(klucze API są dla aplikacji/skryptów, a nie dla ludzi logujących się do konsoli)",
        "correct": false
      },
      {
        "text": "Przekierowaniu portu 389 (LDAP) bezpośrednio do Internetu",
        "inline_explanation": "(bardzo niebezpieczna praktyka, naraża AD na ataki)",
        "correct": false
      },
      {
        "text": "Współdzieleniu jednego konta root przez wszystkich pracowników",
        "inline_explanation": "(karygodny błąd bezpieczeństwa)",
        "correct": false
      }
    ],
    "explanation": "Federacja tożsamości to standard w dużych firmach. \n  \n Zamiast tworzyć osobne konta w chmurze, łączymy chmurę (Service Provider) z naszym lokalnym katalogiem (Identity Provider). Użytkownik loguje się raz w firmie i ma dostęp do AWS/Azure/Google."
  },
  {
    "id": 138,
    "question": "W celu zapewnienia bezpiecznego, prywatnego i gwarantowanego połączenia między siecią firmową (On-Premise) a chmurą publiczną, z pominięciem publicznego Internetu, stosuje się:",
    "options": [
      {
        "text": "Zwykły tunel VPN Site-to-Site",
        "inline_explanation": "(działa przez publiczny Internet, więc nie gwarantuje przepustowości)",
        "correct": false
      },
      {
        "text": "Dedykowane łącza prywatne (np. AWS Direct Connect, Azure ExpressRoute)",
        "inline_explanation": "(fizyczny światłowód wpinany bezpośrednio do routerów dostawcy chmury)",
        "correct": true
      },
      {
        "text": "Publiczne adresy IP z otwartymi portami RDP/SSH",
        "inline_explanation": "(bardzo niebezpieczne i nie zapewnia prywatności transmisji)",
        "correct": false
      },
      {
        "text": "Sieć Tor",
        "inline_explanation": "(zapewnia anonimowość, ale jest wolna i nieprzewidywalna)",
        "correct": false
      },
      {
        "text": "Protokół FTP",
        "inline_explanation": "(służy do przesyłania plików, nie jest metodą łączenia sieci)",
        "correct": false
      }
    ],
    "explanation": "Dla małych firm VPN przez Internet wystarczy. Dla korporacji przesyłających terabajty danych, publiczny Internet jest zbyt wolny i niestabilny. Rozwiązaniem są dedykowane łącza (Direct Connect), które omijają Internet, zapewniając stałą przepustowość i mniejsze opóźnienia."
  },
  {
    "id": 139,
    "question": "Atak typu Blind SQL Injection (Time-based) polega na:",
    "options": [
      {
        "text": "Odczytaniu danych bezpośrednio z komunikatu błędu na stronie",
        "inline_explanation": "(to klasyczny Error-based SQLi)",
        "correct": false
      },
      {
        "text": "Wnioskowaniu o poprawności danych na podstawie czasu odpowiedzi serwera",
        "inline_explanation": "(atakujący wstrzykuje instrukcję `SLEEP(5)` i mierzy, czy strona ładuje się dłużej)",
        "correct": true
      },
      {
        "text": "Podmianie treści strony głównej (Defacement)",
        "inline_explanation": "(to skutek ataku, a nie mechanizm Blind SQLi)",
        "correct": false
      },
      {
        "text": "Przechwyceniu ciasteczek sesyjnych innych użytkowników",
        "inline_explanation": "(to domena XSS)",
        "correct": false
      },
      {
        "text": "Zgadnięciu hasła administratora metodą słownikową",
        "inline_explanation": "(to Brute Force)",
        "correct": false
      }
    ],
    "explanation": "W atakach \"Blind\" aplikacja nie zwraca żadnych danych ani błędów. Jest \"ślepa\". \n  \n Haker zadaje pytania w stylu: \"Jeśli pierwsza litera hasła to 'A', to czekaj 5 sekund\". Jeśli serwer \"zamyśli się\" na 5 sekund, haker wie, że trafił."
  },
  {
    "id": 140,
    "question": "Najskuteczniejszą metodą zapobiegania atakom SQL Injection po stronie kodu aplikacji jest:",
    "options": [
      {
        "text": "Szyfrowanie całej bazy danych",
        "inline_explanation": "(nie chroni przed wykonaniem wstrzykniętego polecenia, np. DROP TABLE)",
        "correct": false
      },
      {
        "text": "Stosowanie zapytań parametryzowanych (Prepared Statements)",
        "inline_explanation": "(silnik bazy oddziela kod SQL od danych; dane są traktowane zawsze jako tekst, nigdy jako komenda)",
        "correct": true
      },
      {
        "text": "Ukrywanie błędów PHP przed użytkownikiem",
        "inline_explanation": "(to utrudnia atak, ale go nie blokuje - patrz Blind SQLi)",
        "correct": false
      },
      {
        "text": "Blokowanie znaków specjalnych (np. apostrofów) za pomocą wyrażeń regularnych",
        "inline_explanation": "(trudne do idealnego zrobienia, łatwe do obejścia; tzw. czarna lista to słaba ochrona)",
        "correct": false
      },
      {
        "text": "Zmiana nazwy tabeli z 'users' na trudną do zgadnięcia",
        "inline_explanation": "(Security by Obscurity - nie działa, bo nazwy tabel można wyciągnąć z metadanych bazy)",
        "correct": false
      }
    ],
    "explanation": "Przykład w PHP (PDO): \n ❌ ŹLE: `$sql = \"SELECT * FROM users WHERE name = '\" . $name . \"'\";` \n ✅ DOBRZE: `$stmt = $pdo->prepare(\"SELECT * FROM users WHERE name = :name\"); $stmt->execute(['name' => $name]);` \n W wersji dobrej, nawet jak `$name` to `' OR '1'='1`, baza poszuka użytkownika o tak dziwnym imieniu, zamiast wykonać atak."
  },
  {
    "id": 141,
    "question": "Tzw. \"Zombie Cookie\" (lub Evercookie) to mechanizm śledzący, który:",
    "options": [
      {
        "text": "Jest zwykłym ciasteczkiem sesyjnym",
        "inline_explanation": "(nie, sesyjne znikają po zamknięciu przeglądarki)",
        "correct": false
      },
      {
        "text": "Potrafi odtworzyć się po usunięciu standardowych ciasteczek przez użytkownika",
        "inline_explanation": "(ukrywa swoje kopie w różnych magazynach przeglądarki: LocalStorage, Flash, ETag, IndexedDB)",
        "correct": true
      },
      {
        "text": "Służy do poprawy bezpieczeństwa logowania w bankowości",
        "inline_explanation": "(nie, jest uznawany za naruszenie prywatności i malware)",
        "correct": false
      },
      {
        "text": "Jest wysyłany tylko przez połączenia HTTPS",
        "inline_explanation": "(to Secure Cookie)",
        "correct": false
      },
      {
        "text": "Wygasa automatycznie po 30 minutach",
        "inline_explanation": "(celem Zombie Cookie jest przetrwanie latami)",
        "correct": false
      }
    ],
    "explanation": "Zombie Cookie to uporczywy element śledzący. Działa jak wirus: jeśli usuniesz plik cookies, skrypt na stronie sprawdzi, czy dane są w LocalStorage lub cache'u obrazka (ETag). Jeśli znajdzie kopię, natychmiast odtwarza usunięte ciasteczko, \"ożywiając\" je jak zombie."
  }
]