[
  {
    "id": 1,
    "question": "Powłoka (ang. shell) w systemie UNIX jest odpowiedzialna za...",
    "options": [
      {
        "text": "wykonywanie niektórych wbudowanych podstawowych komend (komendy nie wbudowane są wywoływane przez powłokę jako programy zewnętrzne)",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "bezpośrednie zarządzanie przydziałem czasu procesora dla uruchomionych procesów",
        "inline_explanation": "(to zadanie planisty/schedulera w jądrze)",
        "correct": false
      },
      {
        "text": "tylko i wyłącznie wyświetlanie graficznego interfejsu użytkownika",
        "inline_explanation": "(shell to przede wszystkim CLI, choć może uruchamiać GUI)",
        "correct": false
      },
      {
        "text": "kompilację kodu źródłowego jądra w czasie rzeczywistym przed każdym uruchomieniem komendy",
        "inline_explanation": "(shell jest interpreterem, a nie kompilatorem; jądro jest już skompilowanym kodem binarnym)",
        "correct": false
      },
      {
        "text": "obsługę przekierowań strumieni wejścia/wyjścia oraz mechanizmu potoków (łączenie programów znakiem |)",
        "inline_explanation": "(to jedna z kluczowych funkcji powłoki, pozwalająca na tworzenie złożonych poleceń)",
        "correct": true
      },
      {
        "text": "uruchamianie programów",
        "inline_explanation": "(to Shell jest odpowiedzialny za znalezienie programu na dysku i zlecenie jego uruchomienia)",
        "correct": true
      },
      {
        "text": "obsługę skryptów",
        "inline_explanation": "(możliwość automatyzacji zadań - język skryptowy powłoki)",
        "correct": true
      },
      {
        "text": "zarządzanie pamięcią RAM i przydział czasu procesora",
        "inline_explanation": "(to zadanie Jądra/Schedulera)",
        "correct": false
      },
      {
        "text": "kompilacja kodu źródłowego",
        "inline_explanation": "(shell nie jest kompilatorem, on tylko może uruchomić kompilator, np. `gcc`)",
        "correct": false
      },
      {
        "text": "zarządzanie systemem plików na poziomie fizycznym",
        "inline_explanation": "(shell pozwala przeglądać pliki, ale to Jądro decyduje, jak są zapisywane na talerzach dysku)",
        "correct": false
      }
    ],
    "explanation": "Powłoka (shell) to program systemowy, który pełni rolę pośrednika między użytkownikiem a jądrem systemu operacyjnego (kernelem). Jest to interpreter poleceń. Kiedy wpisujesz komendę w terminalu, shell ją analizuje (parsowanie) i decyduje, jak ją wykonać. Kluczowym rozróżnieniem jest tutaj podział na komendy wbudowane (built-in, np. cd, echo), które shell wykonuje sam, oraz zewnętrzne (programy w /bin), które uruchamia. Dodatkowo shell zarządza środowiskiem pracy (zmienne środowiskowe), obsługuje historię poleceń oraz pozwala na sterowanie przepływem danych między procesami (potoki i przekierowania). Nie zajmuje się jednak bezpośrednim zarządzaniem sprzętem (np. czasem procesora), co jest wyłącznym zadaniem jądra."
  },
  {
    "id": 2,
    "question": "Przeciążenie (przeładowanie) operatorów w języku C++ pozwala...",
    "options": [
      {
        "text": "dodać do siebie obiekty dwóch różnych klas np. wektor i liczbę zespoloną",
        "inline_explanation": "(to kluczowa zaleta, pozwalająca na intuicyjne operacje matematyczne na własnych typach danych)",
        "correct": true
      },
      {
        "text": "zdefiniować własne zachowanie dla operatorów wejścia/wyjścia (<< i >>)",
        "inline_explanation": "(dzięki temu można wypisywać całe obiekty na ekran instrukcją cout << obiekt, zamiast tworzyć metody print)",
        "correct": true
      },
      {
        "text": "zmieniać priorytety wykonywania operatorów matematycznych",
        "inline_explanation": "(priorytety są ściśle zdefiniowane w gramatyce języka i są niezmienne dla wszystkich typów)",
        "correct": false
      },
      {
        "text": "tworzyć zupełnie nowe symbole operatorów, które nie istnieją w języku (np. ** dla potęgowania)",
        "inline_explanation": "(można przeciążać tylko te operatory, które już istnieją w składni C++, np. +, -, *, /)",
        "correct": false
      },
      {
        "text": "zmieniać liczarność argumentów operatora (np. sprawić, by operator jednoargumentowy ! przyjmował dwa argumenty)",
        "inline_explanation": "(arność operatora jest stała - operator jednoargumentowy zawsze musi działać na jednym argumencie)",
        "correct": false
      },
      {
        "text": "nadać nowe znaczenie operatorom w zależności od typów argumentów, na których działają",
        "inline_explanation": "()",
        "correct": true
      },
      {
        "text": "zwiększyć czytelność kodu poprzez użycie standardowej notacji matematycznej dla obiektów",
        "inline_explanation": "()",
        "correct": true
      }
    ],
    "explanation": "Przeciążanie operatorów (operator overloading) to mechanizm polimorfizmu statycznego, który pozwala nadać nowe znaczenie standardowym operatorom (np. +, -, <<) w odniesieniu do typów zdefiniowanych przez użytkownika. Głównym celem jest zwiększenie czytelności kodu (np. dodawanie macierzy znakiem + zamiast funkcją addMatrix). Istnieją jednak sztywne ograniczenia: nie można zmieniać priorytetów operatorów, ich łączności (lewo/prawostronnej), liczby argumentów (arności) ani tworzyć nowych symboli (jak ** czy <->). Nie można też zmieniać działania operatorów dla typów wbudowanych (np. nie można zmienić znaczenia 2 + 2)."
  },
  {
    "id": 3,
    "question": "Wymień zasoby, które w systemach UNIXowych mogą mieć pełną reprezentację w postaci pliku (np. w wirtualnym systemie plików /proc albo /dev).",
    "options": [
      {
        "text": "partycja dyskowa, pamięć RAM, karta sieciowa (NIC), parametry uruchomionych procesów",
        "inline_explanation": "(wszystkie te zasoby są mapowane na pliki w katalogach /dev, /proc lub /sys)",
        "correct": true
      },
      {
        "text": "wyłącznie pliki tekstowe i binarne zapisane na fizycznym dysku twardym",
        "inline_explanation": "(taka definicja jest błędna, bo w Unixie plikami są również urządzenia, potoki i gniazda)",
        "correct": false
      },
      {
        "text": "rejestry procesora dostępne bezpośrednio jako pliki do edycji w notatniku",
        "inline_explanation": "(rejestry to wewnętrzne komórki CPU o ogromnej szybkości; system nie udostępnia ich jako plików w /dev)",
        "correct": false
      },
      {
        "text": "tylko urządzenia peryferyjne podłączane przez USB, ale nie komponenty wewnętrzne jak RAM",
        "inline_explanation": "(pamięć RAM również jest dostępna jako plik, zazwyczaj pod ścieżką /dev/mem)",
        "correct": false
      },
      {
        "text": "terminal (TTY), generator liczb losowych, dysk twardy, informacje o modelu procesora",
        "inline_explanation": "(odpowiednio: /dev/tty, /dev/random, /dev/sda, /proc/cpuinfo)",
        "correct": true
      },
      {
        "text": "partycja dyskowa, pamięć RAM, pamięć podręczna procesora (L1 Cache), rejestry sterujące",
        "inline_explanation": "(cache L1 i rejestry sterujące są zarządzane sprzętowo i nie są widoczne jako pliki w systemie plików)",
        "correct": false
      }
    ],
    "explanation": "Filozofia systemów UNIX brzmi: \"Wszystko jest plikiem\" (Everything is a file). Oznacza to, że system operacyjny udostępnia jednolity interfejs plikowy (open, read, write, close) do obsługi sprzętu i danych systemowych. Katalog /dev zawiera pliki urządzeń (np. /dev/sda dla dysku, /dev/mem dla RAM, /dev/tty dla terminala, /dev/random dla entropii). Katalog /proc to wirtualny system plików mapujący stan jądra (np. /proc/cpuinfo) i procesów. Nie wszystko jednak jest plikiem - wyjątkiem są m.in. niskopoziomowe zasoby CPU jak rejestry czy pamięć cache L1/L2, do których dostęp ma tylko procesor/kernel."
  },
  {
    "id": 4,
    "question": "Wskaż instrukcje sterujące w języku C/C++.",
    "options": [
      {
        "text": "`if( ... ){ ... }`",
        "inline_explanation": "(podstawowa instrukcja warunkowa)",
        "correct": true
      },
      {
        "text": "`switch( ... ) { ... }`",
        "inline_explanation": "(instrukcja wyboru wielowariantowego)",
        "correct": true
      },
      {
        "text": "`for(int i=0; i<n; i++) { ... }`",
        "inline_explanation": "(pętla - instrukcja iteracyjna)",
        "correct": true
      },
      {
        "text": "`return 0;`",
        "inline_explanation": "(instrukcja skoku - powrót z funkcji)",
        "correct": true
      },
      {
        "text": "`break;`",
        "inline_explanation": "(instrukcja skoku - przerwanie pętli lub switcha)",
        "correct": true
      },
      {
        "text": "`int a = 5;`",
        "inline_explanation": "(to jest deklaracja i inicjalizacja zmiennej)",
        "correct": false
      },
      {
        "text": "`#include <stdio.h>`",
        "inline_explanation": "(to dyrektywa preprocesora, przetwarzana przed właściwą kompilacją)",
        "correct": false
      },
      {
        "text": "`a + b;`",
        "inline_explanation": "(to wyrażenie arytmetyczne, a nie instrukcja sterująca przepływem)",
        "correct": false
      }
    ],
    "explanation": "Instrukcje sterujące (control flow statements) decydują o kolejności wykonywania poleceń w programie. Pozwalają na warunkowe wykonanie kodu lub jego powtarzanie.\nDo podstawowych instrukcji sterujących należą:\n⚫instrukcje warunkowe (`if`, `if...else`, `switch`),\n⚫pętle (`for`, `while`, `do...while`),\n⚫instrukcje skoku (`break`, `continue`, `return`, `goto`).\nDeklaracje zmiennych (np. `int a`) i dyrektywy preprocesora (zaczynające się od `#`) nie sterują przepływem programu w czasie jego działania."
  },
  {
    "id": 5,
    "question": "Operator widoczności `protected` dla pola składowego klasy bazowej oznacza że:",
    "options": [
      {
        "text": "pole to jest niedostępne dla klasy bazowej ale widoczne w klasie pochodnej",
        "inline_explanation": "(klasa bazowa zawsze ma dostęp do własnych pól, niezależnie od modyfikatora)",
        "correct": false
      },
      {
        "text": "pole to jest dostępne dla metod klasy bazowej oraz metod klas pochodnych, ale niedostępne dla obiektów z zewnątrz",
        "inline_explanation": "(to jest dokładnie definicja modyfikatora protected w C++)",
        "correct": true
      },
      {
        "text": "pole to jest widoczne publicznie dla wszystkich funkcji w programie",
        "inline_explanation": "(to definicja `public`)",
        "correct": false
      },
      {
        "text": "pole to jest dostępne tylko i wyłącznie dla klasy bazowej",
        "inline_explanation": "(to definicja `private`)",
        "correct": false
      }
    ],
    "explanation": "Pola `protected` są widoczne w klasie, która je zdefiniowała (bazowej) ORAZ w klasach, które po niej dziedziczą (pochodnych). Są ukryte przed światem zewnętrznym (np. funkcją main). Twierdzenie, że klasa bazowa nie ma dostępu do własnego pola protected, jest fałszywe."
  },
  {
    "id": 6,
    "question": "Komunikatem w systemie UNIX (kolejki komunikatów System V) może być:",
    "options": [
      {
        "text": "dowolna struktura danych, przy czym pierwsza zmienna w strukturze musi być typu long",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "dowolny ciąg znaków (string) zakończony znakiem null",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "dowolna liczba całkowita typu int przesyłana przez potok",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "wskaźnik do pamięci współdzielonej, który musi być pierwszą zmienną",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "struktura zawierająca typ komunikatu oraz właściwe dane",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "sygnał systemowy",
        "inline_explanation": "(sygnał to nie to samo co \"Komunikat\" w sensie Message Queues. Sygnał to prosta liczba przerywająca działanie, nie przenosi złożonych danych)",
        "correct": false
      }
    ],
    "explanation": "W kolejkach komunikatów System V ({msgsnd}, {msgrcv}) komunikat jest strukturą. System operacyjny wymaga, aby pierwszym elementem tej struktury był {long mtype} (typ komunikatu), który służy do filtrowania wiadomości. Reszta struktury zależy od programisty."
  },
  {
    "id": 7,
    "question": "Operacja usunięcia segmentu pamięci współdzielonej:",
    "options": [
      {
        "text": "może być wykonana tylko przez proces posiadający odpowiednie prawa dostępu lub przez administratora",
        "inline_explanation": "(Wymagane uprawnienia właściciela, twórcy lub roota)",
        "correct": true
      },
      {
        "text": "następuje automatycznie w momencie, gdy ostatni proces odłączy się od segmentu",
        "inline_explanation": "(Nie w System V – tam segmenty są trwałe/persistent)",
        "correct": false
      },
      {
        "text": "może być wykonana przez dowolnego użytkownika systemu bez względu na uprawnienia",
        "inline_explanation": "(Fałsz, systemy uniksowe wymagają odpowiednich uprawnień do zasobów IPC)",
        "correct": false
      },
      {
        "text": "jest niemożliwa, pamięć współdzielona jest czyszczona tylko przy restarcie systemu",
        "inline_explanation": "(Fałsz, można użyć polecenia ipcrm lub funkcji shmctl)",
        "correct": false
      },
      {
        "text": "powoduje oznaczenie segmentu do usunięcia, ale fizyczne zwolnienie pamięci następuje dopiero po odłączeniu się od niego ostatniego procesu",
        "inline_explanation": "()",
        "correct": true
      },
      {
        "text": "wykonywana jest za pomocą funkcji `shmctl` z flagą `IPC_RMID`",
        "inline_explanation": "()",
        "correct": true
      },
      {
        "text": "wykonywana jest za pomocą funkcji `free` lub `delete`",
        "inline_explanation": "()",
        "correct": true
      }
    ],
    "explanation": "Pamięć współdzielona w standardzie System V jest zasobem trwałym (persistent) – nie znika sama po zakończeniu procesów. Musi zostać jawnie usunięta (np. poleceniem ipcrm lub funkcją shmctl). Może to zrobić tylko właściciel segmentu, twórca lub root."
  },
  {
    "id": 8,
    "question": "Ile interfejsów sieciowych można utworzyć na jednym interfejsie fizycznym?",
    "options": [
      {
        "text": "zależnie od użytej maski podsieci",
        "inline_explanation": "(maska określa wielkość sieci logicznej, a nie limit liczby interfejsów w systemie)",
        "correct": false
      },
      {
        "text": "wiele (teoretycznie liczba nieograniczona, w praktyce ograniczona zasobami systemu operacyjnego)",
        "inline_explanation": "(limitują nas tylko zasoby RAM/CPU i limity kernela/sterownika)",
        "correct": true
      },
      {
        "text": "dokładnie jeden wirtualny interfejs na jeden fizyczny",
        "inline_explanation": "(to fałsz; wirtualizacja sieci pozwala na setki interfejsów, np. w kontenerach)",
        "correct": false
      },
      {
        "text": "maksymalnie 4, zgodnie ze standardem Ethernet",
        "inline_explanation": "(standard Ethernet nie narzuca sztywnego limitu na liczbę interfejsów logicznych/wirtualnych)",
        "correct": false
      },
      {
        "text": "nawet kilka tysięcy, np. przy wykorzystaniu standardu VLAN (802.1Q) lub aliasów IP",
        "inline_explanation": "(każdy VLAN jest widoczny w systemie jako osobny interfejs, np. `eth0.10`, `eth0.20`)",
        "correct": true
      }
    ],
    "explanation": "W systemach operacyjnych (zwłaszcza Linux/Unix) jeden interfejs fizyczny (np. `eth0`) może być 'rodzicem' dla wielu interfejsów wirtualnych. Przykłady to: aliasy IP (`eth0:0`), interfejsy VLAN (`eth0.100`), interfejsy macvlan czy mostki (bridges). Maska podsieci określa, ile adresów IP mieści się w danej sieci, ale nie zabrania przypisania wielu różnych podsieci do tej samej karty sieciowej. Limit jest więc narzucany przez zasoby sprzętowe (RAM) i wydajność procesora, a nie przez sam standard sieciowy."
  },
  {
    "id": 9,
    "question": "Plik `/dev/zero` w systemie Unix jest plikiem:",
    "options": [
      {
        "text": "zwykłym (regular file)",
        "inline_explanation": "(pliki zwykłe, jak tekstowe czy binarne, przechowują trwałe dane na nośniku)",
        "correct": false
      },
      {
        "text": "specjalnym znakowym (character special file)",
        "inline_explanation": "(oferuje dostęp sekwencyjny do danych, bajt po bajcie; w `ls -l` oznaczony literą `c`)",
        "correct": true
      },
      {
        "text": "katalogiem (directory)",
        "inline_explanation": "(katalogi służą do organizowania struktury plików)",
        "correct": false
      },
      {
        "text": "specjalnym blokowym (block special file)",
        "inline_explanation": "(urządzenia blokowe, jak dyski twarde, operują na blokach danych i są buforowane)",
        "correct": false
      },
      {
        "text": "dowiązaniem symbolicznym (symbolic link)",
        "inline_explanation": "(choć w `/dev` jest wiele linków, `/dev/zero` jest zazwyczaj niezależnym węzłem urządzenia)",
        "correct": false
      },
      {
        "text": "dostarczającym nieskończony strumień bajtów zerowych",
        "inline_explanation": "()",
        "correct": true
      },
      {
        "text": "dostarczającym od razu sygnał `EOF`",
        "inline_explanation": "()",
        "correct": false
      }
    ],
    "explanation": "Katalog `/dev` zawiera pliki reprezentujące urządzenia. `/dev/zero` to **urządzenie znakowe** (character device). Jego zadaniem jest dostarczanie nieskończonego strumienia bajtów o wartości 0 (null bytes) podczas odczytu (używane np. do bezpiecznego wymazywania dysków poleceniem `dd` lub tworzenia pustych plików o zadanym rozmiarze). Odróżnia się je od urządzeń blokowych (jak dyski `/dev/sda`), które przechowują dane w blokach i pozwalają na swobodny dostęp (seeking)."
  },
  {
    "id": 10,
    "question": "Które z wymienionych systemów plików są systemami z dziennikiem (journalling filesystems):",
    "options": [
      {
        "text": "NTFS",
        "inline_explanation": "(standard w systemach Windows NT/10/11; posiada plik dziennika `$LogFile`)",
        "correct": true
      },
      {
        "text": "ext4",
        "inline_explanation": "(najpopularniejszy obecnie system plików w Linuxie, posiada domyślnie włączone księgowanie)",
        "correct": true
      },
      {
        "text": "XFS",
        "inline_explanation": "(wysokowydajny, 64-bitowy system plików z księgowaniem, domyślny np. w RHEL)",
        "correct": true
      },
      {
        "text": "JFS",
        "inline_explanation": "(stworzony przez IBM)",
        "correct": true
      },
      {
        "text": "APFS",
        "inline_explanation": "(Applowski, działa na zasadzie Copy-on-Write)",
        "correct": true
      },
      {
        "text": "ext3",
        "inline_explanation": "(następca ext2, który jako pierwszy w tej rodzinie wprowadził mechanizm journalingu)",
        "correct": true
      },
      {
        "text": "FAT32",
        "inline_explanation": "(prosty system plików z ery Windows 95/98, nie posiada dziennika i jest podatny na uszkodzenia)",
        "correct": false
      },
      {
        "text": "ext2",
        "inline_explanation": "(starszy standard Linuxa; brak dziennika wymusza długotrwałe sprawdzanie `fsck` po awarii)",
        "correct": false
      },
      {
        "text": "ext5",
        "inline_explanation": "(taki system plików nie istnieje; rozwój zatrzymał się na ext4, a nowsze to np. Btrfs czy ZFS)",
        "correct": false
      }
    ],
    "explanation": "Systemy plików z księgowaniem (journalling) zapisują metadane zmian w specjalnym wydzielonym obszarze (dzienniku) zanim zostaną one fizycznie zapisane w głównej strukturze danych. Pozwala to na błyskawiczne przywrócenie spójności systemu plików po nagłym zaniku zasilania (tzw. replay log). Do systemów z dziennikiem należą: **NTFS**, **ext3**, **ext4**, **XFS**, **JFS**, **ReiserFS**. Systemy starsze (**FAT32**, **ext2**) nie posiadają tej funkcji. Nazwa **ext5** jest zmyślona."
  },
  {
    "id": 11,
    "question": "Plik o nazwie `file` miał prawa dostępu: `rwsr-x-wx`. Wykonano polecenie: `chmod u=rx,g+ws,o=r file`. Jakie będą jego prawa dostępu?",
    "options": [
      {
        "text": "`rwsrw-rwx`",
        "inline_explanation": "(błędne; sugeruje, że bit SUID u właściciela został zachowany, a grupa nie otrzymała bitu `s`)",
        "correct": false
      },
      {
        "text": "`r-xrwsr--`",
        "inline_explanation": "(poprawny wynik: `u` nadpisane na `r-x` (bez s), `g` rozszerzone do `rws`, `o` przycięte do `r--`)",
        "correct": true
      },
      {
        "text": "`rwxrwxrwx`",
        "inline_explanation": "(to pełne uprawnienia 777, wynikające z niezrozumienia operatorów `=` i `+`)",
        "correct": false
      },
      {
        "text": "`r--r--r--`",
        "inline_explanation": "(to uprawnienia 444, brakuje praw wykonania i bitów specjalnych)",
        "correct": false
      },
      {
        "text": "`r-xr-xr--`",
        "inline_explanation": "(błędne; brakuje dodanego zapisu `w` oraz bitu SGID `s` dla grupy)",
        "correct": false
      }
    ],
    "explanation": "Analiza polecenia krok po kroku:\n1. **Stan początkowy:** `rwsr-x-wx` (User: `rws` [SUID], Group: `r-x`, Other: `wx`).\n2. `u=rx`: Operator `=` ustawia uprawnienia na sztywno. Właściciel otrzymuje `r-x`. Bit SUID znika, bo nie został wymieniony przy przypisaniu. Wynik częściowy: `r-x`.\n3. `g+ws`: Operator `+` dodaje do istniejących (`r-x`). Dodajemy `w` (zapis) -> `rwx`. Dodajemy `s` (SGID) -> `rws`. Wynik częściowy: `rws`.\n4. `o=r`: Ustawia dla reszty świata tylko odczyt. Wynik częściowy: `r--`.\n**Wynik końcowy:** `r-xrwsr--`."
  },
  {
    "id": 12,
    "question": "Utworzenie dowiązania (linku) twardego do pliku powoduje:",
    "options": [
      {
        "text": "utworzenie nowego węzła (tzw. i-nodu) pod tą samą nazwą",
        "inline_explanation": "(link twardy nie tworzy nowego inode'a, lecz wskazuje na już istniejący)",
        "correct": false
      },
      {
        "text": "utworzenie w katalogu nowej nazwy wskazującej na ten sam i-węzeł, co plik oryginalny",
        "inline_explanation": "(obie nazwy są równoważne, a licznik dowiązań w i-węźle zwiększa się o 1)",
        "correct": true
      },
      {
        "text": "zwiększenie licznika linków o 1",
        "inline_explanation": "(obie nazwy są równoważne, a licznik dowiązań w i-węźle zwiększa się o 1)",
        "correct": true
      },
      {
        "text": "skopiowanie zawartości pliku do nowej lokalizacji na dysku",
        "inline_explanation": "(to działanie polecenia `cp`; hard link nie zajmuje dodatkowego miejsca na dane)",
        "correct": false
      },
      {
        "text": "stworzenie specjalnego pliku tekstowego zawierającego ścieżkę do oryginału",
        "inline_explanation": "(to definicja linku symbolicznego - soft link)",
        "correct": false
      },
      {
        "text": "utworzenie skrótu, który może działać między różnymi systemami plików (partycjami)",
        "inline_explanation": "(linki twarde nie mogą przekraczać granic partycji, ponieważ numery inode są unikalne tylko w obrębie jednego systemu plików)",
        "correct": false
      }
    ],
    "explanation": "W systemie plików typu UNIX plik jest identyfikowany przez numer i-węzła (inode). Nazwa pliku to tylko wpis w katalogu wskazujący na ten numer. **Link twardy** (hard link, tworzony przez `ln`) to po prostu kolejna nazwa (wpis katalogowy) wskazująca na ten sam, fizyczny i-węzeł. Usunięcie jednej nazwy nie usuwa danych, dopóki licznik dowiązań (link count) nie spadnie do zera. Z kolei **Link symboliczny** (`ln -s`) to osobny mały plik (nowy inode), którego zawartością jest ścieżka tekstowa do pliku docelowego."
  },
  {
    "id": 13,
    "question": "Jaka jest różnica między kolejkami FIFO i łączami komunikacyjnymi w systemie UNIX?",
    "options": [
      {
        "text": "tylko kolejki FIFO mają zdefiniowaną nazwę (wpis w systemie plików)",
        "inline_explanation": "(zwykłe łącza `pipe` są anonimowe i istnieją tylko w pamięci jądra jako para deskryptorów)",
        "correct": true
      },
      {
        "text": "łącza anonimowe mogą łączyć tylko procesy spokrewnione, a FIFO - dowolne procesy w systemie",
        "inline_explanation": "(ponieważ FIFO identyfikujemy po ścieżce do pliku, każdy proces z uprawnieniami może z niej skorzystać)",
        "correct": true
      },
      {
        "text": "łącza komunikacyjne (pipes) działają dwukierunkowo (full-duplex), a FIFO jednokierunkowo",
        "inline_explanation": "(w standardowym POSIX/UNIX oba mechanizmy są zazwyczaj jednokierunkowe; dane płyną w jedną stronę)",
        "correct": false
      },
      {
        "text": "kolejki FIFO przechowują przesyłane dane trwale na dysku twardym",
        "inline_explanation": "(nie, FIFO ma tylko *nazwę* na dysku; dane przelatują przez bufor w pamięci RAM i znikają po odczycie)",
        "correct": false
      },
      {
        "text": "łącza komunikacyjne mogą łączyć procesy uruchomione na różnych komputerach w sieci",
        "inline_explanation": "(nie, oba mechanizmy to IPC lokalne; do komunikacji sieciowej służą gniazda - `sockets`)",
        "correct": false
      }
    ],
    "explanation": "Podstawowa różnica dotyczy sposobu adresowania. Zwykłe łącza (tworzone funkcją `pipe()` lub znakiem `|` w shellu) są **anonimowe** i pozwalają na komunikację tylko procesów posiadających wspólnego przodka (dziedziczenie deskryptorów). Kolejki FIFO (tworzone poleceniem `mkfifo`) posiadają **nazwę** w systemie plików (np. `/tmp/my_fifo`), dzięki czemu mogą łączyć dwa zupełnie niezależne, niespokrewnione procesy działające w tym samym systemie operacyjnym."
  },
  {
    "id": 14,
    "question": "Zaznacz prawdziwe zdania:",
    "options": [
      {
        "text": "Heapsort jest zwykle szybszy niż Quicksort, jednak posiada gorszą pesymistyczną złożoność czasową",
        "inline_explanation": "(jest odwrotnie: Heapsort jest wolniejszy w praktyce, ale ma lepszą, bo gwarantowaną złożoność pesymistyczną)",
        "correct": false
      },
      {
        "text": "Quicksort jest zwykle szybszy w praktyce, ale ma gorszą złożoność pesymistyczną ($O(n^2)$) niż Heapsort ($O(n \\log n)$)",
        "inline_explanation": "(Złożoność pesymistyczna: Quicksort ($O(n^2)$), Heapsort ($O(n \\log n)$).\nQuicksort lepiej wykorzystuje pamięć podręczną CPU, ale zły dobór elementu osiowego (pivot) może go drastycznie spowolnić)",
        "correct": true
      },
      {
        "text": "Obydwa algorytmy mają identyczną złożoność pesymistyczną $O(n^2)$",
        "inline_explanation": "(Heapsort jest algorytmem o gwarantowanej złożoności $O(n \\log n)$ niezależnie od danych wejściowych)",
        "correct": false
      },
      {
        "text": "Heapsort jest algorytmem stabilnym",
        "inline_explanation": "(nie, operacje na kopcu zmieniają kolejność występowania elementów o tej samej wartości)",
        "correct": false
      },
      {
        "text": "Quicksort jest algorytmem typu \"dziel i rządź\" (divide and conquer), działającym w miejscu (in-place)",
        "inline_explanation": "(tak, dzieli tablicę na mniejsze partycje i nie wymaga dodatkowej tablicy pomocniczej o rozmiarze n, jak Mergesort)",
        "correct": true
      }
    ],
    "explanation": "Porównanie algorytmów: **Quicksort** jest w praktyce najszybszy dzięki świetnej lokalności odwołań (cache friendly), ale w najgorszym przypadku (np. posortowana tablica) jego złożoność spada do $O(n^2)$. **Heapsort** (przez kopcowanie) gwarantuje $O(n \\log n)$ w każdym przypadku, ale jest wolniejszy przez chaotyczne skoki po pamięci. Obydwa algorytmy są **niestabilne** (nie zachowują kolejności równych elementów). Algorytmem stabilnym o złożoności $O(n \\log n)$ jest np. Mergesort."
  },
  {
    "id": 15,
    "question": "Problem NP-trudny można rozwiązać w skończonym czasie:",
    "options": [
      {
        "text": "przekształcając go do znanego problemu NP-zupełnego",
        "inline_explanation": "(redukcja służy do udowodnienia trudności problemu, a nie do jego szybszego rozwiązania; problem wynikowy nadal pozostaje trudny obliczeniowo)",
        "correct": false
      },
      {
        "text": "stosując algorytm o złożoności wykładniczej (np. przegląd zupełny / brute force)",
        "inline_explanation": "(złożoność rzędu $O(2^n)$ lub $O(n!)$ jest ogromna, ale matematycznie skończona i gwarantuje poprawny wynik)",
        "correct": true
      },
      {
        "text": "stosując algorytm aproksymacyjny",
        "inline_explanation": "(często rezygnujemy z idealnej dokładności na rzecz akceptowalnego czasu obliczeń, uzyskując wynik \"wystarczająco dobry\")",
        "correct": true
      },
      {
        "text": "jest to niemożliwe, ponieważ problemy NP-trudne są nierozstrzygalne",
        "inline_explanation": "(fałsz; są one obliczalne, problemem jest jedynie czas potrzebny na wykonanie obliczeń, który rośnie lawinowo wraz z danymi)",
        "correct": false
      },
      {
        "text": "używając standardowego algorytmu o złożoności wielomianowej (zakładając $P \\neq NP$)",
        "inline_explanation": "(obecnie nie znamy algorytmów wielomianowych dla problemów NP-trudnych; ich odkrycie oznaczałoby, że $P=NP$)",
        "correct": false
      }
    ],
    "explanation": "Klasa problemów **NP-trudnych** obejmuje zadania, dla których nie znamy szybkich (wielomianowych) algorytmów rozwiązujących. Nie oznacza to jednak, że są nierozwiązywalne (jak np. Problem Stopu). Można je rozwiązać algorytmami dokładnymi o złożoności wykładniczej (np. sprawdzając wszystkie możliwości), co dla małych danych jest wykonalne. W praktyce inżynierskiej najczęściej stosuje się **algorytmy heurystyczne** i **aproksymacyjne**, które w skończonym czasie dają wynik zbliżony do optymalnego."
  },
  {
    "id": 16,
    "question": "Błąd względny:",
    "options": [
      {
        "text": "jest zawsze większy lub równy 1",
        "inline_explanation": "(błąd względny jest zazwyczaj małym ułamkiem, np. 0.05; wartość > 1 oznaczałaby, że błąd jest większy niż mierzona wielkość)",
        "correct": false
      },
      {
        "text": "jest wielkością bezwymiarową (nie posiada jednostki)",
        "inline_explanation": "(jednostki licznika i mianownika się skracają, np. $\\frac{[m]}{[m]}$)",
        "correct": true
      },
      {
        "text": "jest ilorazem błędu bezwzględnego i wartości dokładnej (lub zmierzonej)",
        "inline_explanation": "(wyraża się wzorem $\\delta = \\frac{\\Delta x}{x_0}$)",
        "correct": true
      },
      {
        "text": "posiada taką samą jednostkę jak mierzona wielkość",
        "inline_explanation": "(to cecha błędu bezwzględnego, który wyrażamy np. w metrach lub sekundach)",
        "correct": false
      },
      {
        "text": "przyjmuje wartości ujemne dla pomiarów zaniżonych",
        "inline_explanation": "(zwyczajowo błąd względny definiuje się przy użyciu wartości bezwzględnej, więc jest wielkością nieujemną)",
        "correct": false
      }
    ],
    "explanation": "Błąd względny (relative error) określa jakość pomiaru w odniesieniu do wielkości mierzonej. Wzór: $\\delta = \\frac{|x - x_0|}{|x_0|}$. Dzięki temu, że jest wielkością **bezwymiarową** (często wyrażaną w procentach), pozwala porównywać dokładność pomiarów różnych wielkości fizycznych (np. czy dokładniej zmierzyliśmy długość stołu, czy czas biegu)."
  },
  {
    "id": 17,
    "question": "Algorytm Dijkstry:",
    "options": [
      {
        "text": "rozwiązuje problem wyboru najkrótszej ścieżki w grafach z ujemnymi wagami",
        "inline_explanation": "(nie, algorytm ten jest zachłanny i nie potrafi cofnąć decyzji, co przy ujemnych wagach prowadzi do błędów; należy użyć algorytmu Bellmana-Forda)",
        "correct": false
      },
      {
        "text": "wymaga, aby wagi krawędzi w grafie były nieujemne",
        "inline_explanation": "(jest to warunek konieczny, aby zachłanna strategia wyboru wierzchołka o najmniejszym koszcie działała poprawnie)",
        "correct": true
      },
      {
        "text": "znajduje najkrótsze ścieżki z jednego źródła do wszystkich innych wierzchołków",
        "inline_explanation": "(jest to algorytm typu Single-Source Shortest Path)",
        "correct": true
      },
      {
        "text": "służy do znajdowania Minimalnego Drzewa Rozpinającego (MST)",
        "inline_explanation": "(do MST służą algorytmy Prima lub Kruskala; Dijkstra buduje drzewo najkrótszych ścieżek, które jest czymś innym)",
        "correct": false
      },
      {
        "text": "ma zawsze gorszą złożoność obliczeniową niż algorytm Bellmana-Forda",
        "inline_explanation": "(fałsz, Dijkstra na kopcach Fibonacciego jest znacznie szybszy: $O(E + V \\log V)$ vs Bellman-Ford: $O(V \\cdot E)$)",
        "correct": false
      }
    ],
    "explanation": "Algorytm Dijkstry to klasyczny algorytm grafowy służący do znajdowania najkrótszej ścieżki z jednego wierzchołka do wszystkich pozostałych. Jego kluczowym ograniczeniem jest wymóg **nieujemnych wag krawędzi**. Jeśli graf zawiera krawędzie o wagach ujemnych (np. w logistyce: zysk zamiast kosztu), należy zastosować wolniejszy, ale bardziej ogólny algorytm Bellmana-Forda."
  },
  {
    "id": 18,
    "question": "Zaznacz prawdziwe zdania odnoszące się do algorytmów.",
    "options": [
      {
        "text": "Operacje dominujące to takie, które mogą być pominięte podczas szacowania złożoności obliczeniowej",
        "inline_explanation": "(jest odwrotnie - to właśnie operacje dominujące decydują o rzędzie złożoności i to je zliczamy)",
        "correct": false
      },
      {
        "text": "Operacja dominująca to instrukcja, której liczba wykonań jest proporcjonalna do całkowitego czasu działania algorytmu (dla dużych n)",
        "inline_explanation": "(zazwyczaj jest to instrukcja w najbardziej zagnieżdżonej pętli)",
        "correct": true
      },
      {
        "text": "Szacując złożoność obliczeniową, pomijamy stałe współczynniki oraz wyrazy niższego rzędu",
        "inline_explanation": "(dlatego np. $2n^2 + 100n$ upraszczamy do notacji $O(n^2)$)",
        "correct": true
      },
      {
        "text": "Złożoność pesymistyczna opisuje najlepszy możliwy przypadek wykonania algorytmu",
        "inline_explanation": "(opisuje najgorszy przypadek - Worst Case; najlepszy przypadek to złożoność optymistyczna)",
        "correct": false
      },
      {
        "text": "Złożoność pamięciowa algorytmu jest zawsze równa jego złożoności czasowej",
        "inline_explanation": "(fałsz, np. Quicksort ma czas $O(n \\log n)$, ale pamięć $O(\\log n)$)",
        "correct": false
      }
    ],
    "explanation": "W asymptotycznej analizie złożoności (Notacja Duże O) interesuje nas tempo wzrostu czasu wykonania (lub zużycia pamięci) w funkcji rozmiaru danych wejściowych ($n$). Skupiamy się na **operacji dominującej** (wykonywanej najczęściej). Stałe (np. \"algorytm wykonuje 5 operacji na każdy element\") oraz składniki niższego rzędu są pomijane, ponieważ dla bardzo dużych $n$ przestają mieć znaczenie."
  },
  {
    "id": 19,
    "question": "Problemem NP-trudnym jest:",
    "options": [
      {
        "text": "problem minimalnego drzewa rozpinającego (MST)",
        "inline_explanation": "(klasa P - rozwiązywalny w czasie wielomianowym algorytmami Prima/Kruskala)",
        "correct": false
      },
      {
        "text": "problem komiwojażera (TSP - Traveling Salesman Problem)",
        "inline_explanation": "(klasyczny problem optymalizacyjny, dla którego nie znamy rozwiązania wielomianowego)",
        "correct": true
      },
      {
        "text": "problem plecakowy (Knapsack problem)",
        "inline_explanation": "(problem decyzyjny wyboru przedmiotów o największej wartości przy ograniczonej wadze)",
        "correct": true
      },
      {
        "text": "problem kolorowania grafu",
        "inline_explanation": "(Czy da się pokolorować mapę N kolorami tak, by sąsiedzi mieli inne kolory?)",
        "correct": true
      },
      {
        "text": "wyszukiwanie binarne w posortowanej tablicy",
        "inline_explanation": "(klasa P - problem bardzo łatwy, złożoność $O(\\log n)$)",
        "correct": false
      },
      {
        "text": "problem spełnialności formuł logicznych (SAT)",
        "inline_explanation": "(pierwszy problem udowodniony jako NP-zupełny - twierdzenie Cooka)",
        "correct": true
      },
      {
        "text": "sortowanie ciągu liczb",
        "inline_explanation": "(klasa P - np. MergeSort, HeapSort)",
        "correct": false
      }
    ],
    "explanation": "Problemy **NP-trudne** to takie, które są co najmniej tak trudne jak najtrudniejsze problemy w klasie NP. Nie znamy dla nich algorytmów wielomianowych (przy założeniu $P \\neq NP$). Przykłady: Problem Komiwojażera (odwiedzenie miast najkrótszą drogą), Problem Plecakowy (upakowanie plecaka) czy SAT. Problemy takie jak sortowanie, MST czy wyszukiwanie binarne należą do klasy **P** (Polynomial) i są łatwo rozwiązywalne przez współczesne komputery."
  },
  {
    "id": 20,
    "question": "Graf może być reprezentowany przez:",
    "options": [
      {
        "text": "macierz incydencji",
        "inline_explanation": "(relacja węzeł-krawędź; wiersze to wierzchołki, kolumny to krawędzie)",
        "correct": true
      },
      {
        "text": "listy sąsiedztwa",
        "inline_explanation": "(dla każdego wierzchołka przechowujemy listę jego sąsiadów; oszczędne dla grafów rzadkich $O(V+E)$)",
        "correct": true
      },
      {
        "text": "macierz sąsiedztwa",
        "inline_explanation": "(macierz kwadratowa $V \\times V$; szybka weryfikacja czy krawędź istnieje ($O(1)$), ale pamięciożerna $O(V^2)$)",
        "correct": true
      },
      {
        "text": "zwykłą kolejkę FIFO",
        "inline_explanation": "(kolejka to struktura pomocnicza używana np. w algorytmie BFS, ale sama w sobie nie definiuje topologii grafu)",
        "correct": false
      },
      {
        "text": "listę krawędzi (Edge List)",
        "inline_explanation": "(prosta tablica lub lista przechowująca pary połączonych wierzchołków)",
        "correct": true
      }
    ],
    "explanation": "Wybór reprezentacji grafu zależy od jego gęstości i wykonywanych operacji. **Macierz sąsiedztwa** jest idealna dla grafów gęstych (dużo krawędzi), pozwalając na błyskawiczne sprawdzenie połączenia. **Listy sąsiedztwa** są standardem dla grafów rzadkich (oszczędność pamięci). **Macierz incydencji** jest rzadziej stosowana, ale przydatna w hipergrafach lub obwodach elektrycznych."
  },
  {
    "id": 21,
    "question": "Jakie czynniki należy wziąć pod uwagę przy tworzeniu własnych struktur danych?",
    "options": [
      {
        "text": "które operacje będą operacjami częstymi, a jakie rzadkimi",
        "inline_explanation": "(kluczowe kryterium; np. tablica jest świetna do odczytu, a lista wiązana do wstawiania)",
        "correct": true
      },
      {
        "text": "ograniczenia pamięciowe i czasowe",
        "inline_explanation": "(analiza złożoności obliczeniowej kluczowych operacji w notacji Big O)",
        "correct": true
      },
      {
        "text": "wyłącznie estetykę kodu źródłowego",
        "inline_explanation": "(wygląd kodu jest wtórny wobec wydajności i poprawności struktury danych)",
        "correct": false
      },
      {
        "text": "dostępność bibliotek graficznych do wizualizacji",
        "inline_explanation": "(możliwość narysowania struktury nie wpływa na jej wydajność w systemie)",
        "correct": false
      },
      {
        "text": "łatwość implementacji i utrzymania",
        "inline_explanation": "(często prostsza struktura, np. `std::vector`, jest lepsza niż skomplikowane drzewo, jeśli zysk wydajności jest marginalny)",
        "correct": true
      }
    ],
    "explanation": "Projektowanie struktur danych to sztuka kompromisu (trade-off). Zawsze analizujemy: 1) **Profil operacji** (co robimy najczęściej?), 2) **Złożoność** (ile to potrwa?), 3) **Pamięć** (ile to zajmie?). Nie ma jednej idealnej struktury do wszystkiego."
  },
  {
    "id": 22,
    "question": "Algorytmem heurystycznym jest:",
    "options": [
      {
        "text": "algorytm Metropolisa",
        "inline_explanation": "(probabilistyczna metoda szukania minimum globalnego, inspirowana procesem krystalizacji metalu)",
        "correct": true
      },
      {
        "text": "A*",
        "inline_explanation": "(również probabilistyczna metoda szukania minimum globalnego, inspirowana procesem krystalizacji metalu)",
        "correct": true
      },
      {
        "text": "symulowane wyżarzanie",
        "inline_explanation": "(również probabilistyczna metoda szukania minimum globalnego, inspirowana procesem krystalizacji metalu)",
        "correct": true
      },
      {
        "text": "algorytm genetyczny",
        "inline_explanation": "(metoda ewolucyjna wykorzystująca selekcję, krzyżowanie i mutację)",
        "correct": true
      },
      {
        "text": "sortowanie bąbelkowe",
        "inline_explanation": "(to algorytm dokładny, deterministyczny o złożoności $O(n^2)$, a nie przybliżony)",
        "correct": false
      },
      {
        "text": "algorytm Dijkstry",
        "inline_explanation": "(to algorytm dokładny, zawsze znajduje optymalną najkrótszą ścieżkę)",
        "correct": false
      },
      {
        "text": "algorytm mrówkowy",
        "inline_explanation": "(heurystyka inspirowana zachowaniem mrówek zostawiających ślad feromonowy)",
        "correct": true
      }
    ],
    "explanation": "Algorytmy heurystyczne służą do znajdowania rozwiązań \"wystarczająco dobrych\" dla problemów trudnych obliczeniowo (np. NP-trudnych), gdzie przegląd wszystkich możliwości trwałby miliardy lat. Nie gwarantują one znalezienia najlepszego rozwiązania (optimum globalnego), ale znajdują dobre rozwiązanie w akceptowalnym czasie. Inne przykłady: Algorytm zachłanny, Tabu Search."
  },
  {
    "id": 23,
    "question": "Zaznacz prawdziwe zdania:",
    "options": [
      {
        "text": "Zrównoleglając algorytm w 50% programu na 4 procesorach uzyskamy minimum 2-krotne przyspieszenia działania",
        "inline_explanation": "(fałsz, maksymalne przyspieszenie w tym przypadku wyniesie 1.6x)",
        "correct": false
      },
      {
        "text": "Zrównoleglając algorytm w 50% na 4 procesorach uzyskamy przyspieszenie wynoszące 1.6 raza",
        "inline_explanation": "(wynika to ze wzoru: $S(4) = \\frac{1}{(1-0.5) + \\frac{0.5}{4}} = 1.6$)",
        "correct": true
      },
      {
        "text": "Maksymalne teoretyczne przyspieszenie programu zależy od jego sekwencyjnej części",
        "inline_explanation": "(gdy $N \\to \\infty$, przyspieszenie dąży do $\\frac{1}{1-P}$)",
        "correct": true
      },
      {
        "text": "Zwiększanie liczby procesorów liniowo zwiększa wydajność każdego programu",
        "inline_explanation": "(nie, ogranicza nas część sekwencyjna, której nie da się przyspieszyć dokładaniem rdzeni)",
        "correct": false
      },
      {
        "text": "Dla programu w 90% zrównoleglonego, maksymalne przyspieszenie na nieskończonej liczbie procesorów wynosi 10x",
        "inline_explanation": "(prawda: $\\frac{1}{1-0.9} = \\frac{1}{0.1} = 10$)",
        "correct": true
      }
    ],
    "explanation": "Skorzystajmy z **Prawa Amdahla**: $$S(N) = \\frac{1}{(1-P) + \\frac{P}{N}}$$ Gdzie $P$ to część zrównoleglona (50% = 0.5), a $N$ to liczba procesorów (4). \n $$ S(4) = \\frac{1}{(1-0.5) + \\frac{0.5}{4}} = \\frac{1}{0.5 + 0.125} = \\frac{1}{0.625} = 1.6 $$ \n Przyspieszenie wynosi **1.6 razy**. Nawet przy nieskończonej liczbie procesorów ($N \\to \\infty$), granica wynosi $\\frac{1}{0.5} = 2$. Czyli 2-krotne przyspieszenie to teoretyczne maksimum absolutne (nieosiągalne dla skończonej liczby 4 procesorów)."
  },
  {
    "id": 24,
    "question": "Z jakimi korzyściami wiąże się używanie wirtualnych środowisk?",
    "options": [
      {
        "text": "Zmniejszenie zużycia miejsca na dysku",
        "inline_explanation": "(wirtualizacja zazwyczaj zwiększa zużycie dysku przez duplikację plików systemowych gościa)",
        "correct": false
      },
      {
        "text": "Izolacja uruchamianych aplikacji i ich zależności od systemu gospodarza",
        "inline_explanation": "(kluczowa cecha bezpieczeństwa i stabilności - awaria w VM nie kładzie hosta)",
        "correct": true
      },
      {
        "text": "Łatwiejsze przenoszenie i wdrażanie aplikacji (portability)",
        "inline_explanation": "(obraz VM lub kontenera można uruchomić na dowolnym sprzęcie z kompatybilnym hiperwizorem)",
        "correct": true
      },
      {
        "text": "Zawsze wyższa wydajność niż uruchamianie natywne na sprzęcie",
        "inline_explanation": "(wirtualizacja zawsze wprowadza pewien narzut/overhead na emulację sprzętu lub translację rozkazów)",
        "correct": false
      },
      {
        "text": "Możliwość tworzenia migawek (snapshots) całego stanu systemu",
        "inline_explanation": "(pozwala na szybkie przywrócenie systemu po nieudanej aktualizacji)",
        "correct": true
      }
    ],
    "explanation": "Wirtualne środowiska (maszyny wirtualne, kontenery, venv) służą przede wszystkim **izolacji**. \n ⚫ **Zalety:** Separacja zależności (różne projekty mają różne biblioteki), łatwość przenoszenia, bezpieczeństwo (piaskownica), testowanie. \n ⚫ **Wady:** Zazwyczaj większe zużycie dysku (duplikacja bibliotek, obrazów systemu) i narzut wydajnościowy (rzędu od 1% do kilkunastu % w zależności od technologii)."
  },
  {
    "id": 25,
    "question": "Cechą charakterystyczną zwinnych metod tworzenia oprogramowania jest:",
    "options": [
      {
        "text": "Przeplatanie procesów specyfikacji, projektowania i implementacji (podejście iteracyjne)",
        "inline_explanation": "(zamiast robić to raz a dobrze, robimy to cyklicznie w każdym sprincie)",
        "correct": true
      },
      {
        "text": "Gotowość na zmiany wymagań w trakcie trwania projektu",
        "inline_explanation": "(reagowanie na zmiany ponad realizację założonego planu - manifest Agile)",
        "correct": true
      },
      {
        "text": "Szczegółowe zaplanowanie całego procesu i budżetu przed napisaniem pierwszej linijki kodu",
        "inline_explanation": "(to domena modelu kaskadowego / Waterfall, a nie Agile)",
        "correct": false
      },
      {
        "text": "Całkowity brak dokumentacji projektowej",
        "inline_explanation": "(Agile ceni działające oprogramowanie *ponad* dokumentację, ale jej nie eliminuje; niezbędne minimum jest tworzone)",
        "correct": false
      },
      {
        "text": "Ścisła współpraca z klientem (często włączenie go do zespołu projektowego)",
        "inline_explanation": "(klient widzi postępy na bieżąco i daje feedback po każdej iteracji)",
        "correct": true
      }
    ],
    "explanation": "Metodyki zwinne (Agile, np. Scrum, Kanban) przeciwstawiają się sztywnemu modelowi kaskadowemu (Waterfall). W Agile: \n ⚫ Pracuje się w krótkich iteracjach (sprintach). \n ⚫ Fazy (analiza, projekt, kodowanie, testy) **przeplatają się** w każdej iteracji, zamiast następować po sobie jednorazowo dla całego projektu. \n ⚫ Kluczowa jest adaptacja do zmian i ciągłe dostarczanie wartości biznesowej."
  },
  {
    "id": 26,
    "question": "Wskaż poprawne zdania dotyczące architektury oprogramowania:",
    "options": [
      {
        "text": "Nie istnieje związek pomiędzy architekturą, a wymaganiami systemu teleinformatycznego",
        "inline_explanation": "(jest odwrotnie - architektura jest odpowiedzią na wymagania, zwłaszcza te niefunkcjonalne)",
        "correct": false
      },
      {
        "text": "Architektura oprogramowania wynika w dużej mierze z wymagań niefunkcjonalnych (np. wydajności, bezpieczeństwa)",
        "inline_explanation": "(tzw. Quality Attributes determinują wybór technologii i wzorców, np. mikroserwisy dla skalowalności)",
        "correct": true
      },
      {
        "text": "Wzorce architektoniczne (np. MVC, Klient-Serwer) to sprawdzone rozwiązania typowych problemów projektowych",
        "inline_explanation": "(ułatwiają projektowanie, dostarczając gotowe szablony struktury aplikacji)",
        "correct": true
      },
      {
        "text": "Architektura dotyczy tylko wyglądu interfejsu użytkownika",
        "inline_explanation": "(nie, to domena UX/UI; architektura to struktura wewnętrzna: komponenty, bazy danych, komunikacja)",
        "correct": false
      },
      {
        "text": "Dobra architektura powinna być udokumentowana (np. diagramy UML, C4 model), aby ułatwić komunikację w zespole",
        "inline_explanation": "(dokumentacja architektoniczna jest kluczowa dla zrozumienia systemu przez nowych programistów)",
        "correct": true
      }
    ],
    "explanation": "Architektura oprogramowania to fundament systemu. Jest ona ściśle powiązana z wymaganiami, zwłaszcza wymaganiami niefunkcjonalnymi (Jakościowymi - ang. NFR: Non-Functional Requirements), takimi jak: wydajność, skalowalność, bezpieczeństwo, dostępność. Jeśli system ma być bezpieczny i skalowalny (wymagania), architektura musi to uwzględniać (np. przez load balancery, szyfrowanie, mikroserwisy). Podana odpowiedź (\"Nie istnieje związek...\") jest FAŁSZYWA. Związek jest kluczowy."
  },
  {
    "id": 27,
    "question": "Wskaż poprawne zdania dotyczące architektury systemu teleinformatycznego:",
    "options": [
      {
        "text": "Architektura systemu teleinformatycznego nie ma wpływu na jego bezpieczeństwo",
        "inline_explanation": "(ma fundamentalny wpływ; błędy architektoniczne są najtrudniejsze i najdroższe do naprawienia)",
        "correct": false
      },
      {
        "text": "Decyzje architektoniczne mają fundamentalny wpływ na poziom bezpieczeństwa systemu (np. poprzez izolację komponentów)",
        "inline_explanation": "(np. podział na strefy sieciowe, użycie DMZ, separacja uprawnień)",
        "correct": true
      },
      {
        "text": "Architektura powinna uwzględniać wymagania niefunkcjonalne, takie jak niezawodność, skalowalność i bezpieczeństwo",
        "inline_explanation": "(bez tego system może działać poprawnie funkcjonalnie, ale być niestabilny lub podatny na ataki)",
        "correct": true
      },
      {
        "text": "Architektura dotyczy tylko sprzętu, a nie oprogramowania",
        "inline_explanation": "(nie, architektura systemu to połączenie sprzętu, sieci i oprogramowania)",
        "correct": false
      },
      {
        "text": "Wybór modelu architektonicznego (np. monolit vs mikroserwisy) wpływa na łatwość wdrażania i skalowania systemu",
        "inline_explanation": "(mikroserwisy łatwiej skalować niezależnie, ale są trudniejsze w utrzymaniu)",
        "correct": true
      }
    ],
    "explanation": "Architektura systemu to fundamentalna organizacja systemu, obejmująca jego komponenty, relacje między nimi oraz zasady projektowania. Bezpieczeństwo systemu jest ściśle powiązane z architekturą (koncepcja Security by Design). Decyzje architektoniczne (np. separacja warstw, brak pojedynczych punktów awarii, minimalizacja powierzchni ataku) determinują odporność systemu. Źle zaprojektowana architektura może uniemożliwić skuteczne zabezpieczenie systemu w późniejszych fazach."
  },
  {
    "id": 28,
    "question": "Wskaż poprawne zdania dotyczące ewolucji oprogramowania:",
    "options": [
      {
        "text": "Ewolucja oprogramowania może zostać wymuszona przez zmianę wymagań po oddaniu finalnej wersji oprogramowania",
        "inline_explanation": "(zmienność biznesu wymusza ciągłe dostosowywanie oprogramowania)",
        "correct": true
      },
      {
        "text": "Koszty ewolucji i utrzymania oprogramowania często przekraczają koszty jego pierwotnego wytworzenia",
        "inline_explanation": "(reguła 60/60 lub nawet 80/20 - utrzymanie to większość kosztów w cyklu życia systemu)",
        "correct": true
      },
      {
        "text": "Ewolucja oprogramowania kończy się w momencie wdrożenia wersji 1.0 na produkcję",
        "inline_explanation": "(fałsz, wdrożenie to początek najdłuższej fazy cyklu życia - eksploatacji i pielęgnacji)",
        "correct": false
      },
      {
        "text": "Zmiany w oprogramowaniu po wdrożeniu wynikają wyłącznie z błędów programistów",
        "inline_explanation": "(nie, wynikają też z nowych funkcji, zmian prawnych, aktualizacji systemów operacyjnych)",
        "correct": false
      },
      {
        "text": "Refaktoryzacja to technika ułatwiająca ewolucję poprzez poprawę struktury kodu bez zmiany jego zachowania",
        "inline_explanation": "(czysty kod łatwiej modyfikować w przyszłości)",
        "correct": true
      }
    ],
    "explanation": "Ewolucja oprogramowania (często utożsamiana z utrzymaniem) to proces zmian zachodzących w oprogramowaniu po jego wdrożeniu. Zgodnie z prawami ewolucji oprogramowania (prawa Lehmana), program używany w rzeczywistym środowisku musi się zmieniać, w przeciwnym razie staje się coraz mniej użyteczny. Zmiany te są wymuszane przez:\n ⚫ Zmiany w wymaganiach biznesowych (nowe funkcje).\n ⚫ Zmiany w środowisku (nowy system operacyjny, sprzęt).\n ⚫ Konieczność naprawy błędów.\nPodane zdanie jest prawdziwe."
  },
  {
    "id": 29,
    "question": "Wskaż poprawne zdania dotyczące implementacji oprogramowania:",
    "options": [
      {
        "text": "Implementacja oprogramowania jest zawsze najdłuższym i najbardziej kosztownym etapem tworzenia oprogramowania",
        "inline_explanation": "(fałsz, zazwyczaj faza utrzymania trwa latami i kosztuje znacznie więcej)",
        "correct": false
      },
      {
        "text": "Faza utrzymania i ewolucji oprogramowania generuje zazwyczaj największe koszty w całkowitym cyklu życia systemu",
        "inline_explanation": "(szacuje się, że to nawet 60-80% całkowitego kosztu posiadania - TCO)",
        "correct": true
      },
      {
        "text": "Wytworzenie kodu (implementacja) jest tylko jednym z etapów procesu inżynierii oprogramowania",
        "inline_explanation": "(obok analizy, projektowania, testowania i wdrażania)",
        "correct": true
      },
      {
        "text": "Testowanie oprogramowania wykonuje się zawsze tylko po zakończeniu całej implementacji",
        "inline_explanation": "(w nowoczesnych podejściach, np. TDD/Agile, testy pisze się równolegle lub nawet przed kodem)",
        "correct": false
      },
      {
        "text": "Współczesna implementacja często obejmuje pisanie automatycznych testów jednostkowych (Unit Tests)",
        "inline_explanation": "(programista nie tylko pisze kod funkcjonalny, ale też kod weryfikujący jego poprawność)",
        "correct": true
      }
    ],
    "explanation": "W cyklu życia oprogramowania (SDLC), faza implementacji (kodowania) jest kluczowa, ale rzadko jest najdłuższa czy najdroższa.\n ⚫ **Najdroższa** jest zazwyczaj faza utrzymania (maintenance/ewolucja), trwająca przez cały okres życia produktu.\n ⚫ W nowoczesnych metodykach (Agile, DevOps) dużo czasu zajmują testy, projektowanie architektury i zbieranie wymagań, a sam kod powstaje iteracyjnie."
  },
  {
    "id": 30,
    "question": "Protokoły rutingu typu wektor odległości:",
    "options": [
      {
        "text": "przesyłają do swoich sąsiadów tylko listę podsieci, które są podłączone do nich bezpośrednio",
        "inline_explanation": "(nie, to opis bliższy protokołom Link State wysyłającym LSA; Distance Vector wysyła wszystko co wie)",
        "correct": false
      },
      {
        "text": "okresowo przesyłają całą swoją tablicę routingu do bezpośrednich sąsiadów",
        "inline_explanation": "(np. `RIP` wysyła pełną tablicę co 30 sekund, co generuje duży ruch w dużych sieciach)",
        "correct": true
      },
      {
        "text": "wykorzystują algorytm Bellmana-Forda do wyznaczania tras",
        "inline_explanation": "(obliczają najlepszą trasę na podstawie wektorów otrzymanych od sąsiadów)",
        "correct": true
      },
      {
        "text": "wykorzystują algorytm Dijkstry do wyznaczania tras",
        "inline_explanation": "(nope - Bellmana-Forda)",
        "correct": false
      },
      {
        "text": "posiadają pełną mapę topologii całej sieci",
        "inline_explanation": "(to cecha protokołów Stanu Łącza / Link State jak `OSPF`; DV zna tylko kierunek i odległość)",
        "correct": false
      },
      {
        "text": "są podatne na problem zliczania do nieskończoności (Count-to-Infinity) przy awarii łączy",
        "inline_explanation": "(dlatego stosuje się mechanizmy obronne jak Split Horizon czy Route Poisoning)",
        "correct": true
      },
      {
        "text": "RIP",
        "inline_explanation": "()",
        "correct": true
      },
      {
        "text": "IGRP",
        "inline_explanation": "()",
        "correct": true
      },
      {
        "text": "OSPF",
        "inline_explanation": "()",
        "correct": false
      },
      {
        "text": "IS-IS",
        "inline_explanation": "()",
        "correct": false
      }
    ],
    "explanation": "Protokoły wektora odległości (np. `RIP`, `IGRP`) działają na zasadzie \"plotkowania\" z sąsiadami. Cechy charakterystyczne:\n ⚫ Każdy router wysyła sąsiadom **całą swoją tablicę routingu** (wszystko co wie o sieci).\n ⚫ Działają okresowo (np. `RIP` co 30 sekund).\n ⚫ Router zna tylko kierunek (wektor) i odległość do celu, nie zna topologii całej sieci (nie ma mapy)."
  },
  {
    "id": 31,
    "question": "Pole Czas Życia (Time to live) w nagłówku protokołu IPv4:",
    "options": [
      {
        "text": "przeciwdziała skutkom wystąpienia pętli w sieci (zapobiega nieskończonemu krążeniu pakietów)",
        "inline_explanation": "(gdyby nie TTL, pakiet w pętli routingowej krążyłby w nieskończoność, zapychając łącze)",
        "correct": true
      },
      {
        "text": "jest zmniejszane o 1 przez każdy router na ścieżce przesyłu",
        "inline_explanation": "(router dekrementuje TTL przed przekazaniem pakietu dalej)",
        "correct": true
      },
      {
        "text": "określa dokładny czas w sekundach, po którym pakiet zostanie usunięty",
        "inline_explanation": "(współcześnie to liczba skoków; historycznie w RFC miały to być sekundy, ale routery przetwarzają pakiety szybciej)",
        "correct": false
      },
      {
        "text": "służy do priorytetyzacji ruchu w sieci",
        "inline_explanation": "(do tego służy pole ToS / DS Field)",
        "correct": false
      },
      {
        "text": "gdy osiągnie wartość 0, router odrzuca pakiet i wysyła komunikat `ICMP Time Exceeded`",
        "inline_explanation": "(na tym mechanizmie opiera się działanie narzędzia `traceroute`)",
        "correct": true
      },
      {
        "text": "określa maksymalną liczbę skoków, jakie pakiet może wykonać",
        "inline_explanation": "()",
        "correct": true
      }
    ],
    "explanation": "Pole TTL (8 bitów) służy do ograniczenia czasu przebywania pakietu w sieci. Każdy router, przez który przechodzi pakiet, zmniejsza wartość TTL o 1. Gdy TTL osiągnie 0, pakiet jest odrzucany, a do nadawcy wysyłany jest komunikat `ICMP Time Exceeded`. Zapobiega to nieskończonemu krążeniu pakietów w pętlach routingowych."
  },
  {
    "id": 32,
    "question": "Które zdania dotyczące programu traceroute są prawdziwe:",
    "options": [
      {
        "text": "wykorzystuje do działania usługę PING",
        "inline_explanation": "(nieprecyzyjne; `traceroute` to osobny program, a `ping` służy tylko do sprawdzenia dostępności, choć w Windows oba używają ICMP Echo)",
        "correct": false
      },
      {
        "text": "działa poprzez wysyłanie pakietów ze stopniowo zwiększaną wartością pola TTL",
        "inline_explanation": "(TTL=1 dla pierwszego routera, TTL=2 dla drugiego itd.)",
        "correct": true
      },
      {
        "text": "identyfikuje routery pośrednie na podstawie otrzymanych komunikatów ICMP 'Time Exceeded'",
        "inline_explanation": "(to właśnie adres źródłowy tego komunikatu jest adresem routera na ścieżce)",
        "correct": true
      },
      {
        "text": "pozwala zidentyfikować adresy IP routerów (węzłów) pośrednich na ścieżce do celu",
        "inline_explanation": "()",
        "correct": true
      },
      {
        "text": "służy do wykrywania pętli routingu lub miejsca awarii sieci",
        "inline_explanation": "(jeśli trasa urywa się na 5. routerze, wiesz, gdzie szukać problemu)",
        "correct": true
      },
      {
        "text": "służy do sprawdzania adresów MAC routerów pośrednich",
        "inline_explanation": "(traceroute działa w warstwie 3 [sieciowej]; adresy MAC [warstwa 2] są tracone przy każdym przeskoku przez router - widzisz tylko IP)",
        "correct": false
      },
      {
        "text": "zawsze wysyła pakiety na port 80 (HTTP)",
        "inline_explanation": "(w implementacji Linux/UDP używa wysokich portów >30000, które są prawdopodobnie zamknięte u celu)",
        "correct": false
      },
      {
        "text": "modyfikuje tablice routingu na routerach",
        "inline_explanation": "(to narzędzie pasywne diagnostycznie, nic nie zmienia w konfiguracji sieci)",
        "correct": false
      }
    ],
    "explanation": "Program `traceroute` (Windows: `tracert`) służy do śledzenia trasy pakietów. Mechanizm: wysyła pakiety z polem TTL=1, 2, 3... Routery po drodze odrzucają je (bo TTL wygasa) i odsyłają `ICMP Time Exceeded`. Program zbiera te odpowiedzi i wyświetla listę routerów.\n ⚫ Windows: używa `ICMP Echo Request`.\n ⚫ Linux: domyślnie używa pakietów UDP na losowe, wysokie porty."
  },
  {
    "id": 33,
    "question": "Który z poniższych protokołów routingu jest protokołem stanu łącza:",
    "options": [
      {
        "text": "EIGRP",
        "inline_explanation": "(Enhanced IGRP - nazywa się go protokołem hybrydowym, ale jest to zaawansowany Distance Vector, nie jest to czysty Link State [nie ma pełnej mapy topologii w takim sensie jak OSPF])",
        "correct": false
      },
      {
        "text": "RIPv1",
        "inline_explanation": "(klasyczny protokół wektora odległości - Distance Vector)",
        "correct": false
      },
      {
        "text": "OSPF",
        "inline_explanation": "(najpopularniejszy protokół Link State w sieciach korporacyjnych)",
        "correct": true
      },
      {
        "text": "IS-IS",
        "inline_explanation": "(protokół Link State używany głównie przez dostawców usług ISP)",
        "correct": true
      },
      {
        "text": "BGP",
        "inline_explanation": "(protokół wektora ścieżki - Path Vector, fundament Internetu)",
        "correct": false
      },
      {
        "text": "Routing statyczny",
        "inline_explanation": "(to nie jest protokół dynamiczny; trasy są wpisywane ręcznie przez administratora)",
        "correct": false
      }
    ],
    "explanation": "Protokoły routingu dzielimy na:\n ⚫ **Distance Vector (Wektor odległości):** `RIP`, `IGRP`. Routery wymieniają się informacją 'co widzą' (plotkowanie).\n ⚫ **Link State (Stan łącza):** `OSPF`, `IS-IS`. Routery budują pełną mapę sieci (graf) i liczą najkrótsze ścieżki algorytmem Dijkstry.\n ⚫ **Hybrydowe:** `EIGRP`."
  },
  {
    "id": 34,
    "question": "Do których sieci należą wszystkie następujące adresy IP: 192.168.1.200, 192.168.1.210, 192.168.1.220?",
    "options": [
      {
        "text": "192.168.1.192 /26",
        "inline_explanation": "(zakres użyteczny: .193 - .254; wszystkie adresy się mieszczą)",
        "correct": true
      },
      {
        "text": "192.168.1.0 /24",
        "inline_explanation": "(zakres użyteczny: .1 - .254; to standardowa sieć domowa, adresy się mieszczą)",
        "correct": true
      },
      {
        "text": "192.168.1.128 /26",
        "inline_explanation": "(zakres: .129 - .190; adresy są zbyt wysokie i wypadają poza tę podsieć)",
        "correct": false
      },
      {
        "text": "192.168.1.200 /28",
        "inline_explanation": "(zakres: .201 - .214; adres .220 się nie mieści, a .200 to adres sieci)",
        "correct": false
      },
      {
        "text": "192.168.0.0 /16",
        "inline_explanation": "(ogromna sieć obejmująca 192.168.0.0 - 192.168.255.255; adresy oczywiście się mieszczą)",
        "correct": true
      }
    ],
    "explanation": "Analiza dla **192.168.1.192 /26**:\n Maska /26 to `255.255.255.192`. Krok podsieci (block size) to 64. \n Podsieci: `.0`, `.64`, `.128`, **`.192`**. \n Zakres ostatniej podsieci: `192` (sieć) do `255` (broadcast). Adresy 200, 210, 220 mieszczą się w tym przedziale."
  },
  {
    "id": 35,
    "question": "Proszę wskazać zdania prawdziwe odnoszące się do protokołu DHCP:",
    "options": [
      {
        "text": "Serwer DHCP nasłuchuje zapytań na porcie 67 protokołu UDP",
        "inline_explanation": "(jest to port docelowy dla komunikatów wysyłanych przez klientów)",
        "correct": true
      },
      {
        "text": "Klient DHCP nasłuchuje odpowiedzi na porcie 68 protokołu UDP",
        "inline_explanation": "(na ten port serwer wysyła ofertę i potwierdzenie)",
        "correct": true
      },
      {
        "text": "DHCP wykorzystuje protokół TCP do gwarantowanego dostarczania adresów",
        "inline_explanation": "(nie, DHCP opiera się na `UDP` ze względu na szybkość i bezpołączeniowy charakter w fazie rozgłoszeniowej)",
        "correct": false
      },
      {
        "text": "Serwer DHCP przydziela adresy IP na stałe i nie mogą one ulec zmianie",
        "inline_explanation": "(adresy są dzierżawione na określony czas - Lease Time; po jego upływie klient musi odnowić dzierżawę)",
        "correct": false
      },
      {
        "text": "Służy do tłumaczenia nazw domenowych na adresy IP",
        "inline_explanation": "(to definicja DNS)",
        "correct": false
      },
      {
        "text": "Służy do zamiany adresów IP na adresy fizyczne MAC",
        "inline_explanation": "(to definicja ARP)",
        "correct": false
      },
      {
        "text": "Typowa komunikacja przebiega w 4 krokach: Discover, Offer, Request, Acknowledge (DORA)",
        "inline_explanation": "(Klient szuka serwera, Serwer oferuje IP, Klient prosi o ten IP, Serwer potwierdza)",
        "correct": true
      }
    ],
    "explanation": "DHCP (Dynamic Host Configuration Protocol) służy do automatycznej konfiguracji ustawień sieciowych (IP, Maska, Brama, DNS). Działa w oparciu o protokół **UDP**. \n ⚫ **Serwer DHCP:** Nasłuchuje na porcie `UDP 67`. \n ⚫ **Klient DHCP:** Nasłuchuje (odbiera odpowiedzi) na porcie `UDP 68`. \nProces uzyskiwania adresu to tzw. DORA: DHCPDiscover (broadcast), DHCPOffer, DHCPRequest, DHCPAck."
  },
  {
    "id": 36,
    "question": "Które z następujących stwierdzeń dotyczących protokołu IPv4 są prawdziwe:",
    "options": [
      {
        "text": "jest protokołem bezpołączeniowym (connectionless)",
        "inline_explanation": "(nie wymaga nawiązania sesji/handshake'u przed wysyłką danych; każdy pakiet idzie niezależnie)",
        "correct": true
      },
      {
        "text": "działa w modelu \"best effort\"",
        "inline_explanation": "(nie gwarantuje dostarczenia danych, ich kolejności ani braku duplikatów)",
        "correct": true
      },
      {
        "text": "zapewnia bezbłędną i uporządkowaną transmisję danych",
        "inline_explanation": "(to rola protokołu warstwy transportowej, np. `TCP`, a nie warstwy sieciowej IP)",
        "correct": false
      },
      {
        "text": "wykorzystuje adresy 32-bitowe",
        "inline_explanation": "()",
        "correct": true
      },
      {
        "text": "wykorzystuje adresy 128-bitowe",
        "inline_explanation": "(błąd: to jest IPv6)",
        "correct": false
      },
      {
        "text": "jest protokołem warstwy łącza danych (Layer 2)",
        "inline_explanation": "(nie, IP to protokół warstwy 3 - Sieci, służący do adresowania logicznego i routingu)",
        "correct": false
      },
      {
        "text": "nagłówek IPv4 zawiera sumę kontrolną obejmującą nagłówek i dane użytkownika (payload)",
        "inline_explanation": "(fałsz, `Header Checksum` w IPv4 chroni *tylko* nagłówek IP; poprawność danych weryfikują warstwy wyższe, np. TCP/UDP)",
        "correct": false
      },
      {
        "text": "gwarantuje kolejność dostarczania pakietów",
        "inline_explanation": "(fałsz, pakiety mogą iść różnymi trasami i dotrzeć \"pomieszane\")",
        "correct": false
      },
      {
        "text": "posiada wbudowane mechanizmy szyfrowania",
        "inline_explanation": "(w IPv4 `IPsec` jest opcjonalnym dodatkiem, dopiero w IPv6 był projektowany jako obowiązkowy element standardu)",
        "correct": false
      }
    ],
    "explanation": "Protokół IP (Internet Protocol) w wersji 4 jest protokołem warstwy sieciowej (Layer 3). Jego główne cechy to:\n ⚫ **Bezpołączeniowość:** Nie nawiązuje sesji przed wysłaniem danych.\n ⚫ **Best Effort:** Nie daje gwarancji dostarczenia (pakiety mogą ginąć).\n ⚫ **Adresowanie:** Używa 32-bitowych adresów zapisywanych dziesiętnie (np. `192.168.1.1`)."
  },
  {
    "id": 37,
    "question": "Proszę wskazać zdania prawdziwe odnoszące się do DNS:",
    "options": [
      {
        "text": "DNS dokonuje konwersji nazw domenowych na adresy IP (i odwrotnie)",
        "inline_explanation": "(tzw. Forward Lookup i Reverse Lookup)",
        "correct": true
      },
      {
        "text": "Jest to rozproszona, hierarchiczna baza danych",
        "inline_explanation": "(system składa się z tysięcy serwerów: Root, TLD, Authoritative; nie ma jednego centralnego komputera)",
        "correct": true
      },
      {
        "text": "Służy do dynamicznego przydzielania adresów IP komputerom w sieci",
        "inline_explanation": "(to zadanie protokołu `DHCP`; DNS to \"książka telefoniczna\", a nie \"urząd meldunkowy\")",
        "correct": false
      },
      {
        "text": "Działa wyłącznie w oparciu o protokół TCP",
        "inline_explanation": "(nie, standardowe zapytania używają `UDP` dla szybkości; `TCP` używane jest do transferu stref i dużych odpowiedzi)",
        "correct": false
      },
      {
        "text": "Rekord typu MX (Mail Exchange) w DNS wskazuje serwery pocztowe dla danej domeny",
        "inline_explanation": "(dzięki temu wysyłając e-mail na @firma.pl, serwer wie gdzie dostarczyć wiadomość)",
        "correct": true
      },
      {
        "text": "Wykorzystuje domyślnie port 53",
        "inline_explanation": "()",
        "correct": true
      }
    ],
    "explanation": "DNS (Domain Name System) to hierarchiczny system nazw. Jego głównym zadaniem jest tłumaczenie nazw zrozumiałych dla człowieka (np. `google.com`) na adresy IP (np. `142.250.1.1`). Działa na porcie **53**, wykorzystując głównie **UDP** do zapytań (dla zapytań < 512 bajtów) oraz **TCP** do transferu stref (Zone Transfer) lub gdy odpowiedź jest zbyt duża."
  },
  {
    "id": 38,
    "question": "Protokół DHCP pozwala (zaznacz prawdziwe):",
    "options": [
      {
        "text": "uzyskać adres MAC i adres IP w komputerze podłączonym do sieci",
        "inline_explanation": "(fałsz, adres MAC jest fizycznie przypisany do karty sieciowej przez producenta, DHCP go nie nadaje)",
        "correct": false
      },
      {
        "text": "automatycznie skonfigurować adres IP, maskę podsieci i bramę domyślną hosta",
        "inline_explanation": "(podstawowa funkcja protokołu)",
        "correct": true
      },
      {
        "text": "przekazać klientowi adresy serwerów DNS",
        "inline_explanation": "(zazwyczaj opcja DHCP nr 6)",
        "correct": true
      },
      {
        "text": "zamienić prywatny adres IP na publiczny",
        "inline_explanation": "(to zadanie mechanizmu `NAT` - Network Address Translation, a nie DHCP)",
        "correct": false
      },
      {
        "text": "wskazać klientowi adres serwera TFTP i nazwę pliku rozruchowego (dla PXE Boot)",
        "inline_explanation": "(opcje 66 i 67, umożliwiające uruchomienie systemu operacyjnego przez sieć)",
        "correct": true
      },
      {
        "text": "na powiązanie adresu IP z adresem MAC",
        "inline_explanation": "(tzw. rezerwacja statyczna - DHCP pozwala ustawić regułę: \"Jeśli przyjdzie komputer o MAC adresie X, to zawsze daj mu adres Y\")",
        "correct": true
      },
      {
        "text": "gwarantuje bezpieczeństwo przydzielania adresów",
        "inline_explanation": "(podstawowy DHCP nie ma uwierzytelniania - każdy może podpiąć \"lewy\" serwer DHCP do sieci i namieszać)",
        "correct": false
      }
    ],
    "explanation": "DHCP (Dynamic Host Configuration Protocol) konfiguruje parametry sieciowe hosta. Dostarcza: Adres IP, Maskę podsieci, Bramę domyślną, Adresy DNS, nazwę domeny itp.\n **Ważne:** Adres MAC (Media Access Control) jest fizycznym adresem karty sieciowej, nadanym przez producenta. Protokół DHCP **nie nadaje** adresu MAC. Wręcz przeciwnie - serwer DHCP zazwyczaj rozpoznaje klienta właśnie po jego unikalnym adresie MAC, aby przydzielić mu odpowiednie (lub zarezerwowane) IP."
  },
  {
    "id": 39,
    "question": "Podczas zapisu liczby wielobajtowej do pamięci komputera w procesorze o organizacji Big Endian:",
    "options": [
      {
        "text": "najbardziej znaczący bajt (MSB) umieszczony jest jako pierwszy (pod najniższym adresem)",
        "inline_explanation": "(zapis zgodny z naturalnym sposobem czytania liczb przez człowieka od lewej do prawej)",
        "correct": true
      },
      {
        "text": "najmniej znaczący bajt (LSB) umieszczony jest jako pierwszy",
        "inline_explanation": "(to definicja Little Endian, stosowanego np. przez procesory Intel/AMD)",
        "correct": false
      },
      {
        "text": "jest to format natywnie wykorzystywany przez procesory rodziny x86",
        "inline_explanation": "(nie, architektura x86 i x64 wykorzystuje Little Endian)",
        "correct": false
      },
      {
        "text": "kolejność bajtów nie ma znaczenia dla interpretacji liczby",
        "inline_explanation": "(ma kluczowe znaczenie; odwrócenie kolejności drastycznie zmienia wartość liczby)",
        "correct": false
      },
      {
        "text": "zgodnie z konwencją jest to tzw. sieciowa kolejność bajtów (Network Byte Order)",
        "inline_explanation": "(protokoły TCP/IP wymagają przesyłania danych w formacie Big Endian)",
        "correct": true
      }
    ],
    "explanation": "Kolejność bajtów (Endianness):\n ⚫ **Big Endian:** \"Duży koniec\" pierwszy. Najbardziej znaczący bajt (MSB - Most Significant Byte) jest zapisywany pod najniższym adresem pamięci. Jest to standard przyjęty w transmisji sieciowej (Network Byte Order) oraz w starszych procesorach (np. Motorola 68k, SPARC).\n ⚫ **Little Endian:** Najmniej znaczący bajt (LSB) jest pierwszy. Używane powszechnie przez procesory Intel/AMD (architektura x86)."
  },
  {
    "id": 40,
    "question": "Pamięć podręczna:",
    "options": [
      {
        "text": "jest pamięcią nieulotną",
        "inline_explanation": "(fałsz, cache traci dane po zaniku zasilania)",
        "correct": false
      },
      {
        "text": "jest pamięcią ulotną (traci zawartość po zaniku zasilania)",
        "inline_explanation": "(zbudowana jest zazwyczaj z komórek SRAM)",
        "correct": true
      },
      {
        "text": "służy do przyspieszenia dostępu do danych poprzez przechowywanie kopii często używanych danych z pamięci operacyjnej",
        "inline_explanation": "(minimalizuje opóźnienia w dostępie do wolniejszego RAM-u)",
        "correct": true
      },
      {
        "text": "posiada czas dostępu dłuższy niż pamięć RAM",
        "inline_explanation": "(jest wielokrotnie szybsza od pamięci RAM, dlatego znajduje się bliżej rdzenia CPU)",
        "correct": false
      },
      {
        "text": "działa w oparciu o zasady lokalności czasowej i przestrzennej",
        "inline_explanation": "(zakłada, że procesor będzie wkrótce potrzebował tych samych danych lub danych z nimi sąsiadujących)",
        "correct": true
      }
    ],
    "explanation": "Pamięć podręczna procesora (L1, L2, L3) jest zbudowana z bardzo szybkich tranzystorów (pamięć **SRAM** - Static RAM). Jest to pamięć **ulotna** (volatile) - jej zawartość ginie po odłączeniu zasilania, tak samo jak w przypadku głównej pamięci operacyjnej (DRAM). Pamięcią nieulotną jest np. dysk twardy, SSD lub pamięć Flash (ROM/BIOS). Cache działa dzięki zasadzie lokalności odwołań, przewidując, jakie dane będą potrzebne procesorowi."
  },
  {
    "id": 41,
    "question": "Przetwarzanie potokowe w procesorach rodziny x86:",
    "options": [
      {
        "text": "dzieli cykl przetwarzania instrukcji na odrębne etapy (np. `fetch`, `decode`, `execute`)",
        "inline_explanation": "(dzięki temu różne układy procesora pracują jednocześnie nad różnymi instrukcjami)",
        "correct": true
      },
      {
        "text": "pozwala na zwiększenie przepustowości procesora (throughput)",
        "inline_explanation": "(zwiększa się liczba instrukcji kończonych w jednostce czasu)",
        "correct": true
      },
      {
        "text": "sprawia, że czas wykonania pojedynczej instrukcji (latency) ulega skróceniu",
        "inline_explanation": "(fałsz, czas wykonania jednej instrukcji jest taki sam lub nawet dłuższy przez narzut sterowania potokiem)",
        "correct": false
      },
      {
        "text": "umożliwia wykonywanie tylko jednej instrukcji na raz w całym procesorze",
        "inline_explanation": "(to opis procesora sekwencyjnego bez potoku)",
        "correct": false
      },
      {
        "text": "wymaga mechanizmów przewidywania skoków (Branch Prediction) dla zachowania wydajności",
        "inline_explanation": "(błędne przewidzenie skoku wymusza opróżnienie całego potoku, co kosztuje wiele cykli zegara)",
        "correct": true
      }
    ],
    "explanation": "Przetwarzanie potokowe to technika analogiczna do linii montażowej w fabryce. Proces wykonywania instrukcji dzielony jest na etapy (np. Pobranie, Dekodowanie, Wykonanie, Zapis). W jednym cyklu zegara procesor może kończyć jedną instrukcję, mimo że jej pełne wykonanie trwa kilka cykli. Kluczowe jest rozróżnienie: potokowość zwiększa **przepustowość** (ile instrukcji zrobimy w sekundę), ale nie skraca czasu wykonania pojedynczej instrukcji."
  },
  {
    "id": 42,
    "question": "W jakim trybie procesor rodziny x86 rozpoczyna pracę?",
    "options": [
      {
        "text": "SMM (System Management Mode)",
        "inline_explanation": "(to tryb specjalny do zarządzania energią i sprzętem, niewidoczny dla OS)",
        "correct": false
      },
      {
        "text": "Tryb rzeczywisty (Real Mode)",
        "inline_explanation": "(tryb 16-bitowy zgodny z procesorem 8086, z dostępem do 1 MB pamięci)",
        "correct": true
      },
      {
        "text": "Tryb chroniony (Protected Mode)",
        "inline_explanation": "(tryb 32-bitowy z ochroną pamięci, do którego przełącza się bootloader/OS)",
        "correct": false
      },
      {
        "text": "Tryb wirtualny 8086 (Virtual 8086 Mode)",
        "inline_explanation": "(tryb emulacji starego procesora wewnątrz trybu chronionego)",
        "correct": false
      },
      {
        "text": "Tryb 64-bitowy (Long Mode)",
        "inline_explanation": "(nawet nowoczesne procesory i9/Ryzen startują w trybie 16-bitowym dla zachowania kompatybilności wstecznej)",
        "correct": false
      }
    ],
    "explanation": "Procesory z rodziny x86 (nawet najnowsze 64-bitowe) ze względu na kompatybilność wsteczną zawsze uruchamiają się w trybie **Rzeczywistym (Real Mode)**. W tym trybie zachowują się jak stary procesor 8086 (adresowanie 20-bitowe, brak ochrony pamięci). Dopiero system operacyjny (lub bootloader typu GRUB) programowo przełącza procesor w tryb Chroniony (Protected Mode), a następnie w tryb Long Mode (64-bit)."
  },
  {
    "id": 43,
    "question": "Do zmiany rozmiaru bufora odbiorczego UDP dla gniazda służy funkcja:",
    "options": [
      {
        "text": "`ioctl()`",
        "inline_explanation": "(służy głównie do sterowania urządzeniami wejścia/wyjścia, rzadziej do parametrów gniazd)",
        "correct": false
      },
      {
        "text": "`setsockopt()`",
        "inline_explanation": "(z parametrem `SO_RCVBUF` - standardowa funkcja POSIX do konfiguracji opcji gniazd)",
        "correct": true
      },
      {
        "text": "`bind()`",
        "inline_explanation": "(służy do przypisania adresu IP i portu do gniazda)",
        "correct": false
      },
      {
        "text": "`socket()`",
        "inline_explanation": "(służy do utworzenia nowego deskryptora gniazda)",
        "correct": false
      },
      {
        "text": "`fcntl()`",
        "inline_explanation": "(służy do manipulacji deskryptorami plików, np. ustawiania trybu non-blocking `O_NONBLOCK`)",
        "correct": false
      }
    ],
    "explanation": "W standardowym API gniazd (Berkeley Sockets) do ustawiania opcji gniazda służy funkcja `setsockopt()` (Set Socket Option). Aby zmienić rozmiar bufora odbiorczego, używa się poziomu `SOL_SOCKET` i opcji `SO_RCVBUF` (a dla nadawczego `SO_SNDBUF`). Odpowiednie ustawienie buforów jest kluczowe dla wydajności w sieciach o dużym iloczynie przepustowości i opóźnienia (BDP)."
  },
  {
    "id": 44,
    "question": "W modelu komunikacji \"klient-serwer\", funkcja `bind()` musi być wywołana w procesie:",
    "options": [
      {
        "text": "klienta",
        "inline_explanation": "(klient zazwyczaj korzysta z automatycznego przydziału portu przez system podczas `connect`)",
        "correct": false
      },
      {
        "text": "serwera",
        "inline_explanation": "(serwer musi \"związać się\" z konkretnym portem, np. 80, aby klienci wiedzieli, gdzie się łączyć)",
        "correct": true
      },
      {
        "text": "zarówno klienta jak i serwera",
        "inline_explanation": "(klient może użyć `bind`, ale nie jest to wymagane i zazwyczaj się tego unika)",
        "correct": false
      },
      {
        "text": "nie jest wymagana w żadnym z procesów",
        "inline_explanation": "(bez `bind` serwer otrzymałby losowy port i nikt by go nie znalazł)",
        "correct": false
      },
      {
        "text": "tylko jeśli używamy protokołu UDP, w TCP jest zbędna",
        "inline_explanation": "(fałsz, w TCP jest niezbędna na serwerze przed wywołaniem `listen`)",
        "correct": false
      }
    ],
    "explanation": "Funkcja `bind()` przypisuje gniazdu konkretny adres IP i numer portu lokalnego.\n  \n ⚫ **Serwer:** **MUSI** wywołać `bind()`, aby nasłuchiwać na znanym porcie (np. HTTP na 80), do którego będą łączyć się klienci.\n ⚫ **Klient:** Zazwyczaj **NIE** wywołuje `bind()`. System operacyjny automatycznie przydziela mu wolny port (tzw. port efemeryczny) w momencie wywołania funkcji `connect()` (TCP) lub pierwszego `sendto()` (UDP). Ręczne bindowanie klienta stosuje się rzadko (np. gdy wymagają tego reguły firewalla)."
  },
  {
    "id": 45,
    "question": "Zakres adresów rozsyłania grupowego dla protokołu IPv6 jest określony przez:",
    "options": [
      {
        "text": "pole TTL w nagłówku pakietu",
        "inline_explanation": "(w IPv6 pole to nazywa się `Hop Limit` i nie definiuje typu adresu)",
        "correct": false
      },
      {
        "text": "prefiks `ff00::/8`",
        "inline_explanation": "(pierwsze 8 bitów to same jedynki: `1111 1111` -> `FF`)",
        "correct": true
      },
      {
        "text": "prefiks `fe80::/10`",
        "inline_explanation": "(to adresy łącza lokalnego - Link-Local Unicast)",
        "correct": false
      },
      {
        "text": "ustawienie flagi M w nagłówku TCP",
        "inline_explanation": "(nagłówek warstwy 4 nie definiuje adresacji warstwy 3)",
        "correct": false
      },
      {
        "text": "prefiks `2000::/3`",
        "inline_explanation": "(to zakres adresów publicznych - Global Unicast)",
        "correct": false
      }
    ],
    "explanation": "W protokole IPv6 typ adresu rozpoznajemy po jego prefiksie (początkowych bitach). \n  \n Adresy **Multicast** (służące do wysyłania pakietów do grupy odbiorców) zawsze zaczynają się od oktetu `FF` (binarnie `1111 1111`). Zapis formalny to `ff00::/8`. Kolejne 4 bity to zazwyczaj flagi, a następne 4 to zakres (Scope, np. link-local, site-local, global)."
  },
  {
    "id": 46,
    "question": "Z czego wynikają interferencje międzysymbolowe w radiowych sieciach dostępowych?",
    "options": [
      {
        "text": "z niedoskonałości filtrów częstotliwości",
        "inline_explanation": "(jest to możliwe źródło ISI, ale w kontekście kanału radiowego dominującym czynnikiem jest otoczenie)",
        "correct": false
      },
      {
        "text": "z propagacji wielodrogowej sygnału",
        "inline_explanation": "(Multipath Propagation - odbicia sygnału od przeszkód powodują, że \"echa\" symbolu nakładają się na kolejny symbol)",
        "correct": true
      },
      {
        "text": "ze zbyt małej mocy nadajnika stacji bazowej",
        "inline_explanation": "(to wpływa na stosunek sygnału do szumu - SNR, a nie na ISI)",
        "correct": false
      },
      {
        "text": "z wykorzystania modulacji amplitudy zamiast częstotliwości",
        "inline_explanation": "(rodzaj modulacji analogowej nie jest bezpośrednią przyczyną zjawiska w transmisji cyfrowej)",
        "correct": false
      },
      {
        "text": "z efektu Dopplera",
        "inline_explanation": "(Doppler powoduje przesunięcie częstotliwości przy ruchu, a nie nakładanie się symboli w czasie)",
        "correct": false
      }
    ],
    "explanation": "W komunikacji radiowej (np. Wi-Fi, LTE) sygnał dociera do anteny odbiorczej różnymi drogami (odbicia od budynków, ziemi). \n  \n Powoduje to, że kopie tego samego sygnału docierają z różnym opóźnieniem. Jeśli opóźnienie (delay spread) jest duże, \"ogon\" (echo) poprzedniego symbolu $N-1$ nakłada się na początek aktualnie odbieranego symbolu $N$, zakłócając jego odczyt. Aby temu zapobiec, stosuje się np. **Cyclic Prefix** w modulacji OFDM."
  },
  {
    "id": 47,
    "question": "Jakie dodatkowe zjawiska, w porównaniu z łącznością radiową dla łączy stałych typu punkt-punkt, należy uwzględnić dla łączności mobilnej?",
    "options": [
      {
        "text": "efekt Dopplera",
        "inline_explanation": "(zmiana częstotliwości fali nośnej wynikająca z ruchu nadajnika lub odbiornika)",
        "correct": true
      },
      {
        "text": "szybkie zaniki sygnału (Fast Fading) oraz konieczność realizacji procedury handover",
        "inline_explanation": "(sygnał zmienia się dynamicznie co milisekundy; terminal musi płynnie przełączać się między stacjami)",
        "correct": true
      },
      {
        "text": "tłumienie sygnału w wolnej przestrzeni (Free Space Path Loss)",
        "inline_explanation": "(to zjawisko występuje w każdym typie łączności radiowej, również stacjonarnej)",
        "correct": false
      },
      {
        "text": "zjawisko załamania fal (refrakcja)",
        "inline_explanation": "(również występuje w obu typach łączności)",
        "correct": false
      },
      {
        "text": "zjawisko cienia (Shadowing)",
        "inline_explanation": "(nagły spadek mocy sygnału gdy użytkownik wejdzie za przeszkodę, np. budynek)",
        "correct": true
      }
    ],
    "explanation": "W łączności mobilnej (komórkowej) co najmniej jedna ze stron (terminal) się porusza. Ruch ten wprowadza specyficzne problemy:\n ⚫ **Efekt Dopplera:** Zmiana częstotliwości fali proporcjonalna do prędkości (istotne np. w szybkich pociągach).\n ⚫ **Fast Fading:** Gwałtowne zmiany siły sygnału na krótkich odcinkach.\n ⚫ **Handover:** Konieczność programowego przełączania aktywnej sesji między komórkami (BTS) bez zrywania połączenia."
  },
  {
    "id": 48,
    "question": "Minimalna wielkość ramki standardu Ethernet wynosi:",
    "options": [
      {
        "text": "48 bitów",
        "inline_explanation": "(to długość adresu MAC, a nie całej ramki)",
        "correct": false
      },
      {
        "text": "64 bajty",
        "inline_explanation": "(wynika to z wymogów mechanizmu wykrywania kolizji CSMA/CD)",
        "correct": true
      },
      {
        "text": "512 bitów",
        "inline_explanation": "(wynika to z wymogów mechanizmu wykrywania kolizji CSMA/CD)",
        "correct": true
      },
      {
        "text": "1500 bajtów",
        "inline_explanation": "(to typowe MTU - Maximum Transmission Unit, czyli max. ilość danych w ramce)",
        "correct": false
      },
      {
        "text": "1518 bajtów",
        "inline_explanation": "(to maksymalna całkowita wielkość ramki standardowej: 1500 danych + 18 nagłówka)",
        "correct": false
      },
      {
        "text": "9000 bajtów",
        "inline_explanation": "(to rozmiar tzw. Jumbo Frames, niestandardowego rozszerzenia dla gigabitowych sieci)",
        "correct": false
      }
    ],
    "explanation": "Aby mechanizm wykrywania kolizji (CSMA/CD) działał poprawnie w klasycznym Ethernecie, nadajnik musi nadawać ramkę przez czas wystarczający na dotarcie sygnału do najdalszego punktu sieci i powrót ewentualnego sygnału kolizji (Slot Time). Minimalna długość ramki została ustalona na **64 bajty** (512 bitów). Jeśli danych użytkownika jest mniej (np. 10 bajtów), sterownik karty sieciowej musi dopełnić ramkę zerami (padding) do 64 bajtów."
  },
  {
    "id": 49,
    "question": "Serwer DHCP przydziela adresy z sieci o adresie 192.168.0.0. Jaką najdłuższą maskę należy przypisać sieci, aby obsłużyć 512 hostów?",
    "options": [
      {
        "text": "255.255.255.128 (/25)",
        "inline_explanation": "(tylko 126 hostów; za mało)",
        "correct": false
      },
      {
        "text": "255.255.252.0 (/22)",
        "inline_explanation": "(1022 hosty; wystarczy i jest najbardziej dopasowana z poprawnych)",
        "correct": true
      },
      {
        "text": "255.255.254.0 (/23)",
        "inline_explanation": "(510 hostów; pułapka - brakuje dokładnie 2 adresów dla wymaganych 512 urządzeń)",
        "correct": false
      },
      {
        "text": "255.255.0.0 (/16)",
        "inline_explanation": "(65534 hosty; pomieści, ale pytanie wymagało \"najdłuższej możliwej maski\", czyli najmniejszej sieci spełniającej wymogi)",
        "correct": false
      },
      {
        "text": "/22 (zapis CIDR)",
        "inline_explanation": "(to samo co 255.255.252.0)",
        "correct": true
      }
    ],
    "explanation": "Potrzebujemy adresów dla **512 urządzeń**. Wzór na liczbę hostów: $2^h - 2$ (adres sieci i broadcastu).\n ⚫ Maska `/23` (9 bitów hosta): $2^9 - 2 = 512 - 2 = 510$ adresów użytecznych. (Za mało).\n ⚫ Maska `/22` (10 bitów hosta): $2^{10} - 2 = 1024 - 2 = 1022$ adresy użyteczne. (Wystarczy).\nNajdłuższa maska (czyli dająca najmniejszą podsieć), która pomieści 512 hostów to **/22** (255.255.252.0)."
  },
  {
    "id": 50,
    "question": "Protokół ARP (Address Resolution Protocol):",
    "options": [
      {
        "text": "jest stosowany w przypadku maszyn bezdyskowych do pobrania adresu IP",
        "inline_explanation": "(to opis protokołu `RARP` - Reverse ARP)",
        "correct": false
      },
      {
        "text": "służy do mapowania adresu IP na adres fizyczny MAC",
        "inline_explanation": "(kluczowa funkcja umożliwiająca komunikację w sieci Ethernet)",
        "correct": true
      },
      {
        "text": "działa w warstwie aplikacji modelu ISO/OSI",
        "inline_explanation": "(nie, ARP to protokół pomocniczy działający na styku warstwy 2 i 3)",
        "correct": false
      },
      {
        "text": "służy do routingu pakietów między różnymi sieciami WAN",
        "inline_explanation": "(ARP działa tylko w obrębie lokalnej domeny rozgłoszeniowej - LAN)",
        "correct": false
      },
      {
        "text": "wykorzystuje mechanizm Gratuitous ARP do wykrywania konfliktów adresów IP",
        "inline_explanation": "(urządzenie ogłasza swój adres, by sprawdzić, czy ktoś inny go nie używa)",
        "correct": true
      },
      {
        "text": "działa w obrębie jednej sieci lokalnej",
        "inline_explanation": "(ARP nie przechodzi przez routery na zewnątrz)",
        "correct": true
      },
      {
        "text": "wykorzystuje transmisję rozgłoszeniową (Broadcast) do wysyłania zapytań",
        "inline_explanation": "()",
        "correct": true
      },
      {
        "text": "służy do tłumaczenia adresów MAC na adresy IP",
        "inline_explanation": "(ARP działa w drugą stronę)",
        "correct": false
      }
    ],
    "explanation": "ARP służy do mapowania adresu logicznego (IP) na adres fizyczny (MAC). Gdy komputer chce wysłać pakiet do `192.168.1.5`, musi znać adres MAC karty sieciowej tego urządzenia. Wysyła więc zapytanie ARP Broadcast (\"Kto ma 192.168.1.5?\"). Właściwy komputer odpowiada swoim MAC-iem. Dla maszyn bezdyskowych (bootowanie) stosuje się odwrotny protokół: RARP (lub DHCP)."
  },
  {
    "id": 51,
    "question": "Jakie metody wielodostępu są wykorzystywane w sieci LTE?",
    "options": [
      {
        "text": "OFDMA",
        "inline_explanation": "(podział pasma na wiele ortogonalnych podnośnych, co niweluje problem interferencji międzysymbolowych)",
        "correct": true
      },
      {
        "text": "SC-FDMA",
        "inline_explanation": "(zmodyfikowana wersja OFDMA z mniejszym wskaźnikiem PAPR, co oszczędza baterię w telefonie)",
        "correct": true
      },
      {
        "text": "CSMA/CD",
        "inline_explanation": "(mechanizm wykrywania kolizji stosowany w sieciach Ethernet, a nie komórkowych)",
        "correct": false
      },
      {
        "text": "TDMA",
        "inline_explanation": "(główna metoda wielodostępu w sieciach 2G GSM)",
        "correct": false
      },
      {
        "text": "CDMA",
        "inline_explanation": "(technologia z rozpraszaniem widma, charakterystyczna dla sieci 3G UMTS)",
        "correct": false
      }
    ],
    "explanation": "Standard LTE (Long Term Evolution) wykorzystuje różne techniki dla łącza w dół i w górę: \n  \n ⚫ **Downlink (DL):** **OFDMA**. Zapewnia wysoką odporność na wielodrogowość. \n ⚫ **Uplink (UL):** **SC-FDMA** (Single Carrier FDMA). Został wybrany ze względu na mniejszy stosunek mocy szczytowej do średniej (PAPR - Peak-to-Average Power Ratio). Dzięki temu wzmacniacz w telefonie pracuje wydajniej i bateria wystarcza na dłużej."
  },
  {
    "id": 52,
    "question": "Przepływność bitowa strumienia danych dla usługi głosowej w systemie GSM zwiększa się przez:",
    "options": [
      {
        "text": "kodowanie źródłowe (Source Coding)",
        "inline_explanation": "(cel to kompresja mowy, np. kodek RPE-LTP; zmniejsza ilość danych)",
        "correct": false
      },
      {
        "text": "kodowanie kanałowe (Channel Coding)",
        "inline_explanation": "(dodanie nadmiarowości/bitów parzystości w celu korekcji błędów transmisji)",
        "correct": true
      },
      {
        "text": "zastosowanie modulacji wyższego rzędu",
        "inline_explanation": "(to pozwala przesłać więcej bitów w symbolu, ale nie zmienia rozmiaru samego strumienia danych przed modulacją)",
        "correct": false
      },
      {
        "text": "szyfrowanie algorytmem A5/1",
        "inline_explanation": "(szyfrowanie strumieniowe zazwyczaj zachowuje długość ciągu bitów)",
        "correct": false
      },
      {
        "text": "zastosowanie przeplotu (Interleaving)",
        "inline_explanation": "(zmienia kolejność bitów, aby uodpornić transmisję na błędy seryjne, ale nie dodaje nowych bitów)",
        "correct": false
      }
    ],
    "explanation": "W telekomunikacji proces przetwarzania mowy przebiega etapami: \n  \n 1. **Kodowanie źródłowe:** Kompresja (zmniejsza bitrate, np. do 13 kbit/s). \n 2. **Kodowanie kanałowe:** Ochrona przed błędami. Dodaje nadmiarowe bity (redundancję), co **zwiększa** całkowitą przepływność (w GSM z 13 kbit/s do 22.8 kbit/s). \n Pytanie dotyczy zwiększenia przepływności, więc poprawną odpowiedzią jest kodowanie kanałowe."
  },
  {
    "id": 53,
    "question": "Realna pojemność (przepustowość) komórki w systemie LTE zależy od:",
    "options": [
      {
        "text": "średniej efektywności widmowej realizowanych transmisji",
        "inline_explanation": "(zależy od warunków radiowych SINR, co pozwala na użycie gęstszej modulacji np. 64QAM)",
        "correct": true
      },
      {
        "text": "szerokości dostępnego pasma częstotliwości (Bandwidth)",
        "inline_explanation": "(np. kanał 20 MHz oferuje 2x większą przepływność niż 10 MHz)",
        "correct": true
      },
      {
        "text": "konfiguracji antenowej MIMO (Multiple Input Multiple Output)",
        "inline_explanation": "(wysyłanie wielu strumieni danych równolegle na tej samej częstotliwości)",
        "correct": true
      },
      {
        "text": "wyłącznie od odległości użytkownika od stacji bazowej",
        "inline_explanation": "(odległość wpływa na jakość sygnału, ale nie jest jedynym czynnikiem determinującym pojemność)",
        "correct": false
      },
      {
        "text": "częstotliwości nośnej (np. 800 MHz vs 2600 MHz)",
        "inline_explanation": "(częstotliwość wpływa na zasięg/tłumienie, ale 20 MHz pasma na 800 MHz daje teoretycznie taką samą pojemność jak 20 MHz na 2600 MHz)",
        "correct": false
      }
    ],
    "explanation": "Pojemność sieci komórkowej wynika z twierdzenia Shannona-Hartleya: $C = B \\cdot \\log_2(1 + \\frac{S}{N})$. \n  \n Kluczowe czynniki to: \n ⚫ **Szerokość pasma (B):** Im szerszy kanał, tym szybciej. \n ⚫ **MIMO:** Pozwala pomnożyć przepływność przez liczbę anten (przestrzenne multipleksowanie). \n ⚫ **Efektywność widmowa:** Zależna od jakości sygnału (SINR) i użytej modulacji."
  },
  {
    "id": 54,
    "question": "W systemie Unix/Linux, narzędziem służącym do konfiguracji interfejsu sieciowego jest:",
    "options": [
      {
        "text": "`ipconfig`",
        "inline_explanation": "(to standardowe polecenie w systemach rodziny Windows)",
        "correct": false
      },
      {
        "text": "`ifconfig`",
        "inline_explanation": "(klasyczne narzędzie z pakietu `net-tools`, obecnie często zastępowane przez `ip`)",
        "correct": true
      },
      {
        "text": "`ip`",
        "inline_explanation": "(nowoczesne narzędzie z pakietu `iproute2`, np. polecenie `ip addr show`)",
        "correct": true
      },
      {
        "text": "`winipcfg`",
        "inline_explanation": "(graficzne narzędzie z historycznych systemów Windows 95/98)",
        "correct": false
      },
      {
        "text": "`netstat`",
        "inline_explanation": "(służy do wyświetlania statystyk połączeń i otwartych portów, a nie do konfiguracji IP)",
        "correct": false
      }
    ],
    "explanation": "Należy rozróżnić narzędzia Windowsowe od Linuxowych. \n  \n ⚫ **Windows:** `ipconfig`. \n ⚫ **Linux (Legacy):** `ifconfig` (nadal powszechne, ale uznane za przestarzałe). \n ⚫ **Linux (Modern):** Polecenie `ip` (np. `ip link`, `ip addr`, `ip route`). Jest potężniejsze i obsługuje nowsze funkcje kernela."
  },
  {
    "id": 55,
    "question": "Ścieżka w MPLS jest:",
    "options": [
      {
        "text": "obiektem o losowo zmiennych parametrach",
        "inline_explanation": "(ścieżka jest deterministyczna, ustalona przez protokoły routingu lub inżynierię ruchu)",
        "correct": false
      },
      {
        "text": "jednokierunkowa (unidirectional)",
        "inline_explanation": "(to kluczowa cecha; ruch powrotny musi iść osobną ścieżką LSP)",
        "correct": true
      },
      {
        "text": "zawsze dwukierunkowa",
        "inline_explanation": "(aby uzyskać dwukierunkowość, routery muszą zestawić parę ścieżek LSP)",
        "correct": false
      },
      {
        "text": "zestawiana wyłącznie manualnie przez administratora",
        "inline_explanation": "(może być dynamiczna dzięki protokołom takim jak LDP czy RSVP-TE)",
        "correct": false
      },
      {
        "text": "ścieżką działającą w warstwie aplikacji (Layer 7)",
        "inline_explanation": "(MPLS działa między warstwą 2 a 3, stąd nazwa \"Layer 2.5\")",
        "correct": false
      }
    ],
    "explanation": "MPLS (Multiprotocol Label Switching) tworzy ścieżki zwane LSP. \n  \n Kluczową cechą LSP jest to, że jest ona **jednokierunkowa**. Routery na brzegu sieci (LER) nadają etykiety, a routery wewnątrz (LSR) przełączają pakiety wyłącznie na ich podstawie, bez zaglądania w nagłówek IP."
  },
  {
    "id": 56,
    "question": "Poprawiać skuteczność działania sieci neuronowej można zmieniając m.in.:",
    "options": [
      {
        "text": "Funkcje aktywacji, liczbę klastrów, typ optymalizatora",
        "inline_explanation": "(błąd: liczba klastrów to parametr algorytmów uczenia nienadzorowanego, np. K-means, a nie sieci neuronowych)",
        "correct": false
      },
      {
        "text": "Funkcje aktywacji, liczbę warstw ukrytych, współczynnik uczenia (learning rate)",
        "inline_explanation": "(to kluczowe hiperparametry wpływające na zdolność sieci do aproksymacji funkcji)",
        "correct": true
      },
      {
        "text": "Architekturę sieci, typ optymalizatora, rozmiar wsadu (batch size)",
        "inline_explanation": "(zmiana wielkości batcha wpływa na stabilność i szybkość zbieżności procesu uczenia)",
        "correct": true
      },
      {
        "text": "Jedynie kolor obudowy komputera na którym prowadzone są obliczenia",
        "inline_explanation": "(aspekt wizualny sprzętu nie ma wpływu na matematykę sieci)",
        "correct": false
      },
      {
        "text": "Współczynnik odrzucenia (Dropout rate) oraz techniki augmentacji danych",
        "inline_explanation": "(techniki te zapobiegają przeuczeniu się sieci - overfittingowi)",
        "correct": true
      }
    ],
    "explanation": "Aby \"dostroić\" sieć neuronową, manipulujemy hiperparametrami. \n  \n Do najważniejszych należą: \n ⚫ **Learning Rate:** Jak duże kroki robimy podczas optymalizacji. \n ⚫ **Architektura:** Liczba warstw i neuronów. \n ⚫ **Funkcje aktywacji:** np. ReLU, Sigmoid. \n Pojęcie \"liczby klastrów\" dotyczy analizy skupień (clustering), co jest inną dziedziną uczenia maszynowego."
  },
  {
    "id": 57,
    "question": "Które z poniższych poleceń SQL spowodują całkowite usunięcie tabeli `tblname` z bazy?",
    "options": [
      {
        "text": "`DELETE FROM tblname ;`",
        "inline_explanation": "(usuwa wszystkie wiersze, ale pusta tabela pozostaje w bazie)",
        "correct": false
      },
      {
        "text": "`DROP TABLE tblname ;`",
        "inline_explanation": "(usuwa trwale definicję tabeli oraz wszystkie zgromadzone w niej dane)",
        "correct": true
      },
      {
        "text": "`TRUNCATE TABLE tblname ;`",
        "inline_explanation": "(szybkie usunięcie wierszy poprzez zwolnienie stron pamięci, ale struktura tabeli zostaje)",
        "correct": false
      },
      {
        "text": "`ERASE tblname ;`",
        "inline_explanation": "(niepoprawna składnia w standardzie SQL)",
        "correct": false
      },
      {
        "text": "`REMOVE TABLE tblname ;`",
        "inline_explanation": "(błąd składniowy; słowo kluczowe `REMOVE` nie służy do usuwania tabel)",
        "correct": false
      }
    ],
    "explanation": "W SQL mamy rozróżnienie na usuwanie danych (DML) i struktur (DDL): \n ⚫ `DELETE` i `TRUNCATE` czyszczą zawartość, ale \"szkielet\" tabeli zostaje. \n ⚫ `DROP` to polecenie niszczące obiekt - usuwa tabelę całkowicie z systemu."
  },
  {
    "id": 58,
    "question": "Jeżeli polecenie `SELECT * FROM tblname WHERE ...` zwraca jeden wiersz, to (wg standardu SQL) kolejność zwróconych kolumn:",
    "options": [
      {
        "text": "pokrywa się z kolejnością definicji kolumn w poleceniu `CREATE TABLE`",
        "inline_explanation": "(silnik bazy zwraca kolumny w kolejności ich fizycznego/logicznego utworzenia w schemacie)",
        "correct": true
      },
      {
        "text": "jest losowa i zależy od aktualnego obciążenia serwera",
        "inline_explanation": "(kolejność kolumn jest deterministyczna, w przeciwieństwie do kolejności wierszy)",
        "correct": false
      },
      {
        "text": "jest zawsze alfabetyczna według nazw kolumn",
        "inline_explanation": "(nie, chyba że tabela została tak specyficznie utworzona)",
        "correct": false
      },
      {
        "text": "zależy od typów danych (najpierw liczbowe, potem tekstowe)",
        "inline_explanation": "(standard SQL nie grupuje kolumn typami przy wyświetlaniu)",
        "correct": false
      },
      {
        "text": "zależy od tego, która kolumna jest kluczem głównym (Primary Key)",
        "inline_explanation": "(klucz główny nie wymusza bycia pierwszą kolumną w wynikach, choć często jest tak definiowany)",
        "correct": false
      }
    ],
    "explanation": "Użycie gwiazdki (`*`) w zapytaniu `SELECT` oznacza pobranie wszystkich kolumn. Standard SQL określa, że kolumny zostaną zwrócone w kolejności, w jakiej zostały zdefiniowane w strukturze tabeli (czyli w kolejności z polecenia `CREATE TABLE`, chyba że użyto `ALTER TABLE` zmieniającego ten porządek w silniku)."
  },
  {
    "id": 59,
    "question": "W bazie istnieje tabela `osoby` z kolumną `imie`. Które z zapytań zostaną poprawne wykonane?",
    "options": [
      {
        "text": "`SELECT * FROM osoby p WHERE imie = 'Jan';`",
        "inline_explanation": "(poprawne; mimo aliasu `p`, kolumna `imie` jest jednoznaczna)",
        "correct": true
      },
      {
        "text": "`SELECT p.imie FROM osoby p WHERE p.imie = 'Jan';`",
        "inline_explanation": "(poprawne i zalecane; pełna kwalifikacja z użyciem zdefiniowanego aliasu)",
        "correct": true
      },
      {
        "text": "`SELECT * FROM osoby p WHERE osoby.imie = 'Jan';`",
        "inline_explanation": "(często błąd; w wielu dialektach SQL zdefiniowanie aliasu `p` ukrywa oryginalną nazwę `osoby`)",
        "correct": false
      },
      {
        "text": "`SELECT \"imie\" FROM osoby;`",
        "inline_explanation": "(ryzykowne; cudzysłowy oznaczają identyfikator wrażliwy na wielkość liter, co może nie zadziałać w zależności od bazy)",
        "correct": false
      },
      {
        "text": "`SELECT imie FROM osoby AS p WHERE p.imie = 'Jan';`",
        "inline_explanation": "(poprawne; słowo kluczowe `AS` jest opcjonalne, ale zwiększa czytelność)",
        "correct": true
      }
    ],
    "explanation": "Nadawanie aliasów (np. `FROM osoby p`) służy skróceniu zapisu. Warto pamiętać, że w większości silników SQL, gdy nadasz tabeli alias, powinieneś go używać. Odwoływanie się przez oryginalną nazwę tabeli (`osoby.imie`) w zapytaniu, które zdefiniowało alias (`osoby p`), często kończy się błędem \"Table not found\", ponieważ alias \"przykrywa\" oryginalną nazwę w zakresie tego zapytania."
  },
  {
    "id": 60,
    "question": "Które z poniższych stwierdzeń są poprawne?",
    "options": [
      {
        "text": "wyrażenie `40 + 60 + NULL` zwraca `100`",
        "inline_explanation": "(każda operacja arytmetyczna z NULL daje w wyniku NULL)",
        "correct": false
      },
      {
        "text": "wyrażenie `40 + 60 + NULL` zwraca `NULL`",
        "inline_explanation": "(NULL oznacza wartość nieznaną, więc wynik dodawania też jest nieznany)",
        "correct": true
      },
      {
        "text": "porównanie `NULL = NULL` zwraca `UNKNOWN` (lub fałsz)",
        "inline_explanation": "(do sprawdzania NULL używa się operatora `IS NULL`, a nie `=`)",
        "correct": true
      },
      {
        "text": "funkcja `count(*)` ignoruje wiersze z wartościami NULL",
        "inline_explanation": "(nie, `count(*)` liczy wszystkie wiersze; to `count(kolumna)` ignoruje NULL-e w tej kolumnie)",
        "correct": false
      },
      {
        "text": "porównanie `NULL != NULL` zwraca `TRUE`",
        "inline_explanation": "(nie, wynik każdego porównania z NULL to UNKNOWN/NULL)",
        "correct": false
      }
    ],
    "explanation": "W SQL obowiązuje **logika trójwartościowa** (3VL). \n  \n Wartość logiczna może być: Prawdą (`TRUE`), Fałszem (`FALSE`) lub Nieznaną (`UNKNOWN`). \n `NULL` oznacza brak danych. Operacja `NULL = NULL` nie jest prawdą, bo nie wiemy, czy jedna nieznana wartość jest równa drugiej. Dlatego wynik to `UNKNOWN` (w `WHERE` traktowany jak fałsz)."
  },
  {
    "id": 61,
    "question": "W zapytaniu: `SELECT imie, zarobki FROM osoby WHERE zarobki > (SELECT avg(zarobki) FROM osoby);`",
    "options": [
      {
        "text": "zastosowano podzapytanie proste (nieskorelowane)",
        "inline_explanation": "(podzapytanie wykonuje się raz, zwraca jedną wartość i nie zależy od zapytania głównego)",
        "correct": true
      },
      {
        "text": "zastosowano podzapytanie skorelowane (correlated subquery)",
        "inline_explanation": "(fałsz, podzapytanie nie odwołuje się do aliasu tabeli z zapytania zewnętrznego)",
        "correct": false
      },
      {
        "text": "zapytanie jest błędne, nie można używać funkcji agregujących w podzapytaniach",
        "inline_explanation": "(można, pod warunkiem że podzapytanie zwraca pojedynczą wartość - skalar, co tutaj zachodzi)",
        "correct": false
      },
      {
        "text": "zastosowano złączenie typu `OUTER JOIN`",
        "inline_explanation": "(brak słowa kluczowego JOIN; to jest filtrowanie w klauzuli WHERE)",
        "correct": false
      },
      {
        "text": "podzapytanie zwróci błąd, jeśli tabela `osoby` jest pusta",
        "inline_explanation": "(funkcja `AVG` na pustym zbiorze zwraca `NULL`, co sprawi, że porównanie `>` zwróci `UNKNOWN`, a wynik będzie po prostu pusty - bez błędu)",
        "correct": false
      }
    ],
    "explanation": "Mamy tu podzapytanie: `(SELECT avg(zarobki) FROM osoby)`. \n To podzapytanie: \n 1. Może zostać wykonane niezależnie od zapytania zewnętrznego. \n 2. Zwraca pojedynczą wartość (średnią pensję wszystkich osób). \n 3. Jest wykonywane tylko raz dla całego zapytania. \nJest to definicja **podzapytania prostego** (nieskorelowanego). Gdyby podzapytanie odwoływało się do wiersza z zapytania zewnętrznego (np. `WHERE oddzial = o.oddzial`), byłoby to podzapytanie skorelowane (wykonywane dla każdego wiersza)."
  },
  {
    "id": 62,
    "question": "Które deklaracje zmiennej w języku PL/SQL są poprawne?",
    "options": [
      {
        "text": "`ilosc int NOT NULL ;`",
        "inline_explanation": "(błąd: zmienna z ograniczeniem `NOT NULL` musi zostać zainicjalizowana od razu)",
        "correct": false
      },
      {
        "text": "`ilosc int NOT NULL := 0 ;`",
        "inline_explanation": "(poprawne: zadeklarowano typ, ograniczenie i wartość początkową)",
        "correct": true
      },
      {
        "text": "`ilosc int ;`",
        "inline_explanation": "(poprawne: zmienna otrzyma domyślną wartość `NULL`)",
        "correct": true
      },
      {
        "text": "`ilosc number(5) DEFAULT 10 ;`",
        "inline_explanation": "(poprawne: `DEFAULT` działa analogicznie do operatora przypisania `:=`)",
        "correct": true
      },
      {
        "text": "`ilosc int = 10 ;`",
        "inline_explanation": "(błąd składni: w PL/SQL do przypisania służy operator `:=`, a pojedyncze `=` służy do porównania)",
        "correct": false
      }
    ],
    "explanation": "PL/SQL (język proceduralny Oracle). Deklaracja: `ilosc int NOT NULL;` jest błędna. Jeśli nakładamy na zmienną ograniczenie `NOT NULL`, zmienna ta **musi** zostać zainicjalizowana w momencie deklaracji. Domyślnie zmienne otrzymują wartość `NULL`, co naruszyłoby ten warunek."
  },
  {
    "id": 63,
    "question": "Utworzenie indeksu do danej tabeli:",
    "options": [
      {
        "text": "zazwyczaj przyspiesza wszystkie operacje na bazie danych",
        "inline_explanation": "(mit; przyspiesza odczyt, ale spowalnia zapis)",
        "correct": false
      },
      {
        "text": "przyspiesza operacje odczytu (`SELECT`), ale spowalnia operacje modyfikacji (`INSERT`, `UPDATE`, `DELETE`)",
        "inline_explanation": "(baza musi aktualizować strukturę drzewa indeksu przy każdej zmianie danych)",
        "correct": true
      },
      {
        "text": "zwiększa zajętość przestrzeni dyskowej",
        "inline_explanation": "(indeks to dodatkowa struktura danych, która zajmuje miejsce na dysku)",
        "correct": true
      },
      {
        "text": "nie ma wpływu na wydajność bazy danych",
        "inline_explanation": "(ma kluczowy wpływ na wydajność zapytań)",
        "correct": false
      },
      {
        "text": "pozwala na szybsze sortowanie wyników (`ORDER BY`) po zaindeksowanej kolumnie",
        "inline_explanation": "(indeks przechowuje dane w sposób uporządkowany, więc silnik bazy nie musi ich sortować w locie)",
        "correct": true
      }
    ],
    "explanation": "Indeks w bazie danych  działa jak skorowidz w książce. \n ⚫ **Zaleta:** Znacznie przyspiesza operacje wyszukiwania (`SELECT ... WHERE`), sortowania i łączenia tabel. \n ⚫ **Wada:** Spowalnia operacje modyfikacji danych (`INSERT`, `UPDATE`, `DELETE`). \nDlaczego? Ponieważ przy każdym dodaniu lub usunięciu wiersza, baza danych musi nie tylko zaktualizować samą tabelę, ale też przebudować lub zbalansować strukturę indeksu."
  },
  {
    "id": 64,
    "question": "Przed którymi szkodliwymi efektami chroni tryb izolacji transakcji \"Read Committed\" (domyślny w PostgreSQL)?",
    "options": [
      {
        "text": "Dirty Read (Brudny odczyt)",
        "inline_explanation": "(gwarantuje, że czytamy tylko dane, które zostały już zatwierdzone przez inne transakcje)",
        "correct": true
      },
      {
        "text": "Non-repeatable Read (Niepowtarzalny odczyt)",
        "inline_explanation": "(przed tym chroni dopiero wyższy poziom: `Repeatable Read`)",
        "correct": false
      },
      {
        "text": "Phantom Read (Odczyt widmo)",
        "inline_explanation": "(przed tym chroni najwyższy poziom: `Serializable` lub snapshot isolation)",
        "correct": false
      },
      {
        "text": "Utrata danych w wyniku awarii zasilania",
        "inline_explanation": "(to zadanie dziennika transakcyjnego WAL/Redo Log, a nie poziomu izolacji)",
        "correct": false
      },
      {
        "text": "Lost Update (Utracona aktualizacja)",
        "inline_explanation": "(Read Committed zazwyczaj nie chroni przed nadpisaniem zmian, jeśli dwie transakcje edytują ten sam wiersz jednocześnie bez blokad)",
        "correct": false
      }
    ],
    "explanation": "Poziomy izolacji transakcji (wg standardu SQL)  chronią przed różnymi anomaliami: \n ⚫ **Dirty Read:** Czytanie danych, które inna transakcja zmieniła, ale jeszcze nie zatwierdziła (`COMMIT`). \n ⚫ **Non-repeatable Read:** W ramach jednej transakcji to samo zapytanie zwraca inne wartości, bo ktoś inny zmienił dane w międzyczasie. \n ⚫ **Phantom Read:** Pojawienie się nowych wierszy spełniających warunek zapytania. \n Tryb `Read Committed` gwarantuje tylko to pierwsze."
  },
  {
    "id": 65,
    "question": "Jaki znacznik HTML definiuje wewnętrzny arkusz styli CSS?",
    "options": [
      {
        "text": "`<style>`",
        "inline_explanation": "(umieszczany w sekcji `<head>`, zawiera reguły CSS dla bieżącego dokumentu)",
        "correct": true
      },
      {
        "text": "`<css>`",
        "inline_explanation": "(taki znacznik nie istnieje w specyfikacji HTML)",
        "correct": false
      },
      {
        "text": "`<script>`",
        "inline_explanation": "(służy do osadzania skryptów, głownie JavaScript)",
        "correct": false
      },
      {
        "text": "`<link>`",
        "inline_explanation": "(służy do dołączania **zewnętrznych** zasobów, np. plików .css)",
        "correct": false
      },
      {
        "text": "`@import`",
        "inline_explanation": "(to dyrektywa CSS używana wewnątrz arkusza stylów, a nie znacznik HTML)",
        "correct": false
      }
    ],
    "explanation": "Sposoby dołączania CSS do HTML: \n 1. **Zewnętrzny:** Znacznik `<link rel=\"stylesheet\" href=\"style.css\">` (najlepsza praktyka). \n 2. **Wewnętrzny:** Znacznik `<style> ... </style>` w sekcji head. \n 3. **Liniowy (Inline):** Atrybut `style=\"...\"` w konkretnym elemencie HTML (np. `<p style=\"color: red;\">`)."
  },
  {
    "id": 66,
    "question": "Jakie jest właściwe miejsce w dokumencie HTML na umiejscowienie odwołania do zewnętrznego arkusza styli?",
    "options": [
      {
        "text": "początek sekcji ciała dokumentu (`<body>`)",
        "inline_explanation": "(może powodować efekt FOUC - Flash of Unstyled Content)",
        "correct": false
      },
      {
        "text": "sekcja nagłówkowa dokumentu (`<head>`)",
        "inline_explanation": "(przeglądarka wczytuje style przed wyrenderowaniem treści strony)",
        "correct": true
      },
      {
        "text": "koniec sekcji body (przed `</body>`)",
        "inline_explanation": "(tam zazwyczaj umieszcza się skrypty JS dla wydajności, ale nie CSS)",
        "correct": false
      },
      {
        "text": "dowolne miejsce w dokumencie",
        "inline_explanation": "(choć przeglądarki mogą to obsłużyć, jest to niezgodne ze standardem i dobrą praktyką)",
        "correct": false
      },
      {
        "text": "wewnątrz znacznika `<style>` przy użyciu dyrektywy `@import`",
        "inline_explanation": "(to alternatywna, choć wolniejsza metoda dołączania stylów)",
        "correct": true
      }
    ],
    "explanation": "Zgodnie ze standardami W3C i dobrą praktyką, odwołania do arkuszy styli (znaczniki `<link>`) umieszcza się w sekcji nagłówkowej dokumentu, czyli wewnątrz `<head>`. Umieszczenie ich w `<body>` jest błędem, który może powodować **FOUC** (Flash of Unstyled Content) - użytkownik przez ułamek sekundy widzi \"gołą\" stronę bez stylów, zanim te się załadują."
  },
  {
    "id": 67,
    "question": "Skrypt napisany w języku JavaScript dołączany do struktury dokumentu HTML w postaci zewnętrznego pliku (np. `skrypt.js`):",
    "options": [
      {
        "text": "musi zawierać znaczniki `<script>` i `</script>`",
        "inline_explanation": "(nie, te znaczniki wpisuje się w pliku HTML, a nie w pliku .js)",
        "correct": false
      },
      {
        "text": "nie może zawierać znaczników HTML (powinien zawierać czysty kod JS)",
        "inline_explanation": "(interpreter JS zgłosiłby błąd składni widząc tagi HTML)",
        "correct": true
      },
      {
        "text": "musi zaczynać się od deklaracji `<!DOCTYPE html>`",
        "inline_explanation": "(to nagłówek dokumentu HTML, nie ma zastosowania w plikach skryptowych)",
        "correct": false
      },
      {
        "text": "jest dołączany za pomocą znacznika `<link>`",
        "inline_explanation": "(nie, znacznik `<link>` służy do CSS; do JS używa się `<script src=...>` )",
        "correct": false
      },
      {
        "text": "musi być zakodowany w formacie binarnym",
        "inline_explanation": "(pliki .js są plikami tekstowymi, zazwyczaj w kodowaniu UTF-8)",
        "correct": false
      }
    ],
    "explanation": "Zewnętrzny plik JavaScript (z rozszerzeniem `.js`) powinien zawierać **wyłącznie kod JavaScript**. Nie wpisuje się w nim znaczników HTML takich jak `<script>` czy `</script>`. Znaczniki te znajdują się w pliku HTML, który importuje ten skrypt (instrukcją `<script src=\"plik.js\"></script>`)."
  },
  {
    "id": 68,
    "question": "Format zapisu wykorzystywany w maszynach wirtualnych to:",
    "options": [
      {
        "text": "OVF",
        "inline_explanation": "(otwarty standard XML opisujący konfigurację maszyny wirtualnej)",
        "correct": true
      },
      {
        "text": "VMDK",
        "inline_explanation": "(format dysku wirtualnego stworzony przez firmę VMware)",
        "correct": true
      },
      {
        "text": "VHD / VHDX",
        "inline_explanation": "(format dysku wirtualnego używany przez Microsoft Hyper-V)",
        "correct": true
      },
      {
        "text": "JPEG",
        "inline_explanation": "(to format kompresji obrazów)",
        "correct": false
      },
      {
        "text": "OVA",
        "inline_explanation": "(pojedynczy plik archiwum zawierający deskryptor OVF i pliki dysków)",
        "correct": true
      },
      {
        "text": "ISO",
        "inline_explanation": "(to o obraz płyty CD/DVD/Blu-ray)",
        "correct": false
      },
      {
        "text": "ext4",
        "inline_explanation": "(to system plików)",
        "correct": false
      }
    ],
    "explanation": "W wirtualizacji spotykamy formaty opisu maszyny (metadane) oraz formaty dysków. \n ⚫ **OVF:** Otwarty standard pakowania i dystrybucji (przenośny między różnymi hiperwizorami, np. z VMware do VirtualBox). \n ⚫ **VMDK:** Format dysku VMware. \n ⚫ **VHDX:** Nowoczesny format dysku Microsoftu. \n ⚫ **QCOW2:** Popularny format w świecie Linux/KVM (obsługuje snapshoty i kompresję)."
  },
  {
    "id": 69,
    "question": "Pamięci masowe wykorzystywane w maszynach wirtualnych:",
    "options": [
      {
        "text": "NFS (Network File System)",
        "inline_explanation": "(popularny protokół plikowy, łatwy w konfiguracji dla VMware/KVM)",
        "correct": true
      },
      {
        "text": "iSCSI (Internet Small Computer Systems Interface)",
        "inline_explanation": "(protokół blokowy działający po sieci Ethernet/IP)",
        "correct": true
      },
      {
        "text": "Fibre Channel (FC)",
        "inline_explanation": "(dedykowana, szybka sieć optyczna do przesyłania danych blokowych w sieciach SAN)",
        "correct": true
      },
      {
        "text": "SMTP",
        "inline_explanation": "(protokół pocztowy Simple Mail Transfer Protocol)",
        "correct": false
      },
      {
        "text": "vSAN / Ceph (Software Defined Storage)",
        "inline_explanation": "(rozwiązania klastrowe, które agregują dyski lokalne wielu serwerów w jedną wspólną przestrzeń)",
        "correct": true
      }
    ],
    "explanation": "Hiperwizory (jak ESXi, Proxmox, Hyper-V) potrzebują miejsca do składowania plików maszyn wirtualnych. Mogą korzystać z: \n ⚫ **DAS:** Dyski lokalne. \n ⚫ **SAN (Storage Area Network):** Blokowy dostęp przez sieć (FC, iSCSI). \n ⚫ **NAS (Network Attached Storage):** Plikowy dostęp przez sieć (głównie NFS, rzadziej SMB). \n ⚫ **SDS:** Programowe macierze rozproszone (Ceph, vSAN)."
  },
  {
    "id": 70,
    "question": "Hiperwizor typu 1:",
    "options": [
      {
        "text": "pracuje bezpośrednio na systemie operacyjnym gospodarza",
        "inline_explanation": "(to definicja Typu 2 - Hosted, np. VirtualBox zainstalowany na Windowsie)",
        "correct": false
      },
      {
        "text": "pracuje bezpośrednio na sprzęcie fizycznym komputera",
        "inline_explanation": "(ma bezpośredni dostęp do CPU i RAM bez pośrednictwa innego systemu operacyjnego)",
        "correct": true
      },
      {
        "text": "cechuje się wyższą wydajnością niż hiperwizor typu 2",
        "inline_explanation": "(brak narzutu systemu gospodarza)",
        "correct": true
      },
      {
        "text": "przykładem jest Oracle VirtualBox",
        "inline_explanation": "(to klasyczny przykład hiperwizora typu 2)",
        "correct": false
      },
      {
        "text": "przykładem jest VMware ESXi lub Microsoft Hyper-V Server",
        "inline_explanation": "(systemy te instaluje się na czystym serwerze)",
        "correct": true
      },
      {
        "text": "ma bezpośredni dostęp do zasobów sprzętowych",
        "inline_explanation": "()",
        "correct": true
      },
      {
        "text": "nazywany jest również hiperwizorem natywnym",
        "inline_explanation": "()",
        "correct": true
      },
      {
        "text": "wymaga zainstalowanego wcześniej systemu Windows lub Linux",
        "inline_explanation": "(to Typ 2)",
        "correct": false
      },
      {
        "text": "służy głównie do testowania oprogramowania na stacjach roboczych",
        "inline_explanation": "(to domena typu 2)",
        "correct": false
      }
    ],
    "explanation": "Podział hiperwizorów: \n  \n ⚫ **Typ 1 (Bare-metal):** Instalowany na \"gołym metalu\". Przykłady: VMware ESXi, Hyper-V, Xen, KVM (KVM jest hybrydą, ale działa jak Typ 1). Używany w serwerowniach i chmurach. \n ⚫ **Typ 2 (Hosted):** Aplikacja uruchamiana na systemie (Windows/Linux/macOS). Przykłady: VMware Workstation, VirtualBox. Używany do testów i nauki na laptopach."
  },
  {
    "id": 71,
    "question": "Jakimi znacznikami ogranicza się skrypty PHP?",
    "options": [
      {
        "text": "`<? php ?>`",
        "inline_explanation": "(błąd składniowy - spacja po znaku zapytania jest niedozwolona)",
        "correct": false
      },
      {
        "text": "`<?php ... ?>`",
        "inline_explanation": "(standardowy, zalecany i zawsze dostępny sposób otwierania bloku PHP)",
        "correct": true
      },
      {
        "text": "`<script language=\"php\"> ... </script>`",
        "inline_explanation": "(forma przestarzała, usunięta całkowicie w PHP 7.0)",
        "correct": false
      },
      {
        "text": "`<php> ... </php>`",
        "inline_explanation": "(niepoprawne; PHP nie używa składni XML-owej w ten sposób)",
        "correct": false
      },
      {
        "text": "`<?= ... ?>`",
        "inline_explanation": "(tzw. short echo tag; równoważnik `<?php echo ... ?>`, dostępny domyślnie w nowszych wersjach)",
        "correct": true
      }
    ],
    "explanation": "Standardowym sposobem otwarcia bloku kodu PHP jest znacznik: `<?php`, a zamknięcia: `?>`. Istnieją też formy skrócone (`<? ... ?>`), ale ich obsługa zależy od konfiguracji serwera (`short_open_tag` w php.ini) i nie jest zalecana w kodzie przenośnym. Wyjątkiem jest `<?= ... ?>`, który służy do szybkiego wypisywania zmiennych."
  },
  {
    "id": 72,
    "question": "Poufność danych cyfrowych jest zapewniana dzięki:",
    "options": [
      {
        "text": "kryptografii (szyfrowaniu danych)",
        "inline_explanation": "(sprawia, że dane są nieczytelne dla osób nieposiadających klucza)",
        "correct": true
      },
      {
        "text": "sumom kontrolnym i funkcjom skrótu",
        "inline_explanation": "(to zapewnia integralność - wykrywanie zmian, a nie ukrywanie treści)",
        "correct": false
      },
      {
        "text": "redundancji sprzętowej (RAID, klastry)",
        "inline_explanation": "(to zapewnia dostępność - Availability)",
        "correct": false
      },
      {
        "text": "wyłącznie jawnym protokołom transmisji",
        "inline_explanation": "(protokoły jawne, jak HTTP czy Telnet, nie zapewniają poufności)",
        "correct": false
      },
      {
        "text": "steganografii",
        "inline_explanation": "(technika ta ukrywa samo istnienie informacji, np. w obrazku, ale nie jest to synonim kryptografii)",
        "correct": false
      }
    ],
    "explanation": "Poufność to gwarancja, że dane są dostępne jedynie dla uprawnionych. W modelu **CIA** (Confidentiality, Integrity, Availability) głównym mechanizmem zapewniającym poufność jest **szyfrowanie** (np. AES, RSA). Inne mechanizmy wspierające to kontrola dostępu (ACL), ale to szyfrowanie jest ostatnią linią obrony."
  },
  {
    "id": 73,
    "question": "Kontrola integralności danych cyfrowych polega na sprawdzeniu czy nie zostały one:",
    "options": [
      {
        "text": "odczytane przez osoby niepowołane",
        "inline_explanation": "(to naruszenie poufności, a nie integralności)",
        "correct": false
      },
      {
        "text": "zmodyfikowane w sposób nieautoryzowany (przypadkowo lub celowo)",
        "inline_explanation": "(kluczowa definicja integralności)",
        "correct": true
      },
      {
        "text": "zaszyfrowane kluczem publicznym",
        "inline_explanation": "(szyfrowanie to normalna operacja kryptograficzna)",
        "correct": false
      },
      {
        "text": "skopiowane na inny nośnik",
        "inline_explanation": "(samo skopiowanie bit w bit zachowuje integralność kopii)",
        "correct": false
      },
      {
        "text": "sfałszowane (np. poprzez weryfikację podpisu cyfrowego)",
        "inline_explanation": "(podpis cyfrowy gwarantuje zarówno integralność, jak i autentyczność)",
        "correct": true
      }
    ],
    "explanation": "Integralność (Integrity) oznacza, że dane są spójne, kompletne i niezmienione. Kontrola integralności (np. przy użyciu sum kontrolnych CRC, funkcji skrótu SHA-256 lub podpisów cyfrowych) weryfikuje, czy dane są dokładnie takie same, jak w momencie ich utworzenia/wysłania."
  },
  {
    "id": 74,
    "question": "Szyfr monoalfabetyczny:",
    "options": [
      {
        "text": "zachowuje statystykę (częstość występowania znaków) języka szyfrowanej wiadomości",
        "inline_explanation": "(np. litera 'E' w tekście jawnym zawsze zamienia się na ten sam znak w szyfrogramie)",
        "correct": true
      },
      {
        "text": "jest odporny na ataki statystyczne",
        "inline_explanation": "(jest bardzo podatny; można go łatwo złamać analizą częstości liter)",
        "correct": false
      },
      {
        "text": "wykorzystuje wiele alfabetów do szyfrowania jednej wiadomości",
        "inline_explanation": "(to definicja szyfru polialfabetycznego, np. Vigenère)",
        "correct": false
      },
      {
        "text": "jest obecnie uznawany za bezpieczny standard w bankowości",
        "inline_explanation": "(współcześnie używa się szyfrów blokowych jak AES, a nie prostych podstawień)",
        "correct": false
      },
      {
        "text": "jest przykładem prostego szyfru podstawieniowego (substytucyjnego)",
        "inline_explanation": "(każdy znak jest zastępowany innym wg stałej reguły)",
        "correct": true
      }
    ],
    "explanation": "Szyfr monoalfabetyczny polega na stałym przyporządkowaniu znaku tekstu jawnego do znaku szyfrogramu. Ponieważ relacja jest 1:1 i stała, histogram znaków w szyfrogramie wygląda tak samo jak w języku naturalnym (tylko przesunięty/pomieszany). Ułatwia to kryptoanalizę (np. najczęstszy znak w szyfrogramie to prawdopodobnie 'A' lub 'I' w języku polskim)."
  },
  {
    "id": 75,
    "question": "Bezpieczne szyfry powinny mieć następującą własność:",
    "options": [
      {
        "text": "spełnianiem kryterium lawinowości (Avalanche Effect)",
        "inline_explanation": "(zmiana 1 bitu wejścia powinna zmieniać średnio 50% bitów wyjścia)",
        "correct": true
      },
      {
        "text": "liniowością funkcji szyfrującej",
        "inline_explanation": "(szyfry muszą być silnie nieliniowe, by utrudnić kryptoanalizę algebraiczną i różnicową)",
        "correct": false
      },
      {
        "text": "możliwością łatwego odwrócenia procesu bez znajomości klucza",
        "inline_explanation": "(to przeczyłoby idei szyfrowania; powinno to być obliczeniowo niemożliwe)",
        "correct": false
      },
      {
        "text": "generowaniem zawsze takiego samego szyfrogramu dla różnych kluczy",
        "inline_explanation": "(klucz musi determinować unikalny wynik)",
        "correct": false
      },
      {
        "text": "oparciem bezpieczeństwa o utajnienie algorytmu (Security by Obscurity)",
        "inline_explanation": "(zgodnie z Zasadą Kerckhoffsa, bezpieczeństwo powinno zależeć tylko od tajności klucza, a nie algorytmu)",
        "correct": false
      }
    ],
    "explanation": "Współczesna kryptografia wymaga dwóch cech zdefiniowanych przez Shannona: **dyfuzji** i **konfuzji**. Kryterium lawinowości jest kluczowe dla dyfuzji - mała zmiana na wejściu (tekst jawny lub klucz) powoduje ogromną, nieprzewidywalną zmianę na wyjściu, zamazując wszelkie statystyczne zależności."
  },
  {
    "id": 76,
    "question": "Bezpieczna funkcja skrótu musi być odporna na:",
    "options": [
      {
        "text": "faktoryzację",
        "inline_explanation": "(to problem matematyczny leżący u podstaw algorytmu asymetrycznego RSA, a nie funkcji skrótu)",
        "correct": false
      },
      {
        "text": "występowanie kolizji",
        "inline_explanation": "(trudność obliczeniowa znalezienia dwóch różnych danych wejściowych dających ten sam hash)",
        "correct": true
      },
      {
        "text": "ataki typu preimage (odwracanie)",
        "inline_explanation": "(niemożność odtworzenia oryginalnej wiadomości na podstawie samego skrótu)",
        "correct": true
      },
      {
        "text": "deszyfrację",
        "inline_explanation": "(funkcje skrótu są z definicji jednokierunkowe i nieodwracalne, więc pojęcie deszyfracji nie ma tu zastosowania)",
        "correct": false
      },
      {
        "text": "atak urodzinowy (Birthday Attack)",
        "inline_explanation": "(funkcja musi mieć odpowiednio długi skrót, np. 256 bitów, by ten atak był niepraktyczny)",
        "correct": true
      }
    ],
    "explanation": "Funkcja skrótu (hash function) przekształca dane o dowolnej długości w ciąg o stałej długości (np. SHA-256). \n  \n Musi być odporna na: \n ⚫ **Kolizje (Collision resistance):** Trudność w znalezieniu dwóch dowolnych wiadomości $m1$ i $m2$, które dają ten sam skrót. \n ⚫ **Odwracanie (Preimage resistance):** Trudność w znalezieniu wiadomości pasującej do danego skrótu."
  },
  {
    "id": 77,
    "question": "Szyfry symetryczne charakteryzują się tym, że:",
    "options": [
      {
        "text": "dane wejściowe algorytmu dzielone są na symetryczne części",
        "inline_explanation": "(nieprecyzyjny opis, który może dotyczyć struktury Feistela, ale nie definiuje całej klasy szyfrów)",
        "correct": false
      },
      {
        "text": "do szyfrowania i deszyfrowania wykorzystywany jest ten sam tajny klucz",
        "inline_explanation": "(kluczowa cecha; nadawca i odbiorca muszą posiadać identyczną kopię klucza)",
        "correct": true
      },
      {
        "text": "używają pary kluczy: publicznego i prywatnego",
        "inline_explanation": "(to definicja szyfrów asymetrycznych)",
        "correct": false
      },
      {
        "text": "są wolniejsze obliczeniowo od szyfrów asymetrycznych",
        "inline_explanation": "(nie, są zazwyczaj 100-1000x szybsze, dlatego szyfruje się nimi duże ilości danych)",
        "correct": false
      },
      {
        "text": "wymagają bezpiecznego kanału do wymiany klucza przed rozpoczęciem komunikacji",
        "inline_explanation": "(problem dystrybucji kluczy jest główną wadą kryptografii symetrycznej)",
        "correct": true
      }
    ],
    "explanation": "Kluczową cechą kryptografii symetrycznej jest to, że **ten sam klucz** służy zarówno do szyfrowania, jak i deszyfrowania wiadomości. \n  \n Strony komunikacji muszą ten klucz wcześniej bezpiecznie uzgodnić. Przykłady: AES, DES, ChaCha20."
  },
  {
    "id": 78,
    "question": "Załóżmy że Ania i Bartek używają kryptografii asymetrycznej (RSA). Jeżeli Ania zaszyfruje tajną wiadomość kluczem publicznym Bartka, to wiadomość taką można odszyfrować za pomocą:",
    "options": [
      {
        "text": "klucza prywatnego Ani",
        "inline_explanation": "(służyłby do podpisywania wiadomości przez Anię, a nie do odczytu wiadomości dla Bartka)",
        "correct": false
      },
      {
        "text": "klucza prywatnego Bartka",
        "inline_explanation": "(tylko Bartek ma swój klucz prywatny, więc tylko on może otworzyć wiadomość zaszyfrowaną jego kluczem publicznym)",
        "correct": true
      },
      {
        "text": "klucza publicznego Ani",
        "inline_explanation": "(służy do weryfikacji podpisu Ani)",
        "correct": false
      },
      {
        "text": "klucza publicznego Bartka",
        "inline_explanation": "(służy do szyfrowania, a nie deszyfrowania)",
        "correct": false
      },
      {
        "text": "wspólnego klucza sesyjnego",
        "inline_explanation": "(w czystym modelu asymetrycznym nie ma klucza sesyjnego, choć w hybrydowym bywa używany)",
        "correct": false
      }
    ],
    "explanation": "W kryptografii asymetrycznej (klucz publiczny/prywatny): \n ⚫ **Poufność:** Nadawca szyfruje **Kluczem Publicznym Odbiorcy**. Tylko Odbiorca posiada pasujący **Klucz Prywatny**, którym może to odczytać. \n ⚫ **Podpis cyfrowy:** Nadawca szyfruje (podpisuje) swoim **Kluczem Prywatnym**, a każdy może zweryfikować Kluczem Publicznym Nadawcy."
  },
  {
    "id": 79,
    "question": "Co łączy szyfry AES i RSA?",
    "options": [
      {
        "text": "klucze publiczne dla obu algorytmów są jawne",
        "inline_explanation": "(fałsz, AES jest szyfrem symetrycznym i w ogóle nie posiada kluczy publicznych)",
        "correct": false
      },
      {
        "text": "są to algorytmy powszechnie stosowane w nowoczesnych systemach kryptograficznych (często w układzie hybrydowym)",
        "inline_explanation": "(np. w TLS: RSA/ECC służy do uzgodnienia klucza, a AES do szyfrowania właściwych danych)",
        "correct": true
      },
      {
        "text": "oba są szyframi symetrycznymi",
        "inline_explanation": "(RSA jest asymetryczny)",
        "correct": false
      },
      {
        "text": "oba opierają swoje bezpieczeństwo na problemie faktoryzacji liczb pierwszych",
        "inline_explanation": "(tylko RSA; AES opiera się na złożoności operacji substytucji i permutacji)",
        "correct": false
      },
      {
        "text": "oba są uznane przez NIST za standardy",
        "inline_explanation": "(RSA jest standardem de facto, AES jest standardem rządowym USA)",
        "correct": true
      },
      {
        "text": "oba służą do podpisu cyfrowego",
        "inline_explanation": "(AES nie służy do podpisu cyfrowego, tylko RSA)",
        "correct": false
      },
      {
        "text": "mają tę samą długość klucza",
        "inline_explanation": "(klucze RSA są wielokrotnie dłuższe)",
        "correct": false
      },
      {
        "text": "są wspólnie wykorzystywane w systemach szyfrowania hybrydowego",
        "inline_explanation": "(RSA służy do bezpiecznej wymiany klucza, a AES do szyfrowania właściwych danych)",
        "correct": true
      }
    ],
    "explanation": "AES (symetryczny, szybki) i RSA (asymetryczny, wolny) różnią się mechanizmem działania, ale uzupełniają się w **systemach hybrydowych** (np. HTTPS). Asymetryczny RSA służy do bezpiecznej wymiany klucza symetrycznego, który potem jest używany przez AES do szybkiego szyfrowania transmisji."
  },
  {
    "id": 80,
    "question": "W praktyce podpis elektroniczny bazuje na:",
    "options": [
      {
        "text": "szyfrowaniu asymetrycznym i funkcjach skrótu",
        "inline_explanation": "(skrót dokumentu jest szyfrowany kluczem prywatnym nadawcy)",
        "correct": true
      },
      {
        "text": "wyłącznie szyfrowaniu symetrycznym",
        "inline_explanation": "(brak cechy niezaprzeczalności - obie strony mają ten sam klucz, więc każda mogła wygenerować podpis)",
        "correct": false
      },
      {
        "text": "tylko funkcjach skrótu",
        "inline_explanation": "(zapewnia integralność, ale nie wskazuje autora)",
        "correct": false
      },
      {
        "text": "steganografii",
        "inline_explanation": "(ukrywanie danych nie jest metodą uwierzytelniania)",
        "correct": false
      },
      {
        "text": "infrastrukturze klucza publicznego (PKI)",
        "inline_explanation": "(PKI dostarcza certyfikaty wiążące tożsamość z kluczem publicznym)",
        "correct": true
      }
    ],
    "explanation": "Podpis elektroniczny wykorzystuje dwa mechanizmy: \n  \n 1. **Funkcje skrótu (Hash):** Aby zapewnić integralność i wydajność (podpisuje się krótki \"odcisk\" dokumentu, a nie cały wielki plik). \n 2. **Kryptografię asymetryczną:** Aby zapewnić autentyczność i niezaprzeczalność. Skrót jest szyfrowany **kluczem prywatnym** nadawcy."
  },
  {
    "id": 81,
    "question": "Certyfikat klucza publicznego w formacie X.509 zawiera:",
    "options": [
      {
        "text": "identyfikator (Distinguished Name) centrum certyfikacyjnego, które wystawiło certyfikat",
        "inline_explanation": "(pole Issuer DN)",
        "correct": true
      },
      {
        "text": "klucz publiczny podmiotu certyfikatu",
        "inline_explanation": "(to najważniejsza część certyfikatu - wiąże klucz z tożsamością)",
        "correct": true
      },
      {
        "text": "klucz prywatny podmiotu",
        "inline_explanation": "(nigdy! klucz prywatny musi pozostać tajny i nie opuszcza urządzenia właściciela)",
        "correct": false
      },
      {
        "text": "historię odwiedzanych stron internetowych",
        "inline_explanation": "(absurdalna odpowiedź; certyfikat służy do identyfikacji, a nie śledzenia)",
        "correct": false
      },
      {
        "text": "podpis cyfrowy wystawcy (CA)",
        "inline_explanation": "(gwarantuje, że nikt nie sfałszował zawartości certyfikatu)",
        "correct": true
      }
    ],
    "explanation": "Standard X.509 definiuje format certyfikatów w infrastrukturze PKI. \n  \n Certyfikat to cyfrowy dowód tożsamości. Zawiera: \n ⚫ **Subject:** Kto to jest? \n ⚫ **Public Key:** Jaki jest jego klucz publiczny? \n ⚫ **Issuer:** Kto to potwierdza (urząd CA)? \n ⚫ **Signature:** Podpis CA pod powyższymi danymi. \n Certyfikat **nigdy** nie zawiera klucza prywatnego."
  },
  {
    "id": 82,
    "question": "Bezpieczeństwo kryptografii kwantowej bazuje na:",
    "options": [
      {
        "text": "zjawisku, w którym pomiar zaburza stan kwantowy",
        "inline_explanation": "(próba podsłuchu przez Ewę wprowadza błędy w transmisji, które Alicja i Bob mogą wykryć)",
        "correct": true
      },
      {
        "text": "twierdzeniu o zakazie klonowania (No-cloning theorem)",
        "inline_explanation": "(nie da się stworzyć idealnej kopii nieznanego stanu kwantowego)",
        "correct": true
      },
      {
        "text": "prawach fizyki",
        "inline_explanation": "(nie da się oszukać praw natury, niezależnie od tego, jak szybki masz komputer)",
        "correct": true
      },
      {
        "text": "zasadzie nieoznaczoności Heisenberga",
        "inline_explanation": "()",
        "correct": true
      },
      {
        "text": "wykorzystaniu splątania kwantowego do przesyłania danych szybciej niż światło",
        "inline_explanation": "(mit; splątanie nie pozwala na przesył informacji z prędkością nadświetlną)",
        "correct": false
      },
      {
        "text": "trudności rozkładu dużych liczb na czynniki pierwsze",
        "inline_explanation": "(to podstawa kryptografii klasycznej asymetrycznej, np. RSA, a nie kwantowej)",
        "correct": false
      },
      {
        "text": "szyfrowaniu samej wiadomości (payloadu) za pomocą stanów kwantowych",
        "inline_explanation": "(obecnie technologia QKD służy do uzgodnienia klucza, a sama wiadomość jest szyfrowana klasycznie, np. AES-em)",
        "correct": false
      },
      {
        "text": "na problemie logarytmu dyskretnego",
        "inline_explanation": "(to dotyczy Diffie-Hellman/ECC)",
        "correct": false
      },
      {
        "text": "na długości klucza powyżej 4096 bitów",
        "inline_explanation": "(długość klucza jest wtórna, ważny jest sposób jego przesyłania)",
        "correct": false
      }
    ],
    "explanation": "Kryptografia kwantowa opiera się na prawach fizyki, a nie matematyki. \n  \n Jeśli podsłuchiwacz (Ewa) spróbuje zmierzyć przesyłane fotony, zgodnie z **Zasadą Nieoznaczoności Heisenberga**, nieuchronnie zmieni ich stan. Legalni użytkownicy (Alicja i Bob) porównują próbkę danych i jeśli wykryją błędy (ber > 0), wiedzą, że kanał jest podsłuchiwany."
  },
  {
    "id": 83,
    "question": "Uwierzytelnianie typu challenge-response:",
    "options": [
      {
        "text": "wymaga komunikacji poprzez protokół UDP",
        "inline_explanation": "(mechanizm ten jest niezależny od warstwy transportowej; działa też na TCP, HTTP itd.)",
        "correct": false
      },
      {
        "text": "zapobiega przesyłaniu hasła jawnym tekstem przez sieć",
        "inline_explanation": "(przesyłany jest tylko wynik operacji kryptograficznej, a nie samo hasło)",
        "correct": true
      },
      {
        "text": "chroni przed atakami typu powtórzenie (Replay Attack)",
        "inline_explanation": "(dzięki unikalności losowego wyzwania - nonce - stara odpowiedź nie zadziała ponownie)",
        "correct": true
      },
      {
        "text": "wymaga, aby użytkownik posiadał fizyczny token sprzętowy",
        "inline_explanation": "(niekoniecznie, challenge-response jest też podstawą np. protokołów CRAM-MD5 czy NTLM opartych na hasłach)",
        "correct": false
      },
      {
        "text": "wymaga ustanowienia szyfrowanego tunelu (np. VPN) do działania",
        "inline_explanation": "(nie, ten mechanizm został zaprojektowany właśnie po to, by bezpiecznie logować się przez niezaufany, jawny kanał)",
        "correct": false
      }
    ],
    "explanation": "Mechanizm: \n 1. Serwer wysyła losowe wyzwanie (`Nonce`). \n 2. Klient łączy wyzwanie ze swoim hasłem i oblicza skrót/podpis (`Response = Hash(Password + Nonce)`). \n 3. Serwer robi to samo i porównuje wyniki. \n Dzięki temu hasło nigdy nie lata w sieci, a podsłuchanie `Response` nic nie daje atakującemu przy kolejnej próbie logowania (bo `Nonce` będzie inny)."
  },
  {
    "id": 84,
    "question": "Skuteczny atak typu DDoS (Distributed Denial of Service):",
    "options": [
      {
        "text": "wymaga wcześniejszego złamania haseł administratora atakowanego systemu",
        "inline_explanation": "(nie, atakuje się dostępność z zewnątrz, nie trzeba wchodzić do środka)",
        "correct": false
      },
      {
        "text": "polega na wyczerpaniu zasobów systemu (pasma, CPU, tablicy stanów) poprzez generowanie sztucznego ruchu",
        "inline_explanation": "(cel to uniemożliwienie działania usługi dla legalnych użytkowników)",
        "correct": true
      },
      {
        "text": "jest realizowany najczęściej przy użyciu botnetu",
        "inline_explanation": "(sieci tysięcy zainfekowanych urządzeń zombie)",
        "correct": true
      },
      {
        "text": "skutkuje kradzieżą bazy danych użytkowników",
        "inline_explanation": "(to skutek ataku typu 'Data Breach', a nie DoS)",
        "correct": false
      },
      {
        "text": "może wykorzystywać mechanizm amplifikacji (np. DNS Amplification)",
        "inline_explanation": "(atakujący wysyła małe zapytanie ze sfałszowanym adresem źródłowym, a serwer odpowiada dużą porcją danych do ofiary)",
        "correct": true
      }
    ],
    "explanation": "Atak DDoS ma na celu zablokowanie dostępności usługi (Availability). Nie jest to włamanie w sensie kradzieży danych, ale \"zadeptanie\" serwera. Wykorzystuje się do tego **botnety** (przejęte komputery, kamery, routery IoT), które jednocześnie wysyłają żądania do ofiary."
  },
  {
    "id": 85,
    "question": "Który z podanych algorytmów **NIE** służy do testowania czy liczba jest pierwsza?",
    "options": [
      {
        "text": "Test Millera-Rabina",
        "inline_explanation": "(to najpopularniejszy probabilistyczny test pierwszości)",
        "correct": false
      },
      {
        "text": "Algorytm Euklidesa",
        "inline_explanation": "(służy do znajdowania Największego Wspólnego Dzielnika - NWD/GCD dwóch liczb)",
        "correct": true
      },
      {
        "text": "Test AKS (Agrawal-Kayal-Saxena)",
        "inline_explanation": "(pierwszy deterministyczny test pierwszości działający w czasie wielomianowym)",
        "correct": false
      },
      {
        "text": "Test Fermata",
        "inline_explanation": "(prosty probabilistyczny test pierwszości oparty na Małym Twierdzeniu Fermata)",
        "correct": false
      },
      {
        "text": "Test Solovaya-Strassena",
        "inline_explanation": "(historycznie ważny probabilistyczny test pierwszości)",
        "correct": false
      }
    ],
    "explanation": "Należy rozróżnić problemy matematyczne: \n ⚫ **Testowanie pierwszości:** Sprawdzamy, czy $N$ jest liczbą pierwszą (Millera-Rabina, Fermata, AKS). \n ⚫ **NWD:** Szukamy wspólnego dzielnika (Euklides). \n ⚫ **Faktoryzacja:** Szukamy dzielników liczby złożonej (Sito ciał liczbowych - GNFS)."
  },
  {
    "id": 86,
    "question": "Co to jest szyfr afiniczny?",
    "options": [
      {
        "text": "Dowolny szyfr wieloalfabetyczny",
        "inline_explanation": "(fałsz, jest to szyfr monoalfabetyczny, podobnie jak szyfr Cezara)",
        "correct": false
      },
      {
        "text": "Rodzaj szyfru podstawieniowego opartego na funkcji liniowej $f(x) = (ax + b) \\mod m$",
        "inline_explanation": "(gdzie $x$ to numer litery, a $a$ i $b$ to klucze)",
        "correct": true
      },
      {
        "text": "Szyfr blokowy używany w standardzie AES",
        "inline_explanation": "(AES to Rijndael, o wiele bardziej skomplikowana struktura)",
        "correct": false
      },
      {
        "text": "Algorytm asymetryczny oparty na krzywych eliptycznych",
        "inline_explanation": "(to ECC, zupełnie inna dziedzina matematyki)",
        "correct": false
      },
      {
        "text": "Szyfr, w którym klucz mnożący $a$ musi być względnie pierwszy z rozmiarem alfabetu $m$",
        "inline_explanation": "(warunek konieczny, aby funkcja szyfrująca była odwracalna, czyli żeby dało się odszyfrować wiadomość)",
        "correct": true
      }
    ],
    "explanation": "Szyfr afiniczny to klasyczny szyfr podstawieniowy. \n Każda litera o numerze $x$ jest zamieniana na literę o numerze: $$ E(x) = (ax + b) \\pmod m $$ \n Jest to uogólnienie szyfru Cezara (gdzie $a=1$). Aby deszyfracja była możliwa, liczba $a$ musi mieć odwrotność modulo $m$, czyli $NWD(a, m) = 1$."
  },
  {
    "id": 87,
    "question": "Odwrotność liczby $x$ modulo $N$:",
    "options": [
      {
        "text": "Można wyliczyć z użyciem Rozszerzonego Algorytmu Euklidesa",
        "inline_explanation": "(jest to standardowa metoda obliczania elementu odwrotnego w ciele skończonym)",
        "correct": true
      },
      {
        "text": "Istnieje dla każdej liczby całkowitej $x$",
        "inline_explanation": "(fałsz, istnieje tylko wtedy, gdy $x$ i $N$ są względnie pierwsze)",
        "correct": false
      },
      {
        "text": "Jest zawsze równa $1/x$",
        "inline_explanation": "(w arytmetyce modularnej operujemy na liczbach całkowitych, nie ma tu ułamków dziesiętnych)",
        "correct": false
      },
      {
        "text": "Można obliczyć za pomocą sita Eratostenesa",
        "inline_explanation": "(sito służy do znajdowania liczb pierwszych, a nie odwrotności)",
        "correct": false
      },
      {
        "text": "Jest to taka liczba $y$, że $x \\cdot y \\equiv 1 \\pmod N$",
        "inline_explanation": "(to jest matematyczna definicja odwrotności modulo)",
        "correct": true
      }
    ],
    "explanation": "Odwrotność modulo to kluczowe pojęcie w kryptografii asymetrycznej (RSA). \n  \n W arytmetyce \"zegarowej\" (modulo $N$), odwrotnością liczby $x$ jest taka liczba $y$, która po pomnożeniu przez $x$ daje resztę 1 z dzielenia przez $N$. Oblicza się ją Rozszerzonym Algorytmem Euklidesa."
  },
  {
    "id": 88,
    "question": "Aby utrudnić inżynierię wsteczną oprogramowania stosuje się:",
    "options": [
      {
        "text": "obfuskację",
        "inline_explanation": "(zaciemnianie kodu - np. zamiana nazw zmiennych na losowe ciągi znaków, dodawanie martwego kodu)",
        "correct": true
      },
      {
        "text": "pakowanie kodu wykonywalnego",
        "inline_explanation": "(kompresja i szyfrowanie pliku .exe, który rozpakowuje się dopiero w pamięci RAM)",
        "correct": true
      },
      {
        "text": "kompilację z flagami debugowania (Debug Symbols)",
        "inline_explanation": "(to drastycznie ułatwia inżynierię wsteczną, udostępniając nazwy funkcji i zmiennych)",
        "correct": false
      },
      {
        "text": "dokumentowanie kodu zgodnie ze standardami",
        "inline_explanation": "(to dobra praktyka inżynierska, ale nie ma wpływu na skompilowany plik binarny)",
        "correct": false
      },
      {
        "text": "publikację kodu źródłowego na GitHubie",
        "inline_explanation": "(to zaprzeczenie utrudniania analizy - daje atakującemu pełną wiedzę)",
        "correct": false
      }
    ],
    "explanation": "Inżynieria wsteczna polega na analizie skompilowanego programu, by zrozumieć jak działa. Aby to utrudnić, programiści (i twórcy malware'u) stosują **obfuskację**. Zaciemniony kod działa tak samo, ale jest nieczytelny dla człowieka i trudny do analizy dla deasemblerów."
  },
  {
    "id": 89,
    "question": "Wirtualne sieci prywatne (VPN) można tworzyć przy wykorzystaniu protokołu:",
    "options": [
      {
        "text": "TLS",
        "inline_explanation": "(np. OpenVPN, SSL VPN - działa w warstwie aplikacji/sesji)",
        "correct": true
      },
      {
        "text": "IPsec",
        "inline_explanation": "(standard działający w warstwie sieciowej - Layer 3)",
        "correct": true
      },
      {
        "text": "L2TP",
        "inline_explanation": "(często używany w parze z IPsec jako L2TP/IPsec)",
        "correct": true
      },
      {
        "text": "SMTP",
        "inline_explanation": "(protokół pocztowy)",
        "correct": false
      },
      {
        "text": "WireGuard",
        "inline_explanation": "(nowoczesny, szybki i prosty protokół VPN wbudowany w jądro Linuxa)",
        "correct": true
      }
    ],
    "explanation": "VPN tworzy szyfrowany tunel przez publiczną sieć (Internet). Najpopularniejsze technologie to: \n 1. **IPsec:** Standard przemysłowy, trudniejszy w konfiguracji, często używany do łączenia oddziałów firm (Site-to-Site). \n 2. **SSL/TLS (OpenVPN):** Bardziej elastyczny, łatwo przechodzi przez firewalle i NAT, popularny w dostępie zdalnym (Client-to-Site). \n 3. **WireGuard:** Nowy standard, bardzo wydajny."
  },
  {
    "id": 90,
    "question": "W trybie tunelowym (Tunnel Mode) protokołu IPsec:",
    "options": [
      {
        "text": "szyfrowane jest tylko pole danych (payload) pakietu IP",
        "inline_explanation": "(to definicja trybu Transportowego, używanego w komunikacji Host-to-Host)",
        "correct": false
      },
      {
        "text": "szyfrowany jest cały oryginalny pakiet IP i umieszczany w nowym nagłówku",
        "inline_explanation": "(tzw. enkapsulacja; oryginalny adres IP jest ukryty)",
        "correct": true
      },
      {
        "text": "nie stosuje się szyfrowania, jedynie uwierzytelnianie",
        "inline_explanation": "(zależy to od użycia protokołu AH vs ESP, a nie samego trybu)",
        "correct": false
      },
      {
        "text": "nagłówki IP są zawsze przesyłane jawnym tekstem",
        "inline_explanation": "(zewnętrzny nagłówek tak, ale wewnętrzny - oryginalny - jest zaszyfrowany)",
        "correct": false
      },
      {
        "text": "jest to tryb domyślny dla połączeń typu Site-to-Site (Brama-Brama)",
        "inline_explanation": "(pozwala połączyć dwie sieci LAN przez Internet)",
        "correct": true
      }
    ],
    "explanation": "IPsec ma dwa tryby: \n  \n ⚫ **Tryb transportowy:** Chroni tylko dane (payload). Nagłówek IP jest oryginalny. \n ⚫ **Tryb tunelowy:** Szyfruje cały pakiet (wraz z nagłówkiem). Całość jest pakowana w nowy pakiet (\"kopertę\") z adresami bram VPN."
  },
  {
    "id": 91,
    "question": "Systemy wykrywania zagrożeń (IDS) oparte na sygnaturach (Signature-based):",
    "options": [
      {
        "text": "działają z reguły szybciej niż systemy bazujące na wykrywaniu anomalii",
        "inline_explanation": "(porównanie wzorca jest operacją prostszą obliczeniowo niż analiza statystyczna)",
        "correct": true
      },
      {
        "text": "są nieskuteczne w przypadku ataków typu Zero-Day",
        "inline_explanation": "(jeśli nie ma sygnatury w bazie, atak przejdzie niezauważony)",
        "correct": true
      },
      {
        "text": "generują więcej fałszywych alarmów (False Positives) niż systemy anomalii",
        "inline_explanation": "(fałsz, zazwyczaj generują ich mniej, bo reagują na konkretny, znany wzorzec)",
        "correct": false
      },
      {
        "text": "uczą się zachowania sieci w czasie rzeczywistym",
        "inline_explanation": "(to domena systemów behawioralnych/anomalii)",
        "correct": false
      },
      {
        "text": "wymagają regularnych aktualizacji bazy wzorców",
        "inline_explanation": "(podobnie jak programy antywirusowe, muszą znać najnowsze definicje zagrożeń)",
        "correct": true
      }
    ],
    "explanation": "IDS-y dzielimy na: \n 1. **Oparte na sygnaturach:** Porównują pakiety z bazą znanych wzorców (jak antywirus). Szybkie, precyzyjne, ale ślepe na nowe ataki. \n 2. **Oparte na anomaliach:** Uczą się \"normalnego\" ruchu. Wykrywają nowości (Zero-Day), ale często generują fałszywe alarmy."
  },
  {
    "id": 92,
    "question": "Serwer AAA realizuje usługi:",
    "options": [
      {
        "text": "Autoryzacja",
        "inline_explanation": "(Authorization - określenie uprawnień: co użytkownik może zrobić?)",
        "correct": true
      },
      {
        "text": "Uwierzytelnianie",
        "inline_explanation": "(Authentication - weryfikacja tożsamości: kim użytkownik jest?)",
        "correct": true
      },
      {
        "text": "Rozliczalność",
        "inline_explanation": "(Accounting - rejestrowanie aktywności: co i jak długo robił?)",
        "correct": true
      },
      {
        "text": "Adresacja IP",
        "inline_explanation": "(Addressing - przydziałem adresów zajmuje się DHCP, a nie framework AAA)",
        "correct": false
      },
      {
        "text": "Akceleracja sprzętowa",
        "inline_explanation": "(AAA to model bezpieczeństwa logicznego, nie ma związku z wydajnością sprzętu)",
        "correct": false
      }
    ],
    "explanation": "Akronim AAA w bezpieczeństwie sieciowym oznacza: \n ⚫ **Authentication:** Weryfikacja tożsamości (np. login/hasło). \n ⚫ **Authorization:** Przyznanie uprawnień (np. dostęp do VLAN-u HR). \n ⚫ **Accounting:** Logowanie użycia zasobów (np. czas sesji, ilość danych)."
  },
  {
    "id": 93,
    "question": "Hierarchiczny model zaufania do certyfikatów cyfrowych:",
    "options": [
      {
        "text": "jest fundamentem infrastruktury klucza publicznego (PKI)",
        "inline_explanation": "(opiera się na zaufaniu do głównego urzędu - Root CA)",
        "correct": true
      },
      {
        "text": "opiera się na modelu \"Web of Trust\" znanym z PGP",
        "inline_explanation": "(fałsz, WoT to model zdecentralizowany, gdzie użytkownicy ręczą za siebie nawzajem)",
        "correct": false
      },
      {
        "text": "nie wymaga istnienia zaufanej trzeciej strony (TTP)",
        "inline_explanation": "(wymaga; Urząd Certyfikacji - CA - pełni właśnie rolę TTP)",
        "correct": false
      },
      {
        "text": "pozwala każdemu użytkownikowi wystawiać powszechnie uznawane certyfikaty",
        "inline_explanation": "(nie, tylko autoryzowane centra CA mogą wystawiać zaufane certyfikaty)",
        "correct": false
      },
      {
        "text": "wykorzystuje technologię Blockchain do walidacji",
        "inline_explanation": "(klasyczne PKI X.509 nie korzysta z blockchaina, choć trwają nad tym prace badawcze)",
        "correct": false
      }
    ],
    "explanation": "Modele zaufania: \n ⚫ **Hierarchiczny (PKI):** Drzewiasta struktura. Ufamy Root CA (np. DigiCert), więc ufamy wszystkim certyfikatom, które on podpisał. \n ⚫ **Sieć zaufania (Web of Trust):** Model pajęczyny (PGP). Nie ma szefa; ufam Jankowi, a Janek ufa Zosi, więc ja też mogę zaufać Zosi."
  },
  {
    "id": 94,
    "question": "Algorytm Diffiego-Hellmana (DH) umożliwia:",
    "options": [
      {
        "text": "bezpieczne przesyłanie kluczy prywatnych",
        "inline_explanation": "(klucze prywatne nigdy nie powinny być przesyłane!)",
        "correct": false
      },
      {
        "text": "uzgodnienie wspólnego klucza sesji w niezabezpieczonym kanale",
        "inline_explanation": "(obie strony matematycznie generują ten sam klucz, nie przesyłając go fizycznie)",
        "correct": true
      },
      {
        "text": "uwierzytelnienie tożsamości stron",
        "inline_explanation": "(czysty DH nie zapewnia uwierzytelniania i jest podatny na atak Man-in-the-Middle; wymaga dodatkowych podpisów)",
        "correct": false
      },
      {
        "text": "szyfrowanie asymetryczne wiadomości email",
        "inline_explanation": "(do tego służy RSA lub ElGamal; DH służy do wymiany kluczy)",
        "correct": false
      },
      {
        "text": "sprawdzenie integralności plików",
        "inline_explanation": "(to zadanie funkcji skrótu)",
        "correct": false
      }
    ],
    "explanation": "Protokół Diffiego-Hellmana to rewolucyjny algorytm pozwalający dwóm stronom, które nigdy się nie spotkały, uzgodnić wspólny tajny klucz, mimo że cała ich komunikacja jest podsłuchiwana. \n  \n **Wada:** Bez dodatkowego uwierzytelnienia (np. certyfikatami), DH jest podatny na atak \"Człowiek pośrodku\" (MITM)."
  },
  {
    "id": 95,
    "question": "Wyrażana w bitach entropia dla źródła wiadomości:",
    "options": [
      {
        "text": "może wynosić -0,76 bita (jest ujemna)",
        "inline_explanation": "(fałsz, entropia jako miara informacji/niepewności jest zawsze nieujemna)",
        "correct": false
      },
      {
        "text": "jest zawsze wartością nieujemną (większą lub równą 0)",
        "inline_explanation": "(zero oznacza całkowitą pewność - brak informacji)",
        "correct": true
      },
      {
        "text": "osiąga maksimum, gdy wszystkie komunikaty są jednakowo prawdopodobne",
        "inline_explanation": "(rozkład jednostajny maksymalizuje niepewność)",
        "correct": true
      },
      {
        "text": "wynosi 1 bit dla rzutu uczciwą monetą",
        "inline_explanation": "($- (0.5 \\log_2 0.5 + 0.5 \\log_2 0.5) = 1$)",
        "correct": true
      },
      {
        "text": "określa dolną granicę kompresji bezstratnej",
        "inline_explanation": "(zgodnie z twierdzeniem o kodowaniu źródła, nie da się skompresować danych poniżej ich entropii)",
        "correct": true
      }
    ],
    "explanation": "Entropia Shannona $H(X)$ to miara nieokreśloności (ilości informacji). Ponieważ prawdopodobieństwa są ułamkami z przedziału $(0, 1]$, ich logarytmy są ujemne. Minus we wzorze $H(X) = - \\sum p(x) \\log_2 p(x)$ sprawia, że ostateczny wynik jest zawsze **nieujemny** ($H \\ge 0$). Ujemna informacja nie ma sensu fizycznego."
  },
  {
    "id": 96,
    "question": "Proszę wskazać zdanie **FAŁSZYWE** w odniesieniu do ciał Galois:",
    "options": [
      {
        "text": "Ciało na pewno zawiera element odwrotny dla elementu neutralnego dodawania (zera)",
        "inline_explanation": "(fałsz, zero jest jedynym elementem, który nie posiada odwrotności multiplikatywnej - nie można dzielić przez zero)",
        "correct": true
      },
      {
        "text": "Liczba elementów ciała skończonego jest zawsze potęgą liczby pierwszej ($p^n$)",
        "inline_explanation": "(prawda, np. $GF(2^8)$ ma 256 elementów)",
        "correct": false
      },
      {
        "text": "W ciele muszą być wykonalne działania dodawania, odejmowania, mnożenia i dzielenia (przez nie-zero)",
        "inline_explanation": "(prawda, to definicja ciała w algebrze)",
        "correct": false
      },
      {
        "text": "Ciała Galois są szeroko stosowane w kryptografii (np. w AES i Krzywych Eliptycznych)",
        "inline_explanation": "(prawda, pozwalają na wykonywanie obliczeń bez błędów zaokrągleń)",
        "correct": false
      },
      {
        "text": "Istnieją dwa elementy neutralne: 0 dla dodawania i 1 dla mnożenia",
        "inline_explanation": "(prawda, są to podstawowe elementy struktury)",
        "correct": false
      }
    ],
    "explanation": "Ciało (Field) w matematyce to zbiór, w którym można swobodnie dodawać, odejmować, mnożyć i dzielić. \n  \n Kluczowy wyjątek: **nie można dzielić przez zero**. Zatem zdanie, że zero (\"element neutralny dodawania\") ma odwrotność, jest fałszem matematycznym."
  },
  {
    "id": 97,
    "question": "Gdyby komputery kwantowe się upowszechniły, algorytm Shora wymusiłby rezygnację z:",
    "options": [
      {
        "text": "funkcji skrótu SHA-3",
        "inline_explanation": "(nie, SHA-3 jest odporne na algorytm Shora, choć algorytm Grovera wymusiłby użycie dłuższych skrótów)",
        "correct": false
      },
      {
        "text": "obecnie stosowanych algorytmów asymetrycznych takich jak RSA i ECC",
        "inline_explanation": "(algorytm Shora potrafi w czasie wielomianowym faktoryzować liczby i liczyć logarytmy dyskretne, łamiąc te systemy)",
        "correct": true
      },
      {
        "text": "protokołu wymiany kluczy Diffiego-Hellmana",
        "inline_explanation": "(również opiera się na problemie logarytmu dyskretnego, więc zostałby złamany)",
        "correct": true
      },
      {
        "text": "szyfrów symetrycznych z kluczami jednorazowymi (One-Time Pad)",
        "inline_explanation": "(OTP jest niemożliwy do złamania nawet teoretycznie, niezależnie od mocy obliczeniowej)",
        "correct": false
      },
      {
        "text": "wdrożenia algorytmów Kryptografii Postkwantowej (PQC)",
        "inline_explanation": "(wręcz przeciwnie, wymusiłby ich natychmiastowe wdrożenie)",
        "correct": false
      }
    ],
    "explanation": "Algorytm Shora to \"zabójca\" współczesnej kryptografii klucza publicznego. \n Potrafi on szybko rozwiązywać problemy, na których opiera się **RSA** (faktoryzacja) oraz **ECC/Diffie-Hellman** (logarytm dyskretny). Szyfry symetryczne (AES) są bezpieczniejsze - algorytm Grovera osłabia je tylko o połowę (AES-256 staje się jak AES-128)."
  },
  {
    "id": 98,
    "question": "Paradoks dnia urodzin (Birthday Paradox) to zjawisko matematyczne, które wykorzystuje się do ataku na:",
    "options": [
      {
        "text": "szyfry blokowe w trybie CBC",
        "inline_explanation": "(rzadziej, choć np. atak Sweet32 wykorzystuje kolizje bloków 64-bitowych)",
        "correct": false
      },
      {
        "text": "funkcje skrótu (poszukiwanie kolizji)",
        "inline_explanation": "(najczęstsze zastosowanie; pozwala znaleźć kolizję w czasie $O(2^{n/2})$ zamiast $O(2^n)$)",
        "correct": true
      },
      {
        "text": "podpisy cyfrowe",
        "inline_explanation": "(jeśli znajdę dwa dokumenty o tym samym skrócie, mogę podłożyć jeden za drugi pod podpisem)",
        "correct": true
      },
      {
        "text": "generatory liczb pseudolosowych",
        "inline_explanation": "(analiza powtarzalności sekwencji)",
        "correct": false
      },
      {
        "text": "szyfry strumieniowe typu RC4",
        "inline_explanation": "(RC4 ma inne słabości, np. biasy w początkowych bajtach)",
        "correct": false
      }
    ],
    "explanation": "Paradoks dnia urodzin mówi, że w grupie zaledwie 23 osób szansa, że dwie mają urodziny tego samego dnia, wynosi >50%. \n  \n W kryptografii oznacza to, że znalezienie **kolizji** (dwóch różnych wiadomości o tym samym hashu) jest znacznie łatwiejsze niż znalezienie konkretnej wiadomości pasującej do konkretnego hasha (preimage)."
  },
  {
    "id": 99,
    "question": "Który z podanych niżej szyfrów **NIE** jest szyfrem strumieniowym?",
    "options": [
      {
        "text": "ChaCha20",
        "inline_explanation": "(nowoczesny szyfr strumieniowy, następca Salsa20)",
        "correct": false
      },
      {
        "text": "RC4",
        "inline_explanation": "(klasyczny, choć już niebezpieczny szyfr strumieniowy, znany z WEP)",
        "correct": false
      },
      {
        "text": "AES (Rijndael)",
        "inline_explanation": "(standardowy szyfr blokowy, operujący na macierzach 4x4 bajty)",
        "correct": true
      },
      {
        "text": "A5/1",
        "inline_explanation": "(szyfr strumieniowy używany w sieciach GSM do szyfrowania rozmów)",
        "correct": false
      },
      {
        "text": "Salsa20",
        "inline_explanation": "(szyfr strumieniowy zaprojektowany przez Daniela Bernsteina)",
        "correct": false
      }
    ],
    "explanation": "Podział szyfrów: \n  \n ⚫ **Szyfry strumieniowe:** Szyfrują bit po bicie (lub bajt po bajcie) przy użyciu generatora pseudolosowego (XOR z tekstem jawnym). Przykłady: RC4, ChaCha20. \n ⚫ **Szyfry blokowe:** Szyfrują ustalone porcje danych (bloki, np. 128 bitów) naraz. Przykłady: AES, DES, Twofish."
  },
  {
    "id": 100,
    "question": "Funkcja mieszająca SHA-3 jest oparta na kocepcji:",
    "options": [
      {
        "text": "ElGamal",
        "inline_explanation": "(to asymetryczny schemat szyfrowania)",
        "correct": false
      },
      {
        "text": "Gąbki (Sponge construction)",
        "inline_explanation": "(innowacyjna struktura algorytmu Keccak, pozwalająca na wchłanianie danych i wyciskanie skrótu)",
        "correct": true
      },
      {
        "text": "Merkle-Damgård",
        "inline_explanation": "(na tej klasycznej strukturze oparte są MD5, SHA-1 i SHA-2)",
        "correct": false
      },
      {
        "text": "Krzywych eliptycznych",
        "inline_explanation": "(stosowane w ECC, a nie w hashowaniu)",
        "correct": false
      },
      {
        "text": "Sieci Feistela",
        "inline_explanation": "(struktura używana w szyfrach blokowych jak DES, Blowfish)",
        "correct": false
      }
    ],
    "explanation": "SHA-3 (algorytm Keccak) zerwał z tradycją Merkle-Damgård (podatną na ataki typu length extension). Zamiast tego używa **konstrukcji gąbki** (sponge). \n  \n Proces składa się z fazy **absorpcji** (wchłaniania danych wejściowych) i fazy **wyciskania** (generowania skrótu o dowolnej długości)."
  },
  {
    "id": 101,
    "question": "Jakie ramki są wymieniane w procesie przyłączania stacji do punktu dostępowego?",
    "options": [
      {
        "text": "Authentication Request / Authentication Response",
        "inline_explanation": "(drugi etap: 'Open System Authentication' to formalność w sieciach z WPA2, ale jest wymagana przez standard)",
        "correct": true
      },
      {
        "text": "Association Request / Association Response",
        "inline_explanation": "(trzeci etap: faktyczne logiczne przyłączenie do sieci)",
        "correct": true
      },
      {
        "text": "Probe Request / Probe Response",
        "inline_explanation": "(pierwszy etap: aktywne skanowanie w poszukiwaniu sieci)",
        "correct": true
      },
      {
        "text": "Routing Information Protocol (RIP) Update",
        "inline_explanation": "(to protokół routingu warstwy 3, nie bierze udziału w nawiązywaniu połączenia warstwy 2)",
        "correct": false
      },
      {
        "text": "DHCP Discover / Offer",
        "inline_explanation": "(to następuje dopiero PO udanym przyłączeniu radiowym i zestawieniu łącza)",
        "correct": false
      }
    ],
    "explanation": "Proces przyłączania do sieci Wi-Fi składa się z trzech faz: \n  \n 1. **Skanowanie:** Stacja szuka sieci (Probe). \n 2. **Uwierzytelnianie 802.11:** Wymiana ramek Auth (w WPA2 to tylko \"dzień dobry\", właściwe uwierzytelnianie kluczem następuje później w EAPOL). \n 3. **Asocjacja:** Stacja prosi o przyłączenie (Assoc Req), a AP przydziela jej identyfikator (Association ID)."
  },
  {
    "id": 102,
    "question": "Jaką długość może mieć w sieciach IEEE 802.11 tzw. 'secret key'?",
    "options": [
      {
        "text": "256 bitów",
        "inline_explanation": "(standardowa długość klucza Pairwise Master Key w WPA2-Personal, wyliczanego z hasła)",
        "correct": true
      },
      {
        "text": "128 bitów",
        "inline_explanation": "(typowa długość klucza szyfrującego dane w algorytmie AES-CCMP)",
        "correct": false
      },
      {
        "text": "40 bitów",
        "inline_explanation": "(długość klucza w starym, złamanym standardzie WEP-64; 40 bitów klucza + 24 bity wektora inicjującego)",
        "correct": false
      },
      {
        "text": "4 bity",
        "inline_explanation": "(zbyt mało dla jakiejkolwiek kryptografii)",
        "correct": false
      },
      {
        "text": "512 bitów (jako standardowy klucz WEP)",
        "inline_explanation": "(nie istniał taki standard WEP; WEP kończył się na 104/128 bitach)",
        "correct": false
      }
    ],
    "explanation": "W standardzie WPA2/WPA3-Personal używamy hasła (passphrase), ale jest ono przekształcane funkcją PBKDF2 (z użyciem SSID jako soli) w 256-bitowy klucz zwany **PMK (Pairwise Master Key)**. Ten klucz jest podstawą do generowania kluczy tymczasowych szyfrujących transmisję."
  },
  {
    "id": 103,
    "question": "Atak z użyciem ramek RTS, który powoduje blokadę dostępu do kanału radiowego (RTS flood attack) opiera się na:",
    "options": [
      {
        "text": "manipulacji mechanizmem wirtualnego wykrywania nośnej (NAV) poprzez ustawienie maksymalnej wartości w polu Duration",
        "inline_explanation": "(atakujący rezerwuje kanał na długi czas, zmuszając inne stacje do milczenia, nawet jeśli kanał jest wolny)",
        "correct": true
      },
      {
        "text": "wydłużaniu okna Contention Window w innych stacjach",
        "inline_explanation": "(to mechanizm używany przy kolizjach w CSMA/CA, ale RTS Flood atakuje wektor NAV, a nie bezpośrednio algorytm backoff)",
        "correct": false
      },
      {
        "text": "wysyłaniu ramek Deauthentication do wszystkich klientów",
        "inline_explanation": "(to inny typ ataku: Deauth Attack, który rozłącza klientów, a nie blokuje kanał rezerwacją)",
        "correct": false
      },
      {
        "text": "fizycznym zagłuszaniu częstotliwości radiowej silnym sygnałem szumowym",
        "inline_explanation": "(to atak typu Jamming w warstwie fizycznej, a RTS Flood to atak logiczny w warstwie łącza danych)",
        "correct": false
      },
      {
        "text": "przepełnieniu tablicy adresów MAC w przełączniku (Switchu)",
        "inline_explanation": "(atak MAC Flooding dotyczy sieci przewodowych Ethernet, a nie Wi-Fi)",
        "correct": false
      }
    ],
    "explanation": "Atak RTS Flood wykorzystuje mechanizm **NAV (Network Allocation Vector)**. Atakujący wysyła ramki RTS z fałszywą, bardzo dużą wartością w polu **Duration**. Wszystkie stacje w zasięgu, które odbiorą taką ramkę, muszą zgodnie ze standardem 802.11 zaktualizować swój licznik NAV i wstrzymać nadawanie na ten czas, uznając kanał za zajęty (Virtual Carrier Sense), co prowadzi do ataku odmowy dostępu (DoS)."
  },
  {
    "id": 104,
    "question": "Atak ARP Poisoning w sieciach IEEE 802.11:",
    "options": [
      {
        "text": "polega na przypisaniu wielu adresów IP do jednej karty sieciowej",
        "inline_explanation": "(to legalna technika zwana IP Aliasing)",
        "correct": false
      },
      {
        "text": "polega na rozsyłaniu fałszywych odpowiedzi ARP (ARP Reply)",
        "inline_explanation": "(odpowiedzi te wiążą MAC atakującego z IP ofiary lub bramy)",
        "correct": true
      },
      {
        "text": "umożliwia atak typu Man-in-the-Middle w sieciach przełączanych (switch)",
        "inline_explanation": "(przełącznik kieruje ruch do atakującego, myśląc, że to właściwy odbiorca)",
        "correct": true
      },
      {
        "text": "służy do łamania hasła WPA2",
        "inline_explanation": "(ARP działa w warstwie 2/3 już po nawiązaniu połączenia Wi-Fi)",
        "correct": false
      },
      {
        "text": "zatruwa pamięć podręczną (cache) ARP na komputerach ofiar",
        "inline_explanation": "(ofiary aktualizują swoje tablice błędnymi danymi)",
        "correct": true
      }
    ],
    "explanation": "ARP Poisoning polega na \"zatruwaniu\" tablic ARP innych urządzeń w sieci LAN. \n  \n Atakujący wysyła komunikat: \"Ja mam adres IP bramy (np. 192.168.1.1)!\". Komputery ofiar zapisują MAC atakującego jako MAC bramy i cały ruch internetowy wysyłają do niego."
  },
  {
    "id": 105,
    "question": "W przełączniku zgodnym ze standardem IEEE 802.3 i pracującym z domyślnymi ustawieniami odebrano ramkę o nieznanym adresie źródłowym oraz nieznanym adresie docelowym. Tablica adresów MAC:",
    "options": [
      {
        "text": "zostanie zwiększona o 2 adresy",
        "inline_explanation": "(fałsz, switch nie uczy się adresu docelowego z tej ramki, bo nie wie, gdzie on jest)",
        "correct": false
      },
      {
        "text": "zostanie zwiększona o 1 adres (adres nadawcy)",
        "inline_explanation": "(switch uczy się: \"na tym porcie jest nadawca o takim MAC\")",
        "correct": true
      },
      {
        "text": "zostanie zwiększona o 1 adres (adres odbiorcy)",
        "inline_explanation": "(nope - o adres nadawcy)",
        "correct": false
      },
      {
        "text": "nie ulegnie zmianie",
        "inline_explanation": "(fałsz, proces uczenia następuje przy każdej ramce przychodzącej z nowym źródłem)",
        "correct": false
      },
      {
        "text": "zostanie wyczyszczona",
        "inline_explanation": "(nie ma powodu do czyszczenia tablicy)",
        "correct": false
      },
      {
        "text": "ramka zostanie odrzucona (dropped)",
        "inline_explanation": "(nie, ramka zostanie rozgłoszona - flood - na wszystkie porty poza źródłowym)",
        "correct": false
      }
    ],
    "explanation": "Algorytm działania przełącznika: \n  \n 1. **Learning (Uczenie):** Patrzy na Source MAC. Nie zna go? Dopisuje do tablicy (MAC + Port). Tablica rośnie o 1. \n 2. **Forwarding (Przekazywanie):** Patrzy na Destination MAC. Nie zna go? Robi **Flooding** (wysyła wszędzie), ale nie dopisuje go do tablicy, bo nie wie, na którym porcie jest odbiorca."
  },
  {
    "id": 106,
    "question": "Sieci VLAN (Virtual LAN) stosuje się m.in. w celu:",
    "options": [
      {
        "text": "ograniczenia domeny domyślnej",
        "inline_explanation": "(ramki broadcast nie \"wyciekają\" poza obręb danego VLAN-u, co zmniejsza zbędny ruch w sieci)",
        "correct": true
      },
      {
        "text": "zastąpienia routerów w sieci",
        "inline_explanation": "(nie, do komunikacji *pomiędzy* VLAN-ami nadal potrzebny jest router lub switch L3)",
        "correct": false
      },
      {
        "text": "zwiększenia fizycznej przepustowości łącza (Bandwidth)",
        "inline_explanation": "(VLAN to podział logiczny, nie dodaje magicznie nowych kabli ani nie przyspiesza łącza)",
        "correct": false
      },
      {
        "text": "zwiększenia zasięgu sieci bezprzewodowej",
        "inline_explanation": "(to zadanie Access Pointów i anten, a nie logicznej segmentacji)",
        "correct": false
      },
      {
        "text": "ograniczenia domeny kolizyjnej",
        "inline_explanation": "(to robi switch sam z siebie, nawet bez VLAN)",
        "correct": false
      },
      {
        "text": "separacji ruchu sieciowego",
        "inline_explanation": "(np. oddzielenie sieci gości od sieci księgowości, co zwiększa bezpieczeństwo)",
        "correct": true
      },
      {
        "text": "logicznego grupowania stacji roboczych niezależnie od ich fizycznej lokalizacji",
        "inline_explanation": "(pracownik może przenieść biurko na inne piętro, a administrator tylko zmienia konfigurację portu w switchu, żeby nadal był w tej samej podsieci)",
        "correct": true
      }
    ],
    "explanation": "VLAN dzieli fizyczną sieć LAN na mniejsze, odseparowane logicznie podsieci. \n ⚫ **Główny cel:** Ograniczenie domeny rozgłoszeniowej (Broadcast Domain). \n ⚫ **Zalety:** Bezpieczeństwo (separacja), wydajność (mniej śmieciowego ruchu), łatwiejsze zarządzanie strukturą logiczną niezależnie od fizycznego rozmieszczenia gniazdek."
  },
  {
    "id": 107,
    "question": "Jakie nowe elementy zostały wprowadzone w standardzie IEEE 802.11ax?",
    "options": [
      {
        "text": "Kolorowanie obszarów BSS (BSS Coloring)",
        "inline_explanation": "(oznaczanie ramek \"kolorem\" własnej sieci, aby ignorować zakłócenia od sąsiadów)",
        "correct": true
      },
      {
        "text": "OFDMA (Orthogonal Frequency-Division Multiple Access)",
        "inline_explanation": "(podział kanału na mniejsze podnośne przypisane różnym użytkownikom, co zmniejsza opóźnienia)",
        "correct": true
      },
      {
        "text": "Modulacja 1024-QAM",
        "inline_explanation": "(jeszcze gęstsze upakowanie danych w symbolu, wymagające jednak bardzo dobrego sygnału)",
        "correct": true
      },
      {
        "text": "Technologia MIMO",
        "inline_explanation": "(to rozwiązanie było już obecne w starszych standardach 802.11n/ac)",
        "correct": false
      },
      {
        "text": "Target Wake Time (TWT)",
        "inline_explanation": "(mechanizm oszczędzania energii w urządzeniach IoT, które mogą \"spać\" przez ustalony czas)",
        "correct": true
      }
    ],
    "explanation": "Wi-Fi 6 (802.11ax) skupia się na wydajności w tłoku (High Efficiency). \n  \n **BSS Coloring** pozwala na lepsze wykorzystanie przestrzenne pasma w zatłoczonych biurach. Zamiast czekać, aż sąsiad skończy nadawać na tym samym kanale, urządzenie ignoruje jego transmisję, jeśli ma inny \"kolor\"."
  },
  {
    "id": 108,
    "question": "Jakie algorytmy szyfrowania są stosowane w mechanizmie WPA2 standardu IEEE 802.11?",
    "options": [
      {
        "text": "RC5",
        "inline_explanation": "(nie jest używany w standardach Wi-Fi)",
        "correct": false
      },
      {
        "text": "AES (w trybie CCMP)",
        "inline_explanation": "(Advanced Encryption Standard - to podstawa bezpieczeństwa WPA2)",
        "correct": true
      },
      {
        "text": "RC4",
        "inline_explanation": "(był używany w starym WEP i przejściowym WPA/TKIP, obecnie uznany za niebezpieczny)",
        "correct": false
      },
      {
        "text": "3DES",
        "inline_explanation": "(nieużywany w Wi-Fi, zbyt wolny i przestarzały)",
        "correct": false
      },
      {
        "text": "ChaCha20",
        "inline_explanation": "(pojawia się dopiero w WPA3 jako opcja, w WPA2 standardem jest AES)",
        "correct": false
      }
    ],
    "explanation": "Historia szyfrowania w Wi-Fi: \n ⚫ **WEP:** RC4 (złamany). \n ⚫ **WPA (TKIP):** RC4 z rotacją kluczy (tymczasowe). \n ⚫ **WPA2 (CCMP):** **AES** (bezpieczny standard). \n ⚫ **WPA3:** AES-GCMP (jeszcze bezpieczniejszy)."
  },
  {
    "id": 109,
    "question": "Protokół TLS korzysta z:",
    "options": [
      {
        "text": "Infrastruktury Klucza Publicznego (PKI) i certyfikatów X.509",
        "inline_explanation": "(serwer musi wylegitymować się zaufanym certyfikatem, aby potwierdzić tożsamość)",
        "correct": true
      },
      {
        "text": "wyłącznie z symetrycznych kluczy PSK (Pre-Shared Keys)",
        "inline_explanation": "(rzadko używane w publicznym internecie, standardem są certyfikaty)",
        "correct": false
      },
      {
        "text": "protokołu UDP bez kontroli przepływu",
        "inline_explanation": "(TLS działa na TCP; wersja dla UDP to DTLS)",
        "correct": false
      },
      {
        "text": "algorytmów bezkluczowych",
        "inline_explanation": "(niemożliwe; kryptografia wymaga kluczy)",
        "correct": false
      },
      {
        "text": "szyfrowania asymetrycznego do wymiany klucza sesji",
        "inline_explanation": "(np. RSA lub Diffie-Hellman)",
        "correct": true
      }
    ],
    "explanation": "Protokół TLS (następca SSL) działa hybrydowo. \n  \n 1. **Uwierzytelnianie:** Serwer wysyła certyfikat X.509 (PKI). Przeglądarka sprawdza jego podpis. \n 2. **Wymiana kluczy:** Strony używają kryptografii asymetrycznej (RSA/DH), by uzgodnić wspólny klucz. \n 3. **Szyfrowanie danych:** Właściwa transmisja jest szyfrowana szybko (symetrycznie, np. AES)."
  },
  {
    "id": 110,
    "question": "MAC Flooding oznacza:",
    "options": [
      {
        "text": "przesyłanie tablic adresów MAC",
        "inline_explanation": "(nie, to atak ofensywny, a nie audyt)",
        "correct": false
      },
      {
        "text": "przepełnienie tablicy adresów (CAM Table)",
        "inline_explanation": "(tablica ma ograniczony rozmiar, np. 8000 wpisów)",
        "correct": true
      },
      {
        "text": "wymuszenie na przełączniku przejścia w tryb \"Fail-Open\" (działania jak Hub)",
        "inline_explanation": "(gdy tablica jest pełna, switch rozsyła nieznany ruch na wszystkie porty, umożliwiając podsłuch)",
        "correct": true
      },
      {
        "text": "zablokowanie portów protokołem STP",
        "inline_explanation": "(to inny mechanizm)",
        "correct": false
      },
      {
        "text": "szyfrowanie ruchu sieciowego",
        "inline_explanation": "(wręcz przeciwnie, ułatwia jego podsłuchanie)",
        "correct": false
      }
    ],
    "explanation": "MAC Flooding polega na zalaniu przełącznika tysiącami fałszywych ramek z losowymi źródłowymi adresami MAC. \n Switch szybko zapełnia swoją pamięć CAM (Content Addressable Memory). Gdy brakuje miejsca na nowe wpisy, urządzenie z bezpieczeństwa (lub wady) zaczyna traktować nowe ramki jak ruch broadcastowy (flood), wysyłając je do wszystkich. Atakujący może wtedy podsłuchać ruch innych użytkowników."
  },
  {
    "id": 111,
    "question": "Kryptoanaliza szyfru przestawieniowego może korzystać z:",
    "options": [
      {
        "text": "analizy częstotliwościowej",
        "inline_explanation": "(badanie histogramu znaków - ponieważ szyfr zmienia tylko kolejność liter, a nie same litery, więc statystyka występowania liter pozostaje identyczna jak w języku naturalnym)",
        "correct": true
      },
      {
        "text": "faktu, że przestrzeń kluczy jest zazwyczaj bardzo mała (np. 8 bitów)",
        "inline_explanation": "(zależy od długości bloku permutacji, ale dla długich bloków liczba kombinacji n! jest ogromna)",
        "correct": false
      },
      {
        "text": "metod analizy różnicowej",
        "inline_explanation": "(metoda ta służy głównie do łamania nowoczesnych szyfrów blokowych, badając wpływ zmian w tekście jawnym na szyfrogram)",
        "correct": false
      },
      {
        "text": "algorytmów faktoryzacji dużych liczb",
        "inline_explanation": "(to domena kryptoanalizy asymetrycznej, np. RSA)",
        "correct": false
      },
      {
        "text": "obserwacji, że szyfrogram ma wygładzony (płaski) rozkład liter",
        "inline_explanation": "(fałsz, wygładzenie histogramu to cecha szyfrów polialfabetycznych; w przestawieniowym 'górki i dołki' zostają zachowane)",
        "correct": false
      }
    ],
    "explanation": "Szyfr przestawieniowy to po prostu anagramowanie (zmiana kolejności). \n Jeśli zaszyfrujesz słowo \"KAJAK\", otrzymasz np. \"AAKJK\". Liczba liter 'A' i 'K' się nie zmienia.\n\nKryptoanalityk używa **analizy częstotliwościowej**: widząc tekst, w którym litery takie jak A, E, O występują bardzo często (jak w normalnym języku), ale tekst jest nieczytelny, od razu wie, że litery nie zostały zmienione, a jedynie poprzestawiane."
  },
  {
    "id": 112,
    "question": "Jakie kluczowe ulepszenie bezpieczeństwa wprowadza standard WPA3 w sieciach Wi-Fi?",
    "options": [
      {
        "text": "Wprowadza szyfrowanie oparte na algorytmie RC4",
        "inline_explanation": "(fałsz, RC4 jest przestarzały i niebezpieczny)",
        "correct": false
      },
      {
        "text": "Zastępuje mechanizm PSK protokołem SAE (Simultaneous Authentication of Equals)",
        "inline_explanation": "(SAE chroni przed atakami słownikowymi offline na hasło, nawet jeśli jest ono słabe)",
        "correct": true
      },
      {
        "text": "Wymusza stosowanie ochrony ramek zarządzających (Protected Management Frames - PMF)",
        "inline_explanation": "(zapobiega to prostym atakom rozłączeniowym - deauth attack)",
        "correct": true
      },
      {
        "text": "Rezygnuje z szyfrowania na rzecz samej autentykacji",
        "inline_explanation": "(nie, szyfrowanie jest nadal kluczowe; w WPA3 używa się AES-GCMP)",
        "correct": false
      },
      {
        "text": "Pozwala na używanie kluczy 40-bitowych dla kompatybilności z WEP",
        "inline_explanation": "(WPA3 zrywa kompatybilność z tak starymi i dziurawymi rozwiązaniami)",
        "correct": false
      }
    ],
    "explanation": "WPA3 naprawia główną wadę WPA2 - podatność na łamanie haseł metodą brute-force offline po przechwyceniu handshake'u. \n  \n Dzięki protokołowi **SAE** (Dragonfly), atakujący ma tylko jedną szansę na zgadnięcie hasła przy każdej próbie połączenia, co uniemożliwia masowe sprawdzanie haseł w domowym zaciszu."
  },
  {
    "id": 113,
    "question": "Własność Perfect Forward Secrecy (PFS) w protokołach kryptograficznych (np. TLS, IPsec) oznacza, że:",
    "options": [
      {
        "text": "ujawnienie klucza głównego (długoterminowego) pozwala odszyfrować wszystkie przeszłe rozmowy",
        "inline_explanation": "(to definicja BRAKU PFS)",
        "correct": false
      },
      {
        "text": "ujawnienie klucza głównego NIE pozwala na odszyfrowanie sesji, które odbyły się w przeszłości",
        "inline_explanation": "(klucze sesyjne były efemeryczne i zostały skasowane zaraz po rozmowie)",
        "correct": true
      },
      {
        "text": "dla każdej nowej sesji generowany jest nowy, tymczasowy zestaw kluczy",
        "inline_explanation": "(niezależny od klucza głównego serwera)",
        "correct": true
      },
      {
        "text": "system pozwala na odzyskanie zapomnianych haseł użytkowników",
        "inline_explanation": "(PFS dotyczy szyfrowania transmisji, a nie zarządzania tożsamością)",
        "correct": false
      },
      {
        "text": "wszystkie dane są archiwizowane na wypadek awarii",
        "inline_explanation": "(to backup, a nie PFS)",
        "correct": false
      }
    ],
    "explanation": "PFS to \"bezpiecznik\" na wypadek kradzieży klucza prywatnego serwera. \n  \n W systemach bez PFS (np. starym RSA key exchange), jeśli ktoś nagrywał Twój ruch przez rok i dziś ukradł klucz serwera - odczyta wszystko. Z PFS (np. DHE, ECDHE) - nie odczyta nic, bo klucze, które zabezpieczały tamte dane, istniały tylko przez chwilę i zniknęły."
  },
  {
    "id": 114,
    "question": "Które stwierdzenie w odniesieniu do schematu uzgadniania klucza metodą Diffiego-Hellmana jest prawdziwe?",
    "options": [
      {
        "text": "Alicja samodzielnie oblicza swój klucz prywatny a następnie dostarcza go do Boba w bezpieczny sposób",
        "inline_explanation": "(Fałsz. W DH klucz prywatny nigdy nie jest przesyłany. To, co opisano, to transport klucza, a nie jego uzgadnianie)",
        "correct": false
      },
      {
        "text": "Alicja i Bob wymieniają się wyłącznie wartościami publicznymi, a wspólny sekret obliczają niezależnie u siebie",
        "inline_explanation": "(Prawda. Na podstawie wymiany \"wymieszanych\" danych publicznych obie strony dochodzą do tego samego wyniku matematycznego)",
        "correct": true
      },
      {
        "text": "Bezpieczeństwo schematu opiera się na trudności problemu logarytmu dyskretnego",
        "inline_explanation": "(Prawda. Ewa widzi g^a i g^b, ale nie potrafi obliczyć 'a' ani 'b' w rozsądnym czasie)",
        "correct": true
      },
      {
        "text": "Algorytm ten pozwala Alicji bezpośrednio zaszyfrować plik i wysłać go do Boba",
        "inline_explanation": "(Fałsz. DH służy tylko do wygenerowania klucza. Do szyfrowania pliku używa się potem np. AES)",
        "correct": false
      },
      {
        "text": "Schemat ten gwarantuje, że Alicja na pewno rozmawia z Bobem (uwierzytelnianie)",
        "inline_explanation": "(Fałsz. Czysty DH nie zapewnia uwierzytelniania i jest podatny na atak Man-in-the-Middle; wymaga dodatkowych podpisów)",
        "correct": false
      }
    ],
    "explanation": "W protokole Diffiego-Hellmana **klucze prywatne nigdy nie opuszczają komputerów Alicji i Boba**. \n\nIstotą jest to, że wymieniają się oni publicznymi \"półproduktami\". Dzięki matematyce (potęgowaniu modularnemu), po połączeniu swojego tajnego składnika z publicznym składnikiem partnera, oboje uzyskują identyczny **wspólny sekret**, mimo że nigdy go sobie nie przesłali."
  },
  {
    "id": 115,
    "question": "Przykładem uczenia nienadzorowanego jest:",
    "options": [
      {
        "text": "wykrywanie spamu w poczcie",
        "inline_explanation": "(to klasyfikacja nadzorowana - algorytm uczy się na bazie maili oznaczonych jako 'spam' lub 'ham')",
        "correct": false
      },
      {
        "text": "grupowanie danych (Clustering), np. segmentacja klientów",
        "inline_explanation": "(algorytm sam znajduje podobieństwa i dzieli dane na grupy bez wcześniejszych etykiet)",
        "correct": true
      },
      {
        "text": "redukcja wymiarowości danych (np. PCA)",
        "inline_explanation": "(kompresja danych poprzez znalezienie najważniejszych cech)",
        "correct": true
      },
      {
        "text": "rozpoznawania pisma ręcznego",
        "inline_explanation": "(to klasyfikacja nadzorowana na podstawie bazy MNIST)",
        "correct": false
      },
      {
        "text": "wykrywanie anomalii (Anomaly Detection) w ruchu sieciowym",
        "inline_explanation": "(system uczy się co jest normą, a co odstępstwem, nie wiedząc z góry czym jest atak)",
        "correct": true
      }
    ],
    "explanation": "Rodzaje uczenia maszynowego: \n 1. **Nadzorowane (z nauczycielem):** Mamy dane i odpowiedzi (etykiety). Np. \"To jest zdjęcie kota\". Algorytm uczy się rozpoznawać koty. \n 2. **Nienadzorowane (bez nauczyciela):** Mamy tylko dane. Algorytm sam szuka w nich struktur, grup (klastrów) lub anomalii."
  },
  {
    "id": 116,
    "question": "Budując system detekcji ataków sieciowych, można rozważyć algorytm wykrywania anomalii w szczególności gdy:",
    "options": [
      {
        "text": "dane wyjściowe mają większy wymiar niż dane wejściowe",
        "inline_explanation": "(To techniczny aspekt niektórych metod, a nie powód wyboru podejścia; często w detekcji anomalii dążymy wręcz do redukcji wymiaru, by znaleźć wzorzec normy)",
        "correct": false
      },
      {
        "text": "zależy nam na wykrywaniu nowych, nieznanych wcześniej typów ataków (tzw. Zero-day)",
        "inline_explanation": "(Systemy oparte na anomaliach nie szukają konkretnego wirusa, lecz wszystkiego, co odbiega od normy)",
        "correct": true
      },
      {
        "text": "dysponujemy ogromną bazą sygnatur znanych zagrożeń i chcemy zminimalizować liczbę fałszywych alarmów",
        "inline_explanation": "(Wtedy lepszy jest system oparty na sygnaturach/regułach; anomalie generują dużo fałszywych alarmów)",
        "correct": false
      },
      {
        "text": "dane treningowe są silnie niezbalansowane (mamy dużo przykładów ruchu prawidłowego, a bardzo mało przykładów ataków)",
        "inline_explanation": "(To idealne środowisko dla detekcji anomalii – uczymy system co jest 'normalne', a atak jest odrzucany jako 'inny')",
        "correct": true
      },
      {
        "text": "system ma działać w oparciu o sztywne reguły (np. Firewall)",
        "inline_explanation": "(Detekcja anomalii to podejście probabilistyczne/statystyczne, a nie regułowe)",
        "correct": false
      }
    ],
    "explanation": "Systemy IDS (Intrusion Detection System) dzielimy na:\n1. **Oparte na sygnaturach:** Szukają znanych wzorców (jak antywirus). Są precyzyjne, ale ślepe na nowe ataki.\n2. **Oparte na anomaliach:** Uczą się \"normalnego\" zachowania sieci. Wszystko, co odbiega od normy, jest alarmem.\n\nAlgorytm anomalii wybieramy, gdy boimy się ataków, których jeszcze nikt nie nazwał (Zero-day) lub nie mamy próbek ataków do nauczenia sieci neuronowej."
  },
  {
    "id": 117,
    "question": "Termin SQL Injection oznacza:",
    "options": [
      {
        "text": "możliwość umieszczenia zapytania SQL w kodzie źródłowym strony",
        "inline_explanation": "(nieprecyzyjne; programista robi to celowo, a atak polega na manipulacji tym zapytaniem)",
        "correct": false
      },
      {
        "text": "atak polegający na wstrzyknięciu złośliwego kodu SQL poprzez dane wejściowe aplikacji",
        "inline_explanation": "(np. wpisanie `' OR '1'='1` w polu logowania, co zmienia logikę zapytania do bazy)",
        "correct": true
      },
      {
        "text": "wstrzyknięcie skryptu JavaScript do przeglądarki ofiary",
        "inline_explanation": "(to definicja ataku XSS - Cross-Site Scripting)",
        "correct": false
      },
      {
        "text": "atak na serwer DNS w celu przekierowania ruchu",
        "inline_explanation": "(to DNS Spoofing)",
        "correct": false
      },
      {
        "text": "metodę optymalizacji zapytań bazodanowych",
        "inline_explanation": "(SQL Injection to zagrożenie, a nie metoda optymalizacji)",
        "correct": false
      }
    ],
    "explanation": "SQL Injection to jeden z najgroźniejszych błędów bezpieczeństwa (OWASP Top 10). Polega na tym, że aplikacja nie filtruje danych od użytkownika i skleja je bezpośrednio z zapytaniem do bazy. \n Przykład: `SELECT * FROM users WHERE name = '` + `$userInput` + `'` \n Jeśli wpiszesz `x' OR '1'='1`, baza zwróci wszystkich użytkowników."
  },
  {
    "id": 118,
    "question": "Które stwierdzenie w odniesieniu do certyfikatów X.509 jest prawdziwe?",
    "options": [
      {
        "text": "są wykorzystywane do wykonywania cyfrowych podpisów na cyfrowych dokumentach",
        "inline_explanation": "(Tak, certyfikat wiąże tożsamość osoby podpisującej z jej kluczem publicznym, co zapewnia autentyczność i niezaprzeczalność podpisu)",
        "correct": true
      },
      {
        "text": "zawierają w sobie jawną kopię klucza prywatnego użytkownika",
        "inline_explanation": "(Fałsz. Certyfikat jest publiczny, a klucz prywatny musi pozostać wyłączną tajemnicą właściciela)",
        "correct": false
      },
      {
        "text": "służą wyłącznie do szyfrowania dysków twardych w systemach operacyjnych",
        "inline_explanation": "(Fałsz. Choć mogą być do tego użyte, ich głównym standardem jest komunikacja sieciowa SSL/TLS i podpisy)",
        "correct": false
      },
      {
        "text": "są ważne bezterminowo i nigdy nie wygasają",
        "inline_explanation": "(Fałsz. Każdy certyfikat X.509 ma ściśle określone pole 'Not After' i po tej dacie staje się nieważny)",
        "correct": false
      },
      {
        "text": "gwarantują bezpieczeństwo nawet w przypadku kradzieży klucza prywatnego",
        "inline_explanation": "(Fałsz. Jeśli klucz prywatny wycieknie, certyfikat jest kompromitowany i musi zostać unieważniony na liście CRL)",
        "correct": false
      }
    ],
    "explanation": "Standard X.509 to uniwersalny format cyfrowego dokumentu tożsamości.\n\nChoć kojarzymy go głównie z zieloną kłódką w przeglądarce (SSL/TLS), jest on również kluczowy dla **podpisu cyfrowego**. Dzięki niemu, gdy podpisujesz dokument PDF, odbiorca może sprawdzić Twój certyfikat i mieć pewność: \"Tak, ten podpis złożył Jan Kowalski, a dokument nie został zmieniony\"."
  },
  {
    "id": 119,
    "question": "Głównym przeznaczeniem zapory sieciowej (Firewall) jest:",
    "options": [
      {
        "text": "łączenie dwóch lub więcej odrębnych sieci ze sobą",
        "inline_explanation": "(to zadanie routera)",
        "correct": false
      },
      {
        "text": "filtrowanie ruchu sieciowego wchodzącego i wychodzącego na podstawie reguł",
        "inline_explanation": "(blokowanie niepożądanych połączeń, np. na porcie 445)",
        "correct": true
      },
      {
        "text": "przydzielanie adresów IP w sieci lokalnej",
        "inline_explanation": "(to zadanie serwera DHCP)",
        "correct": false
      },
      {
        "text": "skanowanie plików na dysku w poszukiwaniu wirusów",
        "inline_explanation": "(to zadanie programu antywirusowego, klasyczny firewall sieciowy tego nie robi)",
        "correct": false
      },
      {
        "text": "zamiana nazw domenowych na adresy IP",
        "inline_explanation": "(to zadanie serwera DNS)",
        "correct": false
      }
    ],
    "explanation": "Zapora sieciowa (Firewall) to strażnik sieci. Decyduje, które pakiety mogą przejść, a które należy zablokować. Decyzję podejmuje na podstawie: \n ⚫ Adresów IP (kto?) \n ⚫ Portów (jaka usługa?) \n ⚫ Protokołów (TCP/UDP) \n ⚫ Stanu połączenia (Stateful Inspection)."
  },
  {
    "id": 120,
    "question": "Co to jest uwierzytelnianie dwuskładnikowe lub dwuetapowe, znane również jako two-factor authentication (2FA)?",
    "options": [
      {
        "text": "Rodzaj ochrony kryptograficznej - szyfrowanie, które wymaga dwóch kluczy aby zapewnić poufność danych.",
        "inline_explanation": "(Fałsz. To opis pasujący do szyfrowania asymetrycznego lub hybrydowego, a nie do procesu logowania użytkownika)",
        "correct": false
      },
      {
        "text": "Metoda weryfikacji tożsamości wykorzystująca dwa składniki z różnych kategorii (np. hasło i kod SMS)",
        "inline_explanation": "(Prawda. Łączy \"coś co wiesz\" z \"czymś co masz\")",
        "correct": true
      },
      {
        "text": "Wymóg ustawienia dwóch różnych haseł do tego samego konta w celu zwiększenia bezpieczeństwa",
        "inline_explanation": "(Fałsz. Użycie dwóch haseł to nadal tylko jeden składnik - \"wiedza\". To nie jest 2FA)",
        "correct": false
      },
      {
        "text": "Procedura wymagająca dwukrotnego wpisania hasła podczas logowania w celu uniknięcia literówek",
        "inline_explanation": "(Fałsz. To tylko weryfikacja poprawności wpisywania)",
        "correct": false
      },
      {
        "text": "System pozwalający na jednoczesne logowanie do dwóch różnych serwisów",
        "inline_explanation": "(Fałsz. To definicja Single Sign-On / SSO)",
        "correct": false
      }
    ],
    "explanation": "Uwierzytelnianie 2FA (Two-Factor Authentication) nie służy do szyfrowania danych, ale do **potwierdzania tożsamości**.\n\nKluczem jest użycie dwóch **różnych** kanałów/składników:\n1. Coś, co wiesz (Hasło).\n2. Coś, co masz (Telefon z kodem SMS, Token, YubiKey).\n\nSamo szyfrowanie to zupełnie inny proces matematyczny."
  },
  {
    "id": 121,
    "question": "Czym różnią się techniki określane jako client VPN oraz proxy server?",
    "options": [
      {
        "text": "Serwer proxy tworzy zaszyfrowany tunel do przekierowywania ruchu, podczas gdy VPN jedynie ukrywa adres IP użytkownika",
        "inline_explanation": "(Fałsz. Jest dokładnie odwrotnie: to VPN tworzy szyfrowany tunel dla całego ruchu, a Proxy często nie zapewnia szyfrowania)",
        "correct": false
      },
      {
        "text": "Client VPN szyfruje cały ruch sieciowy na poziomie systemu operacyjnego, natomiast serwer proxy działa zazwyczaj na poziomie aplikacji",
        "inline_explanation": "(VPN to \"globalny pancerz\" dla całego komputera, a Proxy to \"maska\" zakładana tylko np. na przeglądarkę)",
        "correct": true
      },
      {
        "text": "Techniki te są tożsame i nazwy te mogą być stosowane zamiennie",
        "inline_explanation": "(Fałsz. Różnią się warstwą działania w modelu OSI oraz poziomem bezpieczeństwa)",
        "correct": false
      },
      {
        "text": "VPN służy wyłącznie do łączenia oddziałów firmy, a proxy wyłącznie do użytku domowego",
        "inline_explanation": "(Fałsz. Client VPN jest powszechnie używany do ochrony prywatności konsumentów)",
        "correct": false
      },
      {
        "text": "Proxy wymaga instalacji sterownika wirtualnej karty sieciowej, a VPN konfiguruje się tylko w przeglądarce",
        "inline_explanation": "(Fałsz. To VPN instaluje wirtualny interfejs sieciowy w systemie)",
        "correct": false
      }
    ],
    "explanation": "Podstawowa różnica leży w **zakresie i szyfrowaniu**:\n\n1. **VPN (Virtual Private Network):** Przejmuje cały ruch z urządzenia (gry, system, przeglądarka), pakuje go w szyfrowany tunel. Gwarantuje prywatność i bezpieczeństwo.\n2. **Proxy:** Działa jako pośrednik (bramka). Zazwyczaj konfiguruje się go dla konkretnej aplikacji (np. tylko Firefox). Ukrywa IP, ale nie zawsze szyfruje dane."
  },
  {
    "id": 122,
    "question": "Zaznacz prawdziwe sformułowania. Listy sterowania dostępem (ACL):",
    "options": [
      {
        "text": "przeszukiwane są sekwencyjnie",
        "inline_explanation": "(Prawda. Router przetwarza listę od góry do dołu i zatrzymuje się na pierwszym dopasowaniu)",
        "correct": true
      },
      {
        "text": "wykonują wszystkie pasujące reguły z listy dla danego pakietu",
        "inline_explanation": "(Fałsz. Wykonywana jest tylko pierwsza pasująca reguła, reszta jest ignorowana)",
        "correct": false
      },
      {
        "text": "domyślnie przepuszczają cały ruch, jeśli nie znaleziono pasującej reguły",
        "inline_explanation": "(Fałsz. Standardem bezpieczeństwa jest 'Implicit Deny' - co nie jest dozwolone, jest zabronione)",
        "correct": false
      },
      {
        "text": "służą wyłącznie do uwierzytelniania użytkowników hasłem",
        "inline_explanation": "(Fałsz. ACL filtrują ruch sieciowy na podstawie adresów IP i portów, a nie tożsamości użytkownika)",
        "correct": false
      },
      {
        "text": "są przetwarzane w kolejności losowej",
        "inline_explanation": "(Fałsz. Kolejność wpisów jest kluczowa - ogólne reguły nie mogą zasłaniać tych bardziej szczegółowych)",
        "correct": false
      }
    ],
    "explanation": "Listy ACL (Access Control Lists) działają według zasady **First Match Wins** (Pierwsze trafienie wygrywa).\n\nRouter bierze pakiet i przykłada go do linijki nr 1. Pasuje? Wykonuje akcję (np. DENY) i kończy pracę. Nie pasuje? Idzie do linijki nr 2. \nJeśli dojdzie do końca listy i nic nie pasuje, stosowana jest ukryta reguła **Deny All** (odrzuć wszystko)."
  },
  {
    "id": 123,
    "question": "Który z wymienionych protokołów nie jest wykorzystywany w rozwiązaniach opartych na IPSec?",
    "options": [
      {
        "text": "SSL",
        "inline_explanation": "(To poprawna odpowiedź, ponieważ SSL/TLS to konkurencyjna technologia działająca w wyższej warstwie, np. w przeglądarkach, a nie w IPsec)",
        "correct": true
      },
      {
        "text": "AH",
        "inline_explanation": "(To integralna część IPsec zapewniająca uwierzytelnianie pakietów)",
        "correct": false
      },
      {
        "text": "ESP",
        "inline_explanation": "(To główny protokół IPsec odpowiedzialny za szyfrowanie danych)",
        "correct": false
      },
      {
        "text": "IKE",
        "inline_explanation": "(To mechanizm negocjacji kluczy używany do zestawienia tunelu IPsec)",
        "correct": false
      },
      {
        "text": "ISAKMP",
        "inline_explanation": "(To framework zarządzania asocjacjami bezpieczeństwa, na którym opiera się IKE w IPsec)",
        "correct": false
      }
    ],
    "explanation": "Architektura **IPsec** (Internet Protocol Security) działa w Warstwie 3 (Sieci) i składa się z trzech filarów: \n1. **AH** (Uwierzytelnianie nagłówka).\n2. **ESP** (Szyfrowanie ładunku).\n3. **IKE/ISAKMP** (Wymiana kluczy).\n\n**SSL** (Secure Sockets Layer) to technologia działająca wyżej (Warstwa 4/7), używana w rozwiązaniach typu SSL VPN (Clientless) lub HTTPS, co stanowi alternatywę dla IPsec."
  },
  {
    "id": 124,
    "question": "Który opis najlepiej definiuje cechę niezaprzeczalności (Non-repudiation) w bezpieczeństwie informacji?",
    "options": [
      {
        "text": "Zdolność unikania sytuacji niepożądanych, takich jak awaria serwera",
        "inline_explanation": "(to definicja Dostępności - Availability)",
        "correct": false
      },
      {
        "text": "Gwarancja, że nadawca nie może wyprzeć się faktu wysłania komunikatu",
        "inline_explanation": "(dzięki podpisowi cyfrowemu mamy matematyczny dowód autorstwa)",
        "correct": true
      },
      {
        "text": "Zapewnienie, że dane nie zostały zmodyfikowane w trakcie przesyłu",
        "inline_explanation": "(to definicja Integralności)",
        "correct": false
      },
      {
        "text": "Ukrywanie treści wiadomości przed osobami postronnymi",
        "inline_explanation": "(to definicja Poufności)",
        "correct": false
      },
      {
        "text": "Możliwość odtworzenia systemu po katastrofie",
        "inline_explanation": "(to Disaster Recovery)",
        "correct": false
      }
    ],
    "explanation": "Niezaprzeczalność to prawno-techniczna cecha, która wiąże podmiot z działaniem. \n Jeśli podpiszesz e-mail swoim certyfikatem kwalifikowanym, nie możesz potem powiedzieć w sądzie \"to nie ja wysłałem\". To jest **Non-repudiation**."
  },
  {
    "id": 125,
    "question": "Jako inżynier bezpieczeństwa infrastruktury uruchomionej w chmurze publicznej, zostałeś poinformowany, że klucz dostępu użytkownika został upubliczniony. Co musisz zrobić żeby ten klucz nie mógł być więcej używany. Dodatkowo należy uruchomić mechanizm, który pozwoli sprawdzić czy klucz został użyty do wykonania złośliwych działań. Jak to zrobić:",
    "options": [
      {
        "text": "Usuń użytkownika, przeanalizuj pliki logów zebrane we wszystkich regionach i przygotuj raport z nadużycia",
        "inline_explanation": "(To błąd. Usunięcie konta utrudnia analizę śledczą - tracisz informacje o przypisanych politykach i uprawnieniach. Należy celować w klucz, a nie w tożsamość użytkownika)",
        "correct": false
      },
      {
        "text": "Unieważnij (dezaktywuj) skompromitowany klucz dostępu oraz wykorzystaj usługę audytową (np. AWS CloudTrail) do analizy historii wywołań API",
        "inline_explanation": "(To jedyna poprawna procedura: natychmiastowe odcięcie dostępu poprzez dezaktywację klucza i analiza logów w celu oceny szkód)",
        "correct": true
      },
      {
        "text": "Zmień hasło do konsoli zarządzania dla tego użytkownika i zrestartuj wirtualne maszyny",
        "inline_explanation": "(Klucze dostępu API działają niezależnie od hasła do konsoli, więc zmiana hasła nie zatrzyma ataku z użyciem klucza)",
        "correct": false
      },
      {
        "text": "Skonfiguruj listę ACL, aby blokowała wszystkie adresy IP spoza sieci firmowej",
        "inline_explanation": "(Klucze API są często używane przez systemy zewnętrzne, a blokada IP może nie zadziałać, jeśli atakujący używa zmiennych adresów)",
        "correct": false
      },
      {
        "text": "Zignoruj zdarzenie, ponieważ klucze dostępu są automatycznie rotowane co 24 godziny",
        "inline_explanation": "(Fałsz. W większości chmur klucze dostępu są ważne bezterminowo, dopóki nie zostaną ręcznie wyłączone)",
        "correct": false
      }
    ],
    "explanation": "Prawidłowa ścieżka **Incident Response** w chmurze:\n1. **Powstrzymanie:** Nie usuwaj konta! Zamiast tego **dezaktywuj (Deactivate/Revoke)** wyciekły klucz Access Key. To natychmiast odcina atakującego, ale zachowuje konto do analizy.\n2. **Analiza:** Uruchom analizę logów (np. **CloudTrail** w AWS), aby zobaczyć, co atakujący zrobił przy użyciu tego klucza (np. czy utworzył nowe instancje do kopania kryptowalut)."
  },
  {
    "id": 126,
    "question": "W odniesieniu do modelu współdzielonej odpowiedzialności za bezpieczeństwo w chmurze publicznej, zaznacz komponenty, których bezpieczeństwo leży w gestii użytkownika chmury:",
    "options": [
      {
        "text": "Aktualizacja systemów operacyjnych",
        "inline_explanation": "(Prawda w modelu IaaS. Dostawca zapewnia sprzęt, ale to klient musi instalować łatki bezpieczeństwa w swoim Windows/Linux)",
        "correct": true
      },
      {
        "text": "Fizyczna ochrona serwerowni i kontrola dostępu do budynku",
        "inline_explanation": "(Fałsz. To zawsze leży po stronie dostawcy chmury - 'Security OF the Cloud')",
        "correct": false
      },
      {
        "text": "Wymiana uszkodzonych podzespołów sprzętowych (dysków, zasilaczy)",
        "inline_explanation": "(Fałsz. Klient nie ma fizycznego dostępu do infrastruktury)",
        "correct": false
      },
      {
        "text": "Zarządzanie warstwą wirtualizacji (Hypervisor)",
        "inline_explanation": "(Fałsz. Izolacja między maszynami wirtualnymi to odpowiedzialność dostawcy)",
        "correct": false
      },
      {
        "text": "Zarządzanie tożsamością, dostępem (IAM) oraz szyfrowaniem danych",
        "inline_explanation": "(Prawda. To klient decyduje, kto ma dostęp do danych i czy są one zaszyfrowane)",
        "correct": true
      }
    ],
    "explanation": "Model współdzielonej odpowiedzialności dzieli zadania na dwie grupy:\n\n1. **Dostawca (AWS/Azure/GCP):** Odpowiada za bezpieczeństwo **SAMEJ CHMURY** (budynki, prąd, kable, serwery fizyczne, hypervisor).\n2. **Klient (Ty):** Odpowiada za bezpieczeństwo **W CHMURZE** (aktualizacja systemu operacyjnego, konfiguracja Firewalla, szyfrowanie danych, zarządzanie kontami użytkowników)."
  },
  {
    "id": 127,
    "question": "Wysoka dostępność HA (High Availability) charakteryzuje systemy:",
    "options": [
      {
        "text": "dla których zadowalający czas pracy operacyjnej przekracza 90%",
        "inline_explanation": "(Fałsz. 90% dostępności to ponad miesiąc przestoju w roku. HA celuje w 99,9% i więcej)",
        "correct": false
      },
      {
        "text": "zaprojektowane w celu zminimalizowania czasu przestoju (downtime) poprzez zastosowanie nadmiarowości (redundancji)",
        "inline_explanation": "(Prawda. Kluczem jest dublowanie elementów, aby awaria jednego nie zatrzymała całego systemu)",
        "correct": true
      },
      {
        "text": "które gwarantują 100% bezpieczeństwo danych przed atakami hakerskimi",
        "inline_explanation": "(Fałsz. Dostępność to nie to samo co poufność czy integralność; system HA może nadal zostać zhakowany)",
        "correct": false
      },
      {
        "text": "posiadające pojedynczy punkt awarii (SPOF) w celu oszczędności kosztów",
        "inline_explanation": "(Fałsz. HA polega właśnie na eliminacji Single Point of Failure)",
        "correct": false
      },
      {
        "text": "działające w trybie klastra (np. Active-Passive lub Active-Active)",
        "inline_explanation": "(Prawda. Klastrowanie to najczęstsza metoda osiągania wysokiej dostępności)",
        "correct": true
      }
    ],
    "explanation": "High Availability (HA) to systemy zaprojektowane tak, aby działały niemal bez przerwy.\n\nMatematyka dostępności:\n* **90% (jedna dziewiątka):** 36,5 dnia przestoju rocznie (Brak HA).\n* **99% (dwie dziewiątki):** 3,65 dnia przestoju rocznie.\n* **99,9% (trzy dziewiątki):** 8 godzin przestoju rocznie (Podstawowe HA).\n* **99,999% (pięć dziewiątek):** 5 minut przestoju rocznie (Standard telekomunikacyjny/bankowy)."
  },
  {
    "id": 128,
    "question": "Dobrą praktyką zapewniania bezpieczeństwa w chmurze jest:",
    "options": [
      {
        "text": "Bazowanie wyłącznie na własnych mechanizmach, ignorując narzędzia dostawcy",
        "inline_explanation": "(błąd; natywne narzędzia chmurowe są lepiej zintegrowane i skalowalne)",
        "correct": false
      },
      {
        "text": "Stosowanie zasady najmniejszych przywilejów (Least Privilege) w IAM",
        "inline_explanation": "(użytkownik/aplikacja ma tylko takie uprawnienia, jakie są niezbędne do działania, i nic więcej)",
        "correct": true
      },
      {
        "text": "Publiczne udostępnianie zasobników (S3 Buckets) dla ułatwienia pracy deweloperom",
        "inline_explanation": "(to jedna z najczęstszych przyczyn wycieków danych w chmurze)",
        "correct": false
      },
      {
        "text": "Używanie konta głównego (Root Account) do codziennych zadań administracyjnych",
        "inline_explanation": "(konto root powinno być zabezpieczone MFA i używane tylko w sytuacjach awaryjnych)",
        "correct": false
      },
      {
        "text": "Wyłączenie logowania audytowego (np. CloudTrail) w celu oszczędności miejsca",
        "inline_explanation": "(logi są niezbędne do analizy incydentów i compliance)",
        "correct": false
      }
    ],
    "explanation": "Bezpieczeństwo w chmurze opiera się na wielu warstwach. Zasada **Least Privilege** jest fundamentalna: jeśli aplikacja potrzebuje tylko czytać z bazy, nie dajemy jej uprawnień do zapisu ani do kasowania serwerów. Ogranicza to zasięg szkód w przypadku włamania (Lateral Movement)."
  },
  {
    "id": 129,
    "question": "Które zdania na temat szyfrowania danych przesyłanych przez sieć w celu przechowywania ich w chmurze publicznej są prawdziwe?",
    "options": [
      {
        "text": "Szyfrowanie jest możliwe tylko przy użyciu kluczy dostarczonych przez operatora chmury",
        "inline_explanation": "(fałsz, można używać własnych kluczy w modelu BYOK - Bring Your Own Key)",
        "correct": false
      },
      {
        "text": "Dane mogą być szyfrowane po stronie klienta (Client-side Encryption) przed wysłaniem",
        "inline_explanation": "(wtedy operator chmury widzi tylko zaszyfrowany blob i nie ma dostępu do treści)",
        "correct": true
      },
      {
        "text": "Szyfrowanie danych w chmurze jest niemożliwe ze względu na spadek wydajności",
        "inline_explanation": "(współczesne procesory sprzętowo wspierają szyfrowanie np. AES-NI, narzut jest pomijalny)",
        "correct": false
      },
      {
        "text": "Protokoły takie jak HTTPS/TLS są zbędne wewnątrz sieci VPC operatora",
        "inline_explanation": "(model Zero Trust zakłada szyfrowanie wszędzie, nawet w sieci wewnętrznej)",
        "correct": false
      },
      {
        "text": "Szyfrowanie chroni dane przed usunięciem",
        "inline_explanation": "(szyfrowanie chroni poufność, a nie dostępność; zaszyfrowany plik nadal można skasować)",
        "correct": false
      }
    ],
    "explanation": "Mamy dwa modele: \n 1. **Server-Side Encryption:** Chmura szyfruje dane po odebraniu (chroni przed kradzieżą dysków w data center). \n 2. **Client-Side Encryption:** Użytkownik szyfruje dane u siebie. To daje pełną kontrolę - nawet operator chmury ani rząd nie odczytają danych bez klucza, który posiada tylko klient."
  },
  {
    "id": 130,
    "question": "Zaznacz prawdziwe zdania dotyczące obiektowego przechowywania danych w chmurze publicznej:",
    "options": [
      {
        "text": "Ze względów bezpieczeństwa nie ma możliwości przechowywania wielu wersji tych samych obiektów",
        "inline_explanation": "(Fałsz. Jest wręcz przeciwnie – mechanizm Versioning pozwala przechowywać historię zmian pliku, co chroni przed ransomware i przypadkowym usunięciem)",
        "correct": false
      },
      {
        "text": "Dane przechowywane są w płaskiej strukturze (tzw. buckets/kontenery) i identyfikowane unikalnym kluczem, a nie w hierarchii katalogów",
        "inline_explanation": "(Prawda. W Object Storage nie ma fizycznych folderów, są tylko kontenery i obiekty)",
        "correct": true
      },
      {
        "text": "Jest to rozwiązanie optymalizowane pod kątem instalacji systemów operacyjnych i baz danych",
        "inline_explanation": "(Fałsz. Do systemów operacyjnych używa się Block Storage. Object Storage ma zbyt duże opóźnienia)",
        "correct": false
      },
      {
        "text": "Obiekty są zazwyczaj niezmienne (immutable) – edycja pliku wymaga nadpisania go w całości nową wersją",
        "inline_explanation": "(Prawda. Nie można edytować jednego bajtu w środku pliku na S3; trzeba wysłać cały plik od nowa)",
        "correct": true
      },
      {
        "text": "Pozwala na przechowywanie ogromnych ilości nieustrukturyzowanych danych (np. zdjęcia, filmy, backupy) przy niskich kosztach",
        "inline_explanation": "(Prawda. To główne zastosowanie tej technologii)",
        "correct": true
      }
    ],
    "explanation": "Magazyn Obiektowy (np. AWS S3, Azure Blob) to nie to samo co dysk twardy.\n\n1. **Wersjonowanie:** Możesz mieć plik `raport.pdf` w wersji 1, 2 i 3. Jeśli usuniesz go 'permanentnie', wciąż możesz odzyskać starą wersję (jeśli funkcja jest włączona).\n2. **Struktura:** Nie ma tu systemu plików (NTFS/ext4). Każdy plik to 'Obiekt' z metadanymi, wrzucony do wielkiego worka zwanego 'Bucket'."
  },
  {
    "id": 131,
    "question": "Zaznacz prawdziwe zdania dotyczące bezpieczeństwa baz danych powoływanych w chmurze publicznej:",
    "options": [
      {
        "text": "Korzystanie z usługi baz danych świadczonej przez operatora chmury zwalnia użytkownika z obowiązku zabezpieczania bazy danych zgodnie z modelem współdzielonej odpowiedzialności",
        "inline_explanation": "(fałsz, dostawca dba o infrastrukturę, ale to klient decyduje, kto ma hasło do bazy)",
        "correct": false
      },
      {
        "text": "Użytkownik nadal odpowiada za zarządzanie uprawnieniami (kto ma dostęp), szyfrowanie danych i ich klasyfikację",
        "inline_explanation": "(zgodnie z modelem współdzielonej odpowiedzialności w PaaS)",
        "correct": true
      },
      {
        "text": "Operator chmury automatycznie decyduje, którzy pracownicy firmy mają dostęp do konkretnych tabel",
        "inline_explanation": "(operator nie zna struktury organizacyjnej klienta ani jego polityki dostępu)",
        "correct": false
      },
      {
        "text": "Bazy danych w chmurze są domyślnie publicznie dostępne dla całego Internetu",
        "inline_explanation": "(domyślnie są izolowane w sieci prywatnej VPC i nie mają publicznego adresu IP)",
        "correct": false
      },
      {
        "text": "W modelu PaaS użytkownik musi samodzielnie instalować poprawki bezpieczeństwa systemu operacyjnego serwera bazy",
        "inline_explanation": "(w PaaS robi to dostawca; w IaaS robiłby to klient)",
        "correct": false
      }
    ],
    "explanation": "W usługach zarządzanych (PaaS) dostawca dba o \"hydraulikę\" (sprzęt, OS, silnik bazy). \n  \n Jednak to **klient** decyduje, co wlewa do tej bazy i komu pozwala z niej czerpać. Odpowiedzialność za **dane** i **dostęp** zawsze leży po stronie klienta."
  },
  {
    "id": 132,
    "question": "Ze względów bezpieczeństwa, sieć zarządzająca i sieć produkcyjna w środowisku zwirtualizowanym powinny być:",
    "options": [
      {
        "text": "połączone w jedną wspólną sieć tak aby ramki rozgłaszane mogły dotrzeć do każdej karty sieciowej w obrębie Centrum Danych",
        "inline_explanation": "(to błąd krytyczny; atak na publiczną aplikację webową dałby atakującemu dostęp do paneli administracyjnych)",
        "correct": false
      },
      {
        "text": "ściśle odseparowane od siebie (np. oddzielne VLAN-y, osobne fizyczne karty sieciowe)",
        "inline_explanation": "(izolacja sprawia, że kompromitacja maszyny wirtualnej nie zagraża infrastrukturze zarządzającej)",
        "correct": true
      },
      {
        "text": "dostępne publicznie z Internetu bez konieczności stosowania VPN",
        "inline_explanation": "(interfejsy zarządzające jak vCenter czy SSH nigdy nie powinny być wystawione do sieci publicznej)",
        "correct": false
      },
      {
        "text": "skonfigurowane tak, aby ruch produkcyjny miał priorytet nad zarządzającym",
        "inline_explanation": "(często jest odwrotnie - utrata kontroli nad klastrem jest groźniejsza niż spowolnienie aplikacji)",
        "correct": false
      },
      {
        "text": "obsługiwane przez ten sam serwer DHCP w tej samej podsieci",
        "inline_explanation": "(łamie zasadę separacji)",
        "correct": false
      }
    ],
    "explanation": "Złota zasada bezpieczeństwa infrastruktury: **Separacja**. \n Ruch administracyjny (logowanie do hiperwizora, vMotion, Storage) musi być odizolowany od ruchu \"brudnego\" (aplikacje dostępne dla klientów). Dzięki temu, nawet jeśli haker przejmie serwer WWW, nie dostanie się do panelu sterowania całą chmurą."
  },
  {
    "id": 133,
    "question": "Migracja maszyn wirtualnych na żywo jest wykonywana w sytuacji:",
    "options": [
      {
        "text": "przeciążenia serwera (hosta) wirtualizacyjnego",
        "inline_explanation": "(maszyny są przenoszone na mniej obciążone hosty, by wyrównać wydajność)",
        "correct": true
      },
      {
        "text": "wykrycia ataku hakerskiego na maszynę wirtualną",
        "inline_explanation": "(systemy wirtualizacji rzadko mają taką logikę; to rola IPS/IDS)",
        "correct": false
      },
      {
        "text": "gdy maszyna wirtualna jest wyłączona",
        "inline_explanation": "(vMotion dotyczy działających maszyn; wyłączone po prostu się uruchamia gdzie indziej)",
        "correct": false
      },
      {
        "text": "w celu zwiększenia pojemności wirtualnego dysku",
        "inline_explanation": "(to operacja na pamięci masowej - Storage vMotion - ale nie wynika z obciążenia CPU/RAM)",
        "correct": false
      },
      {
        "text": "podczas instalacji aktualizacji w systemie gościa",
        "inline_explanation": "(aktualizacja OS wewnątrz VM nie wymaga przenoszenia jej na inny host)",
        "correct": false
      }
    ],
    "explanation": "Migracja na żywo pozwala przenieść działającą maszynę między serwerami bez przerywania jej pracy (użytkownik nie zauważa różnicy). \n Stosuje się ją głównie do: \n 1. **Balansowania obciążenia (DRS):** Gdy jeden serwer się poci, przenosimy VM tam, gdzie jest luźniej. \n 2. **Konserwacji (Maintenance Mode):** Gdy administrator musi wyłączyć fizyczny serwer (np. by dołożyć RAM), \"ewakuuje\" z niego maszyny."
  },
  {
    "id": 134,
    "question": "Zaznacz zdania prawdziwe dotyczące bezpieczeństwa maszyn wirtualnych powoływanych w chmurze publicznej:",
    "options": [
      {
        "text": "Odpowiedzialnością klienta usług chmurowych jest odpowiednia konfiguracja mechanizmów bezpieczeństwa na poziomie nadzorcy wirtualizacji (hypervisor)",
        "inline_explanation": "(Fałsz. Hypervisor jest zarządzany wyłącznie przez dostawcę chmury - to Security OF the Cloud. Klient nie ma do niego dostępu)",
        "correct": false
      },
      {
        "text": "Klient ponosi pełną odpowiedzialność za aktualizację i łatanie systemu operacyjnego (Guest OS) zainstalowanego na maszynie",
        "inline_explanation": "(Prawda. W modelu IaaS dostawca daje 'czysty' system, a dbanie o łatki to zadanie klienta)",
        "correct": true
      },
      {
        "text": "Domyślnie dostawca chmury tworzy kopie zapasowe danych wewnątrz maszyny wirtualnej",
        "inline_explanation": "(Fałsz. Backup danych i konfiguracja snapshotów leży w gestii klienta; dostawca dba tylko o trwałość samej infrastruktury)",
        "correct": false
      },
      {
        "text": "Należy skonfigurować sieciowe grupy bezpieczeństwa (Security Groups), aby ograniczyć ruch przychodzący tylko do niezbędnych portów",
        "inline_explanation": "(Prawda. To wirtualny firewall przed maszyną, za którego konfigurację odpowiada klient)",
        "correct": true
      },
      {
        "text": "Dostawca chmury automatycznie szyfruje wszystkie dane w pamięci RAM maszyny wirtualnej klienta",
        "inline_explanation": "(Fałsz. Choć istnieją technologie Confidential Computing, standardowo pamięć RAM jest w stanie jawnym dla procesora, a szyfrowanie spoczynkowe dotyczy dysków)",
        "correct": false
      }
    ],
    "explanation": "Bezpieczeństwo maszyny wirtualnej (EC2/VM) w chmurze dzieli się grubą kreską:\n\n1. **Podłoga (Dostawca):** Sprzęt, prąd, kable i **Hypervisor**. Ty tego nie dotykasz.\n2. **Meble (Ty):** System operacyjny (Windows/Linux), Firewall, Aplikacje, Dane. Jeśli zostawisz otwarte drzwi (porty) lub nie zaktualizujesz Windowsa, włamanie jest Twoją winą."
  },
  {
    "id": 135,
    "question": "Ograniczanie, przez klienta chmury publicznej, dostępu do metadanych maszyny wirtualnej procesom systemu operacyjnego:",
    "options": [
      {
        "text": "Nie jest konieczne, ponieważ to operator chmury jest odpowiedzialny za metadane maszyn wirtualnych.",
        "inline_explanation": "(Fałsz. Operator udostępnia usługę metadanych dla wygody, ale to klient odpowiada za to, czy jego aplikacja nie udostępni tych danych hakerowi)",
        "correct": false
      },
      {
        "text": "Jest kluczowe dla ochrony przed atakami typu SSRF (Server-Side Request Forgery), które mogą doprowadzić do kradzieży poświadczeń IAM",
        "inline_explanation": "(Prawda. W metadanych często znajdują się tymczasowe klucze dostępu dla roli przypisanej do maszyny)",
        "correct": true
      },
      {
        "text": "Można zrealizować poprzez wymuszenie autoryzacji tokenem (np. IMDSv2 w AWS) lub reguły lokalnego firewalla (iptables)",
        "inline_explanation": "(Prawda. Nowsze standardy wymagają pobrania tokenu sesji, co utrudnia proste ataki SSRF)",
        "correct": true
      },
      {
        "text": "Spowoduje całkowite odcięcie maszyny wirtualnej od Internetu",
        "inline_explanation": "(Fałsz. Serwis metadanych działa na adresie lokalnym Link-Local 169.254.169.254 i jest niezależny od wyjścia na świat)",
        "correct": false
      },
      {
        "text": "Jest niemożliwe, ponieważ system operacyjny przestanie się bootować",
        "inline_explanation": "(Fałsz. System operacyjny działa poprawnie bez dostępu do metadanych po zakończeniu wstępnej inicjalizacji)",
        "correct": false
      }
    ],
    "explanation": "Każda maszyna w chmurze ma dostęp do 'magicznego' adresu IP (zazwyczaj `169.254.169.254`), pod którym serwowane są **Instance Metadata**.\n\nMożna tam znaleźć:\n1. Adres IP maszyny.\n2. Nazwę hosta.\n3. **Klucze dostępowe (Credentials)** do innych usług chmurowych!\n\nJeśli Twoja aplikacja ma lukę (SSRF) i haker zmusi ją do odczytania tego adresu, ukradnie tożsamość Twojej maszyny. Dlatego ograniczenie tego dostępu (lub wymuszenie IMDSv2) to obowiązek klienta."
  },
  {
    "id": 136,
    "question": "Bezpieczeństwo danych w środowisku zwirtualizowanym zapewniają mechanizmy:",
    "options": [
      {
        "text": "replikacji danych",
        "inline_explanation": "(Prawda. Utrzymywanie kopii danych w wielu lokalizacjach chroni przed ich utratą w wyniku awarii sprzętu - realizuje postulat Dostępności)",
        "correct": true
      },
      {
        "text": "izolacji logicznej maszyn wirtualnych",
        "inline_explanation": "(Prawda. Hypervisor musi gwarantować, że jedna maszyna nie może odczytać pamięci RAM ani dysku innej maszyny)",
        "correct": true
      },
      {
        "text": "szyfrowania wolumenów wirtualnych (Data at Rest)",
        "inline_explanation": "(Prawda. Jeśli ktoś ukradnie fizyczny dysk z serwerowni, dane pozostaną nieczytelne bez klucza)",
        "correct": true
      },
      {
        "text": "współdzielenia schowka (clipboard sharing) pomiędzy gospodarzem a gościem",
        "inline_explanation": "(Fałsz. To funkcja wygody, która często jest wyłączana w bezpiecznych środowiskach, bo zwiększa ryzyko wycieku danych)",
        "correct": false
      },
      {
        "text": "publicznego udostępniania snapshotów dysków",
        "inline_explanation": "(Fałsz. To prosta droga do wycieku wrażliwych danych zawartych w obrazie systemu)",
        "correct": false
      }
    ],
    "explanation": "Bezpieczeństwo danych w chmurze/wirtualizacji opiera się na trzech filarach (CIA):\n1. **Poufność:** Izolacja i Szyfrowanie (nikt nie podgląda).\n2. **Integralność:** Sumy kontrolne i Snapshoty (nikt nie zmienia).\n3. **Dostępność:** **Replikacja** (gdy jeden dysk padnie, dane są bezpieczne na drugim). Replikacja to nie to samo co backup, ale jest kluczowa dla ciągłości działania."
  },
  {
    "id": 137,
    "question": "Uwierzytelnianie użytkowników chmury publicznej może odbywać się:",
    "options": [
      {
        "text": "Wyłącznie na podstawie klucza nadanego przez operatora.",
        "inline_explanation": "(Fałsz. Słowo 'wyłącznie' dyskwalifikuje tę odpowiedź. Chmury wspierają hasła, MFA, SSO, certyfikaty i wiele innych metod)",
        "correct": false
      },
      {
        "text": "W oparciu o federację tożsamości (Identity Federation), wykorzystując istniejące konta firmowe (np. z Active Directory)",
        "inline_explanation": "(Prawda. Dzięki temu pracownik nie musi zapamiętywać nowego hasła, loguje się kontem domenowym)",
        "correct": true
      },
      {
        "text": "Przy użyciu uwierzytelniania wieloskładnikowego (MFA), łączącego hasło z kodem z tokena lub aplikacji",
        "inline_explanation": "(Prawda. To zalecany standard bezpieczeństwa dla kont root i administratorów)",
        "correct": true
      },
      {
        "text": "Poprzez weryfikację adresu MAC karty sieciowej użytkownika bez podawania hasła",
        "inline_explanation": "(Fałsz. Adres MAC łatwo sfałszować i nie jest on przesyłany przez Internet poza lokalny router, więc chmura go nie widzi)",
        "correct": false
      },
      {
        "text": "Tylko i wyłącznie z poziomu fizycznej konsoli w serwerowni dostawcy",
        "inline_explanation": "(Fałsz. Ideą chmury jest dostęp zdalny przez Internet z dowolnego miejsca)",
        "correct": false
      }
    ],
    "explanation": "Uwierzytelnianie w chmurze jest bardzo elastyczne. Możemy wyróżnić:\n1. **Ludzi:** Logują się przez Console (GUI) używając Hasła + MFA lub przez SSO (Federację).\n2. **Maszyny/Skrypty:** Logują się przez API używając Access Key ID + Secret Access Key.\n\nTwierdzenie, że istnieje 'wyłącznie' jedna metoda, jest fałszywe."
  },
  {
    "id": 138,
    "question": "Zaznacz zdania prawdziwe w kontekście zapewniania dostępu do chmury publicznej:",
    "options": [
      {
        "text": "Istnieje możliwość zestawienia wielu połączeń VPN z różnych lokalizacji użytkownika (on-prem) do jednej wirtualnej sieci prywatnej",
        "inline_explanation": "(Prawda. Bramy VPN w chmurze obsługują wiele tuneli jednocześnie, co pozwala połączyć np. centralę i oddziały terenowe z jedną siecią VPC)",
        "correct": true
      },
      {
        "text": "Jedyną metodą dostępu do zasobów prywatnych w chmurze jest przypisanie im publicznych adresów IP",
        "inline_explanation": "(Fałsz. To zła praktyka. Do zasobów prywatnych dostajemy się bezpiecznie właśnie przez VPN lub dedykowane łącza)",
        "correct": false
      },
      {
        "text": "Klient ma możliwość fizycznego podłączenia własnych światłowodów bezpośrednio do szaf serwerowych w centrum danych dostawcy chmury",
        "inline_explanation": "(Fałsz. Ze względów bezpieczeństwa klienci nie mają wstępu do serwerowni. Fizyczne łącza realizuje się przez partnerów w lokalizacjach pośrednich - colocation)",
        "correct": false
      },
      {
        "text": "Połączenia VPN wykorzystują publiczny Internet jako medium transmisyjne, ale szyfrują przesyłane dane",
        "inline_explanation": "(Prawda. To główna cecha VPN – tworzenie bezpiecznego tunelu wewnątrz niezaufanej sieci publicznej)",
        "correct": true
      },
      {
        "text": "Użycie dedykowanego łącza prywatnego (np. AWS Direct Connect, Azure ExpressRoute) wyklucza możliwość korzystania z VPN jako łącza zapasowego",
        "inline_explanation": "(Fałsz. Standardem w architekturze korporacyjnej jest posiadanie szybkiego łącza dedykowanego i zapasowego tunelu VPN na wypadek awarii światłowodu)",
        "correct": false
      }
    ],
    "explanation": "Dostęp do chmury (Connectivity) można realizować na 3 główne sposoby:\n1. **Publiczny Internet:** Najmniej bezpieczne, chyba że szyfrowane (HTTPS/SSH).\n2. **VPN (Site-to-Site):** Tunel szyfrowany przez Internet. Możesz podłączyć wiele biur do jednej sieci w chmurze (tzw. topologia Hub-and-Spoke).\n3. **Dedykowane łącze (Direct Connect/ExpressRoute):** Fizyczny kabel omijający publiczny Internet. Najbezpieczniejsze i najstabilniejsze."
  },
  {
    "id": 139,
    "question": "Które z poniższych stwierdzeń dotyczą ataków typu \"Blind\"?",
    "options": [
      {
        "text": "Ataki te polegają na wykorzystaniu mechanizmu \"out-of-band\" do przesyłania danych za pośrednictwem innego kanału",
        "inline_explanation": "(Prawda. Skoro aplikacja nie wyświetla danych na ekranie, atakujący zmusza ją do wysłania ich np. w zapytaniu DNS do serwera, który kontroluje)",
        "correct": true
      },
      {
        "text": "Atakujący otrzymuje pełne komunikaty błędów bazy danych bezpośrednio w odpowiedzi HTTP",
        "inline_explanation": "(Fałsz. Jeśli widać komunikaty błędów, jest to atak typu 'Error-based', a nie 'Blind')",
        "correct": false
      },
      {
        "text": "Wymagają one wnioskowania o danych na podstawie zachowania aplikacji, np. czasu odpowiedzi serwera",
        "inline_explanation": "(Prawda. To tzw. Time-based Blind Injection - np. 'jeśli pierwsza litera hasła to A, odczekaj 10 sekund')",
        "correct": true
      },
      {
        "text": "Są niemożliwe do przeprowadzenia, jeśli aplikacja nie zwraca żadnych danych do przeglądarki",
        "inline_explanation": "(Fałsz. Właśnie do takich sytuacji stworzono techniki Blind)",
        "correct": false
      },
      {
        "text": "Dotyczą wyłącznie ataków socjotechnicznych na osoby niedowidzące",
        "inline_explanation": "(Fałsz. Nazwa 'Blind' odnosi się do braku widocznej odpowiedzi systemu, a nie do wzroku użytkownika)",
        "correct": false
      }
    ],
    "explanation": "Ataki **Blind (Ślepe)** stosuje się, gdy aplikacja jest zabezpieczona przed wyświetlaniem błędów, ale nadal wykonuje złośliwy kod.\n\nSkoro haker nie widzi wyniku `SELECT password FROM users`, ma dwie drogi:\n1. **Zadawanie pytań T/N:** \"Czy pierwsza litera to A?\" -> Jeśli tak, strona ładuje się wolniej (Time-based).\n2. **Out-of-Band (OOB):** \"Jeśli pierwsza litera to A, wyślij ping do mojego serwera\". Wymuszona odpowiedź dotyczy tej drugiej metody."
  },
  {
    "id": 140,
    "question": "Jakie są główne sposoby zabezpieczania przed atakami SQL injection?",
    "options": [
      {
        "text": "Zastosowanie mechanizmów szyfrowania danych w bazie danych.",
        "inline_explanation": "(Fałsz. Szyfrowanie chroni dane spoczynkowe, ale nie zapobiega wstrzyknięciu złośliwego polecenia. Jeśli aplikacja ma uprawnienia do odszyfrowania danych, haker też je odczyta)",
        "correct": false
      },
      {
        "text": "Stosowanie zapytań parametryzowanych (Prepared Statements) w kodzie aplikacji",
        "inline_explanation": "(Prawda. To najskuteczniejsza metoda. Oddziela ona treść zapytania SQL od danych wprowadzonych przez użytkownika, traktując te drugie zawsze jako zwykły tekst, a nie kod)",
        "correct": true
      },
      {
        "text": "Walidacja i sanityzacja danych wejściowych (Input Validation)",
        "inline_explanation": "(Prawda. Sprawdzanie, czy w polu 'wiek' jest liczba, a nie skrypt, to ważna linia obrony 'Defense in Depth')",
        "correct": true
      },
      {
        "text": "Ukrywanie komunikatów błędów bazy danych przed użytkownikiem",
        "inline_explanation": "(Fałsz. To tylko utrudnia atak (zapobiega Error-based SQLi), ale nie łata samej dziury. Hakerzy mogą nadal użyć metody Blind SQLi)",
        "correct": false
      },
      {
        "text": "Instalacja certyfikatu SSL/TLS na serwerze WWW",
        "inline_explanation": "(Fałsz. Szyfrowanie transmisji (HTTPS) chroni przed podsłuchem, ale złośliwy kod SQL dotrze do bazy danych w bezpiecznym, zaszyfrowanym tunelu)",
        "correct": false
      }
    ],
    "explanation": "Atak SQL Injection polega na tym, że haker wpisuje fragment kodu (np. `' OR '1'='1`) w pole formularza, a baza danych wykonuje to jako rozkaz.\n\nJedynym skutecznym sposobem obrony jest **Parametryzacja (Prepared Statements)**. Działa to jak poinformowanie bazy danych: \"Oto szablon zapytania, a to co wpisał użytkownik to tylko głupi tekst, nie próbuj tego wykonywać\"."
  },
  {
    "id": 141,
    "question": "Ciasteczko, które potrafi odtworzyć się po usunięciu, to:",
    "options": [
      {
        "text": "Persistent Cookie",
        "inline_explanation": "(Fałsz. To standardowe 'ciasteczko trwałe'. Przeżywa zamknięcie przeglądarki, ale znika bezpowrotnie, gdy użytkownik ręcznie wyczyści historię)",
        "correct": false
      },
      {
        "text": "Zombie Cookie",
        "inline_explanation": "(Prawda. Wykorzystuje ukryte mechanizmy - np. Flash LSO, HTML5 Storage, ETag - aby automatycznie odtworzyć się po usunięciu standardowego pliku cookie)",
        "correct": true
      },
      {
        "text": "Session Cookie",
        "inline_explanation": "(Fałsz. To najmniej trwały typ - jest usuwane natychmiast po zamknięciu karty lub przeglądarki)",
        "correct": false
      },
      {
        "text": "Secure Cookie",
        "inline_explanation": "(Fałsz. Flaga 'Secure' oznacza tylko tyle, że ciasteczko jest przesyłane wyłącznie przez szyfrowane połączenie HTTPS)",
        "correct": false
      },
      {
        "text": "HttpOnly Cookie",
        "inline_explanation": "(Fałsz. Ta flaga zapobiega dostępowi do ciasteczka przez JavaScript (ochrona przed XSS), ale nie chroni przed usunięciem)",
        "correct": false
      }
    ],
    "explanation": "Istnieje różnica między ciasteczkiem, które 'długo żyje', a takim, które 'zmartwychwstaje':\n\n1. **Persistent Cookie:** Ma datę ważności w przyszłości (np. rok). Pamięta Cię po restarcie komputera. Ale jeśli je usuniesz - koniec.\n2. **Zombie Cookie:** To agresywna technika śledząca. Ukrywa kopię zapasową danych w innym miejscu (np. w pamięci podręcznej przeglądarki). Gdy usuniesz normalne ciasteczko, skrypt na stronie zauważa brak i odtwarza je z kopii zapasowej."
  },
  {
    "id": 142,
    "question": "Co może zrobić użytkownik, by realnie uchronić się od podatności CSRF?",
    "options": [
      {
        "text": "korzystać tylko ze stron używających protokołu HTTPS",
        "inline_explanation": "(Fałsz. HTTPS chroni przed podsłuchem, ale nie przed atakiem CSRF. Można bezpiecznie wysłać sfałszowane żądanie przez szyfrowany kanał)",
        "correct": false
      },
      {
        "text": "wylogowywać się z ważnych serwisów (np. banku) po zakończeniu pracy i nie używać funkcji 'zapamiętaj mnie'",
        "inline_explanation": "(Prawda. CSRF wymaga aktywnej sesji zalogowanego użytkownika. Brak sesji = brak ataku)",
        "correct": true
      },
      {
        "text": "używać innej przeglądarki do bankowości, a innej do przeglądania stron rozrywkowych",
        "inline_explanation": "(Prawda. Izolacja sesji w różnych przeglądarkach uniemożliwia przesłanie złośliwego żądania między nimi)",
        "correct": true
      },
      {
        "text": "regularnie zmieniać hasła do kont",
        "inline_explanation": "(Fałsz. To dobra praktyka, ale nie chroni przed CSRF, który wykorzystuje bieżącą, aktywną sesję, a nie znajomość hasła)",
        "correct": false
      },
      {
        "text": "wyłączyć obsługę JavaScript w przeglądarce",
        "inline_explanation": "(Fałsz. Choć utrudnia to atak, CSRF można wykonać prostym formularzem HTML lub obrazkiem, bez użycia JS)",
        "correct": false
      }
    ],
    "explanation": "CSRF (Cross-Site Request Forgery) polega na tym, że atakujący zmusza Twoją przeglądarkę do wykonania akcji w serwisie, w którym jesteś aktualnie zalogowany (np. \"Przelej 100 zł\").\n\nJako użytkownik masz małe pole manewru (to serwer powinien się bronić tokenami Anti-CSRF). Jedyne co możesz zrobić, to **nie klikać w podejrzane linki** i **wylogowywać się** z ważnych stron."
  },
  {
    "id": 143,
    "question": "Czym jest Code Injection?",
    "options": [
      {
        "text": "Procesem wykorzystywanym do optymalizacji wydajności programu poprzez ograniczenie zbędnego kodu",
        "inline_explanation": "(Fałsz. To brzmi jak 'Refaktoryzacja' lub 'Minifikacja'. Code Injection to groźny atak)",
        "correct": false
      },
      {
        "text": "Techniką ataku polegającą na wprowadzeniu złośliwego kodu, który jest następnie wykonywany przez aplikację",
        "inline_explanation": "(Prawda. Atakujący wykorzystuje luki w walidacji danych, aby wstrzyknąć np. kod PHP, Python lub Shell, przejmując kontrolę nad serwerem)",
        "correct": true
      },
      {
        "text": "Metodą automatycznego generowania kodu źródłowego przez narzędzia AI",
        "inline_explanation": "(Fałsz. To 'Code Generation', a nie Injection)",
        "correct": false
      },
      {
        "text": "Wstrzyknięciem stylów CSS w celu zmiany wyglądu strony",
        "inline_explanation": "(Fałsz. To byłby atak typu CSS Injection lub Defacement, Code Injection zazwyczaj odnosi się do kodu wykonywalnego po stronie serwera)",
        "correct": false
      },
      {
        "text": "Legalną techniką stosowaną przez programistów do aktualizacji oprogramowania bez restartu (Hot patching)",
        "inline_explanation": "(Fałsz. Choć technicznie podobne, w kontekście bezpieczeństwa termin ten oznacza atak)",
        "correct": false
      }
    ],
    "explanation": "Code Injection występuje, gdy aplikacja bierze dane od użytkownika i bez sprawdzenia wykonuje je jako kod programu (np. używając funkcji `eval()`).\n\nPrzykład: Aplikacja ma kalkulator. Użytkownik zamiast `2+2` wpisuje `system('usuń_wszystkie_pliki')`. Jeśli aplikacja to wykona - to jest Code Injection."
  },
  {
    "id": 144,
    "question": "Jak (jako administrator) zabezpieczyć się przed atakami z użyciem ciasteczek?",
    "options": [
      {
        "text": "Szyfrować wartości ciasteczek",
        "inline_explanation": "(Prawda. Dzięki temu, nawet jeśli użytkownik edytuje plik cookie na swoim komputerze, serwer odrzuci zmodyfikowaną wartość lub jej nie odczyta)",
        "correct": true
      },
      {
        "text": "Ustawić flagę HttpOnly",
        "inline_explanation": "(Prawda. Zapobiega to kradzieży ciasteczka przez skrypty JavaScript (ochrona przed XSS))",
        "correct": true
      },
      {
        "text": "Ustawić flagę Secure",
        "inline_explanation": "(Prawda. Wymusza przesyłanie ciasteczka wyłącznie szyfrowanym kanałem HTTPS)",
        "correct": true
      },
      {
        "text": "Zapisywać hasła użytkowników w ciasteczkach jawnym tekstem",
        "inline_explanation": "(Fałsz. To kardynalny błąd bezpieczeństwa)",
        "correct": false
      },
      {
        "text": "Ustawić flagę SameSite (Strict lub Lax)",
        "inline_explanation": "(Prawda. Ogranicza wysyłanie ciasteczek w żądaniach między różnymi stronami, chroniąc przed CSRF)",
        "correct": true
      }
    ],
    "explanation": "Ciasteczka są wektorem wielu ataków (XSS, CSRF, Session Hijacking).\n\nOchrona wymaga wielu warstw:\n1. **HttpOnly:** \"Nie dawaj JS dostępu do ciastek\".\n2. **Secure:** \"Wysyłaj tylko po HTTPS\".\n3. **SameSite:** \"Nie wysyłaj, gdy link pochodzi z innej strony\".\n4. **Szyfrowanie/Podpis:** \"Zabezpiecz treść przed podglądem i zmianą\"."
  },
  {
    "id": 145,
    "question": "WAF (Web Application Firewall) sprawdza:",
    "options": [
      {
        "text": "tylko ruch wysyłany z serwera do użytkownika",
        "inline_explanation": "(Fałsz. To byłoby bez sensu - WAF musi przede wszystkim badać zapytania wchodzące do serwera (GET/POST), aby zablokować SQL Injection czy XSS, zanim dotrą do aplikacji)",
        "correct": false
      },
      {
        "text": "ruch w warstwie aplikacji (HTTP/HTTPS), analizując treść zapytań i odpowiedzi",
        "inline_explanation": "(Prawda. WAF działa w 7. warstwie modelu OSI i 'rozumie' co jest w środku pakietu, w przeciwieństwie do zwykłego firewalla sieciowego)",
        "correct": true
      },
      {
        "text": "poprawność sum kontrolnych ramek Ethernet",
        "inline_explanation": "(Fałsz. To zadanie dla karty sieciowej lub switcha w warstwie 2, a nie dla WAF)",
        "correct": false
      },
      {
        "text": "tylko nagłówki pakietów IP (adres źródłowy i docelowy)",
        "inline_explanation": "(Fałsz. To definicja klasycznego Firewalla stanowego (Packet Filtering), WAF zagląda głębiej - w payload)",
        "correct": false
      },
      {
        "text": "czy użytkownik posiada zainstalowany program antywirusowy",
        "inline_explanation": "(Fałsz. WAF chroni serwer, nie ma wglądu w to, co jest zainstalowane na komputerze klienta)",
        "correct": false
      }
    ],
    "explanation": "WAF to 'ochroniarz', który stoi przed aplikacją WWW.\n\nZwykły Firewall mówi: \"Wpuszczam ruch na porcie 80\".\nWAF mówi: \"Wpuszczam ruch na porcie 80, ALE sprawdzam, czy w formularzu logowania ktoś nie wpisał kodu SQL\". Analizuje on ruch w obie strony, ale kluczowa jest blokada złośliwych żądań (Request)."
  },
  {
    "id": 146,
    "question": "Metodami ochrony przed atakami typu XSS są:",
    "options": [
      {
        "text": "ograniczenia w zakresie publikacji plików oraz linków",
        "inline_explanation": "(Prawda. Zabronienie użytkownikom wgrywania plików HTML/SVG lub wklejania linków 'javascript:' ogranicza wektory ataku)",
        "correct": true
      },
      {
        "text": "kodowanie (encoding) danych wyjściowych odpowiednio do kontekstu (HTML, JS, CSS)",
        "inline_explanation": "(Prawda. Zamiana znaków specjalnych jak `<` na `&lt;` sprawia, że przeglądarka wyświetli je jako tekst, a nie wykona jako kod)",
        "correct": true
      },
      {
        "text": "stosowanie nagłówka Content Security Policy (CSP)",
        "inline_explanation": "(Prawda. CSP to instrukcja dla przeglądarki, z jakich źródeł wolno ładować skrypty. Blokuje to nieautoryzowany kod)",
        "correct": true
      },
      {
        "text": "wyłącznie stosowanie protokołu HTTPS",
        "inline_explanation": "(Fałsz. Szyfrowanie transmisji nie chroni przed złośliwym skryptem, który jest poprawnie przesłany bezpiecznym tunelem)",
        "correct": false
      },
      {
        "text": "ukrywanie kodu źródłowego strony poprzez blokadę prawego przycisku myszy",
        "inline_explanation": "(Fałsz. Security by Obscurity nie działa; kod źródłowy zawsze można podejrzeć w narzędziach deweloperskich)",
        "correct": false
      }
    ],
    "explanation": "XSS (Cross-Site Scripting) polega na wstrzyknięciu złośliwego JavaScriptu.\n\nObrona jest wielowarstwowa:\n1. **Input Validation:** Nie pozwalaj wpisywać `<script>`.\n2. **Output Encoding:** Jeśli ktoś wpisał `<script>`, wyświetl to jako bezpieczny tekst.\n3. **CSP:** Nawet jak skrypt przejdzie, przeglądarka go nie uruchomi, bo nie jest na białej liście."
  },
  {
    "id": 147,
    "question": "Podatności z zakresu Identification and Authentication Failures:",
    "options": [
      {
        "text": "mogą być eliminowane poprzez nałożenia na użytkownika wymagań oraz ograniczeń",
        "inline_explanation": "(Prawda. Chodzi o wymuszenie polityki haseł - np. min. 12 znaków, brak słownikowych słów - oraz blokadę konta po X nieudanych próbach)",
        "correct": true
      },
      {
        "text": "dotyczą wyłącznie błędów w kodzie SQL bazy danych",
        "inline_explanation": "(Fałsz. To byłoby SQL Injection. Tutaj chodzi o proces logowania i zarządzania sesją)",
        "correct": false
      },
      {
        "text": "są niwelowane poprzez wdrożenie uwierzytelniania wieloskładnikowego (MFA)",
        "inline_explanation": "(Prawda. MFA to najskuteczniejsza metoda obrony przed słabymi lub skradzionymi hasłami)",
        "correct": true
      },
      {
        "text": "wymagają stosowania domyślnych haseł producenta dla łatwiejszej konfiguracji",
        "inline_explanation": "(Fałsz. Pozostawienie domyślnych haseł to jedna z głównych przyczyn tych podatności!)",
        "correct": false
      },
      {
        "text": "polegają na przesyłaniu identyfikatora sesji w adresie URL (Session ID exposure)",
        "inline_explanation": "(Prawda. To klasyczny błąd w tej kategorii - identyfikator sesji powinien być w ciasteczku, a nie w pasku adresu, skąd łatwo wycieka)",
        "correct": true
      }
    ],
    "explanation": "Kategoria \"Identification and Authentication Failures\" (dawniej Broken Authentication) obejmuje wszystko, co pozwala hakerowi podszyć się pod użytkownika.\n\nNaprawiamy to poprzez:\n1. **Wymagania:** Silne hasła, rotacja, brak haseł domyślnych.\n2. **Ograniczenia:** Blokada po 3 błędnych próbach (ochrona przed Brute Force).\n3. **MFA:** Dodatkowy składnik logowania."
  }
]

