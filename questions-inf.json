[
  {
    "id": 1,
    "question": "Najbardziej prymitywnym systemem liczbowym jest:",
    "options": [
      {
        "text": "jedynkowy system liczbowy",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "dwójkowy system liczbowy",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "ósemkowy system liczbowy",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "dziesiętny system liczbowy",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "szesnastkowy system liczbowy",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "W systemie jedynkowym piszemy po prostu tyle jedynek, jak duża jest liczba, np. 3 w systemie dziesiętnym to 111 w jedynkowym."
  },
  {
    "id": 2,
    "question": "Wartość 5/16 ma postać w systemie binarnym:",
    "options": [
      {
        "text": "0.0101",
        "inline_explanation": "= 5/16",
        "correct": true
      },
      {
        "text": "0.1011",
        "inline_explanation": "= 11/16",
        "correct": false
      },
      {
        "text": "0.1010",
        "inline_explanation": "= 5/8",
        "correct": false
      }
    ],
    "explanation": "Liczymy osobno część całkowitą i ułamkową (po przecinku).\n\nDla części całkowitej: dzielimy przez 2, dopisujemy resztę z dzielenia (0 lub 1) z lewej strony budowanej liczby, powtarzamy aż dojdziemy do 0.\n\nDla części ułamkowej: mnożymy przez 2, dopisujemy część całkowitą (0 lub 1) z prawej strony budowanej liczby, jako kolejną liczbę bierzemy ułamek z uzyskanej liczby (w razie czego trzeba będzie odciąć 1), powtarzamy aż dojdziemy do 0.\nJeżeli w ułamku zauważymy, że coś zaczyna się powtarzać (wpadamy w pętlę z wartościami), to mamy ułamek okresowy."
  },
  {
    "id": 3,
    "question": "Wartość 1/10 ma postać w systemie binarnym:",
    "options": [
      {
        "text": "0.1010",
        "inline_explanation": "= 5/8",
        "correct": false
      },
      {
        "text": "0.0(0011)",
        "inline_explanation": "= 1/10",
        "correct": true
      },
      {
        "text": "0.(1010)",
        "inline_explanation": "= 2/3",
        "correct": false
      },
      {
        "text": "0.0(1010)",
        "inline_explanation": "= 1/3",
        "correct": false
      }
    ],
    "explanation": "Liczymy osobno część całkowitą i ułamkową (po przecinku).\n\nDla części całkowitej: dzielimy przez 2, dopisujemy resztę z dzielenia (0 lub 1) z lewej strony budowanej liczby, powtarzamy aż dojdziemy do 0.\n\nDla części ułamkowej: mnożymy przez 2, dopisujemy część całkowitą (0 lub 1) z prawej strony budowanej liczby, jako kolejną liczbę bierzemy ułamek z uzyskanej liczby (w razie czego trzeba będzie odciąć 1), powtarzamy aż dojdziemy do 0.\nJeżeli w ułamku zauważymy, że coś zaczyna się powtarzać (wpadamy w pętlę z wartościami), to mamy ułamek okresowy.\n\n0.1 * 2 = 0.2 liczba: 0.0\n0.2 * 2 = 0.4 liczba: 0.00\n0.4 * 2 = 0.8 liczba: 0.000\n0.8 * 2 = 1.6 -> 0.6 liczba: 0.0001\n0.6 * 2 = 1.2 -> 0.2 liczba: 0.00011\nZauważamy, że wróciliśmy do początku 2 linijki, czyli od wtedy jest okres:\n0.0010... = 0.0(0011)"
  },
  {
    "id": 4,
    "question": "Ile informacji zawiera 8-znakowe słowo, którego każdy znak jest jedną z liter a,b? Prawdopodobieństwo pojawienia się (na każdej pozycji) samogłoski jest dwukrotnie większe od prawdopodobieństwa pojawienia się spółgłoski.",
    "options": [
      {
        "text": "więcej niż 8 bitów",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "mniej niż 8 bitów",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "dokładnie 8 bitów",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Wykorzystuje się tutaj wzór na entropię informacji Shannona:\n$H(X) = -\\sum_{i=1}^{n} p_i \\log_2 (p_i)$,\ngdzie $(p_i)$ jest prawdopodobieństwem wystąpienia elementu $x_i$.\n\nŻeby obliczyć na X-znakowego słowa: dla każdego znaku (np. 0/1, a/b/c…) liczymy powyższy wzór, mnożymy przez liczbę miejsc X (zakładając, że dla każdego miejsca jest takie samo prawdopodobieństwo) i potem sumujemy dla poszczególnych znaków. Ważne jest dla nas tylko przyrównanie tego do 8 (jednostką jest bit).\n\n$H(X) = -8 * [2/3 * log_2(2/3) + 1/3 * log_2(1/3)] =...=-8 * [2/3 - log_2(3)]"
  },
  {
    "id": 5,
    "question": "Algorytm to:",
    "options": [
      {
        "text": "uporządkowany zbiór operacji",
        "inline_explanation": "(Definicja ogólna)",
        "correct": true
      },
      {
        "text": "specyfikacja ciągu elementarnych operacji, które przekształcają dane wejściowe na wynik",
        "inline_explanation": "(Definicja ścisła)",
        "correct": true
      },
      {
        "text": "zbiór losowych instrukcji bez określonego celu",
        "inline_explanation": "(Algorytm musi być celowy i uporządkowany)",
        "correct": false
      },
      {
        "text": "fizyczna część komputera wykonująca obliczenia",
        "inline_explanation": "(To procesor, a nie algorytm)",
        "correct": false
      }
    ],
    "explanation": "Algorytm to skończony ciąg jasno zdefiniowanych czynności koniecznych do wykonania pewnego rodzaju zadań. Cechuje go: skończoność, określoność (jednoznaczność), posiadanie danych wejściowych i wyjściowych oraz efektywność."
  },
  {
    "id": 6,
    "question": "Język formalny w informatyce jest:",
    "options": [
      {
        "text": "zbiorem słów nad danym alfabetem, określonym przez ścisłe reguły (gramatykę)",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "sposobem zapisu algorytmów opartym na blokach operacyjnych",
        "inline_explanation": "(To schemat blokowy)",
        "correct": false
      },
      {
        "text": "językiem naturalnym (np. polskim) służącym do luźnej komunikacji",
        "inline_explanation": "(Języki naturalne są niejednoznaczne)",
        "correct": false
      },
      {
        "text": "graficzną reprezentacją struktury bazy danych",
        "inline_explanation": "(To diagram ERD)",
        "correct": false
      }
    ],
    "explanation": "Język formalny to pojęcie z teorii języków i automatów. Jest to zbiór ciągów symboli (słów) wygenerowanych przez ściśle określoną gramatykę. Języki programowania są podzbiorem języków formalnych, w przeciwieństwie do języków naturalnych, które dopuszczają wieloznaczność."
  },
  {
    "id": 7,
    "question": "Syntaktyka (składnia) języka programowania opisuje:",
    "options": [
      {
        "text": "znaczenie instrukcji w języku",
        "inline_explanation": "(To semantyka)",
        "correct": false
      },
      {
        "text": "formalnie poprawne programy",
        "inline_explanation": "(Syntaktyka określa reguły, ale nie gwarantuje poprawności logicznej)",
        "correct": false
      },
      {
        "text": "budowę instrukcji w języku",
        "inline_explanation": "(Reguły pisowni, np. gdzie postawić średnik)",
        "correct": true
      },
      {
        "text": "działanie poprawnego programu",
        "inline_explanation": "(To semantyka)",
        "correct": false
      }
    ],
    "explanation": "Syntaktyka (Syntax) zajmuje się formą i strukturą zapisu. Odpowiada na pytanie 'jak to napisać, żeby kompilator zrozumiał?'. Określa np. użycie nawiasów, średników czy słów kluczowych. "
  },
  {
    "id": 8,
    "question": "Semantyka języka programowania opisuje:",
    "options": [
      {
        "text": "znaczenie instrukcji w języku",
        "inline_explanation": "(Co się stanie po uruchomieniu kodu)",
        "correct": true
      },
      {
        "text": "formalnie poprawne programy",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "budowę instrukcji w języku",
        "inline_explanation": "(To syntaktyka)",
        "correct": false
      },
      {
        "text": "działanie poprawnego programu",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Semantyka (Semantics) zajmuje się znaczeniem i działaniem kodu. Odpowiada na pytanie 'co ten kod robi?'. Kod może być poprawny syntaktycznie (bez błędów kompilacji), ale błędny semantycznie (robić coś innego niż zamierzono). "
  },
  {
    "id": 9,
    "question": "Nawiasy <> w notacji EBNF oznaczają:",
    "options": [
      {
        "text": "symbol nieterminalny",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "opcjonalne wystąpienie elementu",
        "inline_explanation": "[]",
        "correct": false
      },
      {
        "text": "symbol terminalny",
        "inline_explanation": "(litery, liczby, ciągi znaków)",
        "correct": false
      },
      {
        "text": "wielokrotne występowanie elementu",
        "inline_explanation": "{}",
        "correct": false
      }
    ],
    "explanation": "Sposób zapisu gramatyki bezkontekstowej. W szczególności jest używana do opisywania składni (syntaktyki) języków programowania. Ważne elementy notacji:\n● litery, liczby, ciągi znaków - symbole terminalne (końcowe)\n● <> - symbole nieterminalne (pomocnicze)\n● ::= - produkcja\n● | - alternatywa\n● [] - wystąpienie 0 lub 1 raz\n● {} - wystąpienie 0 lub więcej razy"
  },
  {
    "id": 10,
    "question": "Semantyka denotacyjna to:",
    "options": [
      {
        "text": "opis w postaci funkcji przekształcającej dane wejściowe w dane wyjściowe",
        "inline_explanation": "(Skupia się na efekcie działania programu, a nie na krokach)",
        "correct": true
      },
      {
        "text": "opis budowy poprawnych semantycznie programów",
        "inline_explanation": "(To zbyt ogólne określenie)",
        "correct": false
      },
      {
        "text": "stan maszyny przed i po wykonaniu instrukcji",
        "inline_explanation": "(To definicja semantyki operacyjnej)",
        "correct": false
      },
      {
        "text": "zbiór aksjomatów i reguł wnioskowania dla instrukcji",
        "inline_explanation": "(To definicja semantyki aksjomatycznej)",
        "correct": false
      }
    ],
    "explanation": "Semantyka denotacyjna przypisuje fragmentom programu obiekty matematyczne (denotacje), zazwyczaj funkcje. \n  \n Ignoruje ona to, 'jak' program liczy (kroki, rejestry procesora), a skupia się na tym 'co' liczy (matematyczny związek wejścia z wyjściem)."
  },
  {
    "id": 11,
    "question": "Kodem ASCII możemy zakodować:",
    "options": [
      {
        "text": "dowolny znak z zakresu 0-127",
        "inline_explanation": "(Standard ASCII jest 7-bitowy, co daje 128 znaków)",
        "correct": true
      },
      {
        "text": "dowolny znak z zakresu 0-128",
        "inline_explanation": "(Błąd logiczny: zakres 0-128 to 129 znaków)",
        "correct": false
      },
      {
        "text": "dowolny znak z zakresu 0-255",
        "inline_explanation": "(To zakres rozszerzonego ASCII / ISO-8859-1)",
        "correct": false
      },
      {
        "text": "dowolny znak z zakresu 32-255",
        "inline_explanation": "(Pomija znaki sterujące 0-31)",
        "correct": false
      }
    ],
    "explanation": "ASCII:\n● najstarszy format kodowania znaków\n● standardowo tylko znaki z języka angielskiego, zapisywane na 7 bitach\n● 1 znak ASCII zajmuje 1 bajt, czyli 8 bitów; ostatni bit zgodnie ze standardem nie jest używany (są różne rozszerzenia)\n● realnie są to liczby z zakresu 0-127, zapisywane binarnie"
  },
  {
    "id": 12,
    "question": "Kodowanie znaków metodą UTF-8 cechuje:",
    "options": [
      {
        "text": "pozwala zakodować dowolne znaki Unicode",
        "inline_explanation": "(Jest pełną implementacją standardu)",
        "correct": true
      },
      {
        "text": "zmienna długość kodu",
        "inline_explanation": "(Znak może zajmować od 1 do 4 bajtów)",
        "correct": true
      },
      {
        "text": "pozwala zakodować dowolne znaki ASCII za pomocą 1 bajta",
        "inline_explanation": "(Pełna kompatybilność wsteczna z ASCII)",
        "correct": true
      },
      {
        "text": "pozwala zakodować dowolne znaki ASCII za pomocą 8 bajtów",
        "inline_explanation": "(Nieefektywne i niezgodne ze standardem)",
        "correct": false
      },
      {
        "text": "pozwala zakodować dowolne znaki Unicode za pomocą nie więcej niż 6 bajtów",
        "inline_explanation": "(Oryginalna specyfikacja dopuszczała 6, obecna RFC ogranicza do 4, ale technicznie jest to prawda w starszych definicjach)",
        "correct": true
      },
      {
        "text": "kod znaku ASCII może być częścią dłuższego kodu",
        "inline_explanation": "(Nie, UTF-8 ma własność prefiksową - bajt ASCII nigdy nie wystąpi w środku znaku wielobajtowego)",
        "correct": false
      }
    ],
    "explanation": "Unicode:\n● znaki z praktycznie wszystkich języków\n● przyporządkowuje każdemu znakowi liczbę - to, jak ta liczba będzie zakodowana, to już inna sprawa\n● wstecznie kompatybilne z ASCII - pierwsze 128 znaków to właśnie ASCII\n● zmienna długość: 1 bajt dla znaków ASCII, do 4 bajtów dla innych języków\n● standardowo używa kodowania UTF-8\n\nUTF-8:\n● 8-bit Unicode Transformation Format\n● koduje znaki standardu Unicode\n● znaki ASCII zapisuje na 8 bitach, późniejsze zestawy na 16, 24 i 32 bitach (czyli 1-4 bajty)\n● rozróżnia zestaw znaków po pierwszych bajtach, np. znaki ASCII to 0xxxxxxx, a znaki z drugiej serii to 110xxxxx 10xxxxxx etc.\n● jeden znak zgodnie z powyższą zasadą można by zapisać na kilka sposobów, dlatego poprawny jest tylko najkrótszy możliwy zapis danego znaku"
  },
  {
    "id": 13,
    "question": "Od czego zależy dokładność liczb zmiennopozycyjnych w komputerze?",
    "options": [
      {
        "text": "od długości cechy",
        "inline_explanation": "(Cecha decyduje o zakresie liczb, a nie dokładności)",
        "correct": false
      },
      {
        "text": "od długości mantysy",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "od długości cechy i mantysy",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "od bazy systemu liczbowego",
        "inline_explanation": "",
        "correct": false
      }
    ],
  "explanation": "Precyzja reprezentacji (ilość cyfr znaczących) zależy bezpośrednio od liczby bitów przeznaczonych na mantysę. Cecha (wykładnik) determinuje zakres liczb (jak duże lub jak małe liczby bliskie zeru możemy zapisać)."
  },
  {
    "id": 14,
    "question": "Cechami kodu uzupełnień do dwóch (U2) są:",
    "options": [
      {
        "text": "podwójna reprezentacja zera",
        "inline_explanation": "(Występuje np. w kodzie Znak-Moduł)",
        "correct": false
      },
      {
        "text": "pojedyncza reprezentacja zera",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "symetryczny zakres liczb",
        "inline_explanation": "(Zakres jest asymetryczny)",
        "correct": false
      },
      {
        "text": "asymetryczny zakres liczb",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Kod U2 posiada tylko jedno zero (reprezentowane samymi zerami). Jest asymetryczny: liczb ujemnych jest o jedną więcej niż dodatnich (jedna liczba dodatnia jest 'zużywana' na reprezentację zera). Zakres wynosi [-2^(n-1), 2^(n-1)-1]."
  },
  {
    "id": 15,
    "question": "Liczby stałopozycyjne w komputerze są reprezentowane w kodzie uzupełnień do 2. Dla jakich wartości funkcja abs(x) (wartość bezwzględna) będzie obliczona prawidłowo?",
    "options": [
      {
        "text": "tylko dla liczb ujemnych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "tylko dla liczb nieujemnych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "dla wszystkich liczb typu integer",
        "inline_explanation": "(Błąd dla najmniejszej ujemnej)",
        "correct": false
      },
      {
        "text": "wszystkich poza najmniejszą liczbą w reprezentacji",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Ze względu na asymetrię kodu U2, najmniejsza liczba ujemna (np. -128 dla 8 bitów) nie posiada swojego dodatniego odpowiednika (zakres dodatni kończy się na 127). Próba obliczenia jej wartości bezwzględnej spowoduje nadmiar (overflow)."
  },
  {
    "id": 16,
    "question": "Dana jest następująca reprezentacja liczb zmiennopozycyjnych: mantysa zajmuje 20 bitów, wykładnik zajmuje 8 bitów. Wykładnik i mantysa zapisywane są w kodzie U2. Z dokładnością do ilu cyfr dziesiętnych można pamiętać liczby w tej reprezentacji?",
    "options": [
      {
        "text": "około 10",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "około 6",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "około 3",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "14",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Decydująca jest długość mantysy. Jedna cyfra dziesiętna wymaga około log_2(10) ≈ 3.32 bita. Mając 20 bitów mantysy, precyzja wynosi: 20 / 3.32 ≈ 6 miejsc dziesiętnych."
  },
  {
    "id": 17,
    "question": "Dana jest następująca reprezentacja liczb zmiennopozycyjnych: mantysa zajmuje 22 bity (w tym bit znaku), cecha zajmuje 10 bitów (w tym bit znaku). Obie w kodzie U2. Mantysa jest ułamkiem [1/2, 1). Jaka jest największa możliwa liczba w tym systemie?",
    "options": [
      {
        "text": "10^10",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "(1 - 2^(-21)) * 2^(2^9 - 1)",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "2^(2^9)",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "(1 - 2^(-22)) * 2^(2^10 - 1)",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Cecha ma 9 bitów wartości (plus znak), więc w kodzie U2 jej maksymalna wartość to 2^9 - 1. Mantysa ma 21 bitów wartości (plus znak). Największa mantysa mniejsza od 1 to suma ciągu geometrycznego (same jedynki), co daje 1 - 2^(-21). Stąd wynik: maksymalna mantysa * 2^(maksymalna cecha)."
  },
  {
    "id": 18,
    "question": "Jaka jest minimalna liczba bitów, aby reprezentować liczby zmiennopozycyjne z zakresu -10^6 ... 10^6 z dokładnością do 2 miejsc znaczących?",
    "options": [
      {
        "text": "8 bitów",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "12 bitów",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "4 bity",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "14 bitów",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Wymagany jest 1 bit na znak. Mantysa musi zapewnić dokładność 2 miejsc po przecinku, co wg wzoru N/3.3 daje około 7 bitów (2 * 3.3 = 6.6). Wykładnik musi pokryć odpowiedni zakres (wg źródła przyjęto 4 bity). Sumarycznie daje to 1 + 4 + 7 = 12 bitów."
  },
  {
    "id": 19,
    "question": "Dana jest reprezentacja liczb zmiennopozycyjnych: mantysa zajmuje 16 bitów, wykładnik 8 bitów (obie w U2). Z dokładnością do ilu cyfr dziesiętnych można pamiętać liczby w tej reprezentacji?",
    "options": [
      {
        "text": "7-8",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "15-16",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "4-5",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "2-3",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "O precyzji decyduje długość mantysy. Stosując przybliżenie, że 1 cyfra dziesiętna to ok. 3.32 bita: 16 bitów / 3.32 ≈ 4.8. Pozwala to na zapamiętanie około 4-5 cyfr znaczących."
  },
  {
    "id": 20,
    "question": "Liczba 10010 reprezentowana w systemie U2 (uzupełnień do dwóch) ma wartość:",
    "options": [
      {
        "text": "2",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "-14",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "14",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "6",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "-18",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Najstarszy bit to 1, co oznacza liczbę ujemną. Aby obliczyć jej wartość bezwzględną, odwracamy bity (01101) i dodajemy 1, co daje 01110 (czyli 14 w systemie dziesiętnym). Zatem wynikiem jest -14."
  },
  {
    "id": 21,
    "question": "W standardzie IEEE 754 liczby zmiennopozycyjne podwójnej precyzji (double):",
    "options": [
      {
        "text": "posiadają mantysę o długości 52 bitów",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "posiadają mantysę o długości 53 bitów",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "posiadają wykładnik o długości 11 bitów",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "posiadają wykładnik o długości 12 bitów",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "gwarantują 7-8 dziesiętnych miejsc znaczących",
        "inline_explanation": "(Prawda na zasadzie implikacji: skoro gwarantują ok. 15, to gwarantują też 7-8)",
        "correct": true
      },
      {
        "text": "posiadają wykładnik o długości 8 bitów",
        "inline_explanation": "(To cecha pojedynczej precyzji - float)",
        "correct": false
      }
    ],
    "explanation": "Liczba typu double zajmuje 64 bity: 1 bit znaku, 11 bitów wykładnika i 52 bity mantysy (plus jeden bit domyślny, co daje 53 bity precyzji). Taka długość mantysy przekłada się na około 15-17 cyfr znaczących (więc stwierdzenie o 7-8 cyfrach jest logicznie prawdziwe, choć nieprecyzyjne)."
  },
  {
    "id": 22,
    "question": "Bramki wykonują operacje na:",
    "options": [
      {
        "text": "słowach",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "wartościach logicznych",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "liczbach całkowitych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "ciągach znaków",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 23,
    "question": "Bramka NAND wykonuje:",
    "options": [
      {
        "text": "najpierw operację iloczynu logicznego, potem negację",
        "inline_explanation": "(NOT AND)",
        "correct": true
      },
      {
        "text": "najpierw operację negacji, potem iloczynu logicznego",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "operację różnicy symetrycznej",
        "inline_explanation": "(To bramka XOR)",
        "correct": false
      },
      {
        "text": "operację sumy logicznej",
        "inline_explanation": "(To bramka OR)",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 24,
    "question": "Zbiór przerzutników służących do przechowywania informacji cyfrowej to:",
    "options": [
      {
        "text": "procesor",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "rejestr",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "sumator",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "multiplekser",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Inne elementy służące do przechowywania to np. pamięć i bufory. Rejestr jest najszybszą formą pamięci wewnątrz procesora."
  },
  {
    "id": 25,
    "question": "Do czego służy stos systemowy?",
    "options": [
      {
        "text": "do przechowywania wszystkich zmiennych w programie",
        "inline_explanation": "(Zmienne globalne/statyczne są w innym segmencie)",
        "correct": false
      },
      {
        "text": "do przechowywania zmiennych alokowanych procedurą new(p)",
        "inline_explanation": "(One trafiają na stertę - heap)",
        "correct": false
      },
      {
        "text": "dla przechowywania zmiennych lokalnych procedur i funkcji",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "do przechowywania adresów powrotu z funkcji",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "do przechowywania zmiennych alokowanych dynamicznie",
        "inline_explanation": "(To sterta)",
        "correct": false
      }
    ],
    "explanation": "Stos (Stack) służy do obsługi wywołań funkcji: przechowuje ramki stosu zawierające zmienne lokalne, argumenty funkcji oraz adres powrotu. Dynamiczna alokacja (malloc/new) korzysta ze sterty (Heap)."
  },
  {
    "id": 26,
    "question": "Zmienna typu wskaźnik zajmuje 4 bajty. Ile pamięci można zaadresować takim wskaźnikiem?",
    "options": [
      {
        "text": "64 kilobajty",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "4 gigabajty",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "2 megabajty",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "6 gigabajtów",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "8 kilobajtów",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "4 bajty to 32 bity. Liczba możliwych adresów wynosi $2^{32}$. Zakładając, że jeden adres wskazuje na 1 bajt (adresowanie bajtowe), otrzymujemy $2^{32}$ bajtów = 4 GB."
  },
  {
    "id": 27,
    "question": "Jaki paradygmat programowania jest realizowany w języku C?",
    "options": [
      {
        "text": "aplikatywny",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "imperatywny",
        "inline_explanation": "(Opisujemy instrukcje krok po kroku)",
        "correct": true
      },
      {
        "text": "deklaratywny",
        "inline_explanation": "(Np. SQL)",
        "correct": false
      },
      {
        "text": "strukturalny",
        "inline_explanation": "(Używa bloków, funkcji, pętli zamiast GOTO)",
        "correct": true
      },
      {
        "text": "obiektowy",
        "inline_explanation": "(C nie jest obiektowy, C++ jest)",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 28,
    "question": "Jeżeli w programie następuje odwołanie poza obszar tablicy (np. w C/C++):",
    "options": [
      {
        "text": "zawsze sygnalizowany jest błąd wykonania",
        "inline_explanation": "(Nie zawsze, zależy czy trafimy w chronioną pamięć)",
        "correct": false
      },
      {
        "text": "nie jest sygnalizowany błąd, jeżeli pamięć jest zaalokowana",
        "inline_explanation": "(Dla procesu)",
        "correct": true
      },
      {
        "text": "kompilator zawsze wykryje błąd podczas kompilacji",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "wartość pod tym indeksem jest automatycznie zerowana",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Jest to tzw. Undefined Behaviour (zachowanie niezdefiniowane). Jeśli odwołamy się do pamięci, która należy do naszego programu (np. sąsiednia zmienna), system operacyjny nie zgłosi błędu (Segmentation Fault), a program może działać dalej na błędnych danych."
  },
  {
    "id": 29,
    "question": "Których nawiasów trzeba użyć w Odwrotnej Notacji Polskiej do zmiany kolejności wykonywania działań?",
    "options": [
      {
        "text": "{}",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "o kolejności działań nie decydują nawiasy",
        "inline_explanation": "(Jest to notacja beznawiasowa)",
        "correct": true
      },
      {
        "text": "()",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "[]",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "ONP (Odwrotna Notacja Polska) charakteryzuje się tym, że operatory stoją za argumentami. Kolejność wykonywania działań jest jednoznacznie określona przez pozycję operatorów, co eliminuje konieczność stosowania nawiasów."
  },
  {
    "id": 30,
    "question": "Jaki wynik da następujące wyrażenie zapisane w ONP: 2 3 4 5 + * +",
    "options": [
      {
        "text": "25",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "29",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "20",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "35",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Algorytm:\n1. Na stos: 2, 3, 4, 5\n2. Operator +: zdejmij 5 i 4, oblicz 4+5=9. Stos: 2, 3, 9\n3. Operator *: zdejmij 9 i 3, oblicz 3*9=27. Stos: 2, 27\n4. Operator +: zdejmij 27 i 2, oblicz 2+27=29."
  },
  {
    "id": 31,
    "question": "Co oznacza, że algorytm sortowania tablicy posiada złożoność $O(n^2)$?",
    "options": [
      {
        "text": "wykonywana liczba porównań wynosi $n^2$",
        "inline_explanation": "(Oznaczałoby to dokładną wartość, a O to rząd wielkości)",
        "correct": false
      },
      {
        "text": "wykonywana liczba porównań jest rzędu $n^2$",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "wykonywana liczba przestawień elementów tablicy w algorytmie wynosi $n^7$",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "dwukrotne zwiększenie rozmiaru tablicy spowoduje czterokrotne zwiększenie czasu sortowania",
        "inline_explanation": "(Dla n=2x, czas ~ (2x)^2 = 4x^2)",
        "correct": true
      }
    ],
    "explanation": "Złożoność obliczeniowa 'duże O' opisuje asymptotyczne tempo wzrostu czasu wykonywania algorytmu w zależności od rozmiaru danych wejściowych (n). Dla funkcji kwadratowej podwojenie danych skutkuje czterokrotnym wydłużeniem czasu."
  },
  {
    "id": 32,
    "question": "Co oznacza, że algorytm sortowania tablicy posiada złożoność $O(n^2)$? (Wariant 2)",
    "options": [
      {
        "text": "wykonywana liczba porównań i wykonywana liczba przestawień elementów tablicy w algorytmie wynosi $n^2$",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "wykonywana liczba porównań lub wykonywana liczba przestawień elementów tablicy w algorytmie wynosi $n^2$",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "żadne z powyższych",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Notacja $O(n^2)$ jest górnym ograniczeniem rzędu wielkości, a nie stwierdzeniem o dokładnej liczbie konkretnych operacji (która zależy od implementacji i stałych ukrytych w notacji O)."
  },
  {
    "id": 33,
    "question": "Translacja analizuje symbole:",
    "options": [
      {
        "text": "od lewej do prawej strony",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "od prawej do lewej strony",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "w dowolnej kolejności",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "z góry na dół",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Większość kompilatorów i interpreterów przetwarza kod źródłowy (strumień znaków/tokenów) sekwencyjnie, czytając go od lewej do prawej."
  },
  {
    "id": 34,
    "question": "Prawo dostępu do pliku 453 pozwala:",
    "options": [
      {
        "text": "właścicielowi czytać plik",
        "inline_explanation": "(4 = r--)",
        "correct": true
      },
      {
        "text": "wszystkim czytać plik",
        "inline_explanation": "(Inni mają 3, czyli -wx)",
        "correct": false
      },
      {
        "text": "właścicielowi na odczyt, grupie na odczyt i uruchomienie, pozostałym na zapis i uruchomienie",
        "inline_explanation": "(To pełny opis uprawnień 453)",
        "correct": true
      },
      {
        "text": "grupie na odczyt i zapis, pozostałym tylko na odczyt",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Uprawnienia w notacji ósemkowej to r=4, w=2, x=1. \n4 (Właściciel) = r-- (tylko odczyt).\n5 (Grupa) = r-x (odczyt i wykonanie).\n3 (Inni) = -wx (zapis i wykonanie).\nPełny zapis tekstowy: r--r-x-wx."
  },
  {
    "id": 35,
    "question": "Przy konfiguracji obsługi sieci w Unixie:",
    "options": [
      {
        "text": "plik /etc/hosts przechowuje listę znanych hostów i interfejsów sieciowych",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "plik /etc/hosts zawiera tylko adresy IP lokalnych interfejsów",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "plik /etc/networks zawiera adresy IP znanych sieci IP",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "plik /etc/networks przechowuje listę lokalnych interfejsów",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 36,
    "question": "W systemie operacyjnym UNIX prawdziwe są następujące stwierdzenia dotyczące użytkownika i jego sesji:",
    "options": [
      {
        "text": "praca programu logującego (login) jest sterowana m. in. zawartością plików /etc/nologin lub /etc/motd",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "o możliwościach użytkownika w systemie decyduje przynależność do odpowiednich grup użytkowników",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "w zależności od konfiguracji systemu mogą być odnotowywane podłączenia do systemu poprzez zmianę kontekstu użytkownika (komenda su)",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "grupy użytkowników wprowadzono, aby ułatwić zarządzanie użytkownikami oraz podnieść bezpieczeństwo systemu",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "/etc/motd to plik 'message of the day' wyświetlany przy logowaniu. Logowania przez zmianę kontekstu (su/sudo) są logowane w dziennikach systemowych i mogą być blokowane."
  },
  {
    "id": 37,
    "question": "W systemie operacyjnym UNIX prawdziwe są następujące stwierdzenia dotyczące procesu logowania się i uprawnień użytkowników:",
    "options": [
      {
        "text": "o postaci hasła decyduje administrator systemu zapisując ograniczenia w różnych wersjach systemu w różnych plikach konfiguracyjnych",
        "inline_explanation": "(np. w /etc/pam.d/)",
        "correct": true
      },
      {
        "text": "wszystkie grupy użytkowników dają im jednakowe uprawnienia",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "cała informacja dotycząca konfiguracji użytkownika w systemie jest zapisana jedynie w pliku /etc/passwd",
        "inline_explanation": "(Są też inne pliki, np. /etc/group, /etc/shadow)",
        "correct": false
      },
      {
        "text": "nazwa użytkownika w systemie UNIX musi być unikalna, zaś numer identyfikacyjny może się powtarzać",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "system PAM umożliwia m.in. odnotowywanie nieudanych prób podłączania się do systemu",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "technika shadow umożliwia podglądnięcie postaci zaszyfrowanej hasła każdego użytkownika przez dowolnego użytkownika",
        "inline_explanation": "(Tylko root ma dostęp do shadow)",
        "correct": false
      }
    ],
    "explanation": "System PAM (Pluggable Authentication Modules) zarządza polityką uwierzytelniania. Informacje o użytkownikach są rozproszone (passwd, shadow, group). UID teoretycznie może się powtarzać (wskazując na tego samego użytkownika logicznego), ale nazwa (login) musi być unikalna."
  },
  {
    "id": 38,
    "question": "Zaznacz prawdziwe stwierdzenia na temat procesów w systemie UNIX:",
    "options": [
      {
        "text": "proces jest wykonaniem programu i składa się ze zbiorowości bajtów, w których wyróżnia się instrukcje maszynowe (tzw. tekst), dane i stos",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "w kategoriach praktycznych proces jest jednostką utworzoną za pomocą funkcji systemowej fork (z wyjątkiem procesu o numerze 0)",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "każdy uruchomiony w systemie UNIX proces otrzymuje od procesu potomnego dostęp do jego zmiennych środowiskowych",
        "inline_explanation": "(Na odwrót: potomny dziedziczy od macierzystego)",
        "correct": false
      },
      {
        "text": "każdy uruchomiony w systemie UNIX proces otrzymuje od systemu trzy otwarte pliki o numerach 0, 1 i 2",
        "inline_explanation": "(STDIN, STDOUT, STDERR)",
        "correct": true
      },
      {
        "text": "rekord w tablicy procesów znajdującej się w jądrze systemu zawiera podstawowe informacje o procesie (właściciele, lista segmentów, wskaźniki do U-obszaru)",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "liczba możliwych do uruchomienia procesów jest ograniczona jedynie rozmiarem pamięci RAM",
        "inline_explanation": "(Ogranicza ją też tabela procesów/PID)",
        "correct": false
      }
    ],
    "explanation": "Każdy proces otrzymuje standardowe strumienie: 0 (wejście), 1 (wyjście), 2 (błędy). Struktura procesu obejmuje segment tekstu (kod), danych (zmienne) oraz stos."
  },
  {
    "id": 39,
    "question": "Interpretery poleceń systemu UNIX:",
    "options": [
      {
        "text": "w niektórych interpreterach poleceń można uniemożliwić odłączanie się od systemu poprzez wykorzystanie sekwencji Ctrl-D dzięki ustawieniu wartości odpowiedniej zmiennej środowiskowej",
        "inline_explanation": "(np. zmienna IGNOREEOF)",
        "correct": true
      },
      {
        "text": "wszystkie polecenia shella zwracają wartość 0 (zero), kiedy wykonanie ich zakończy się niepowodzeniem lub wartość różną od 0 (zazwyczaj 1) w przypadku przeciwnym",
        "inline_explanation": "(Na odwrót: 0 oznacza sukces, >0 błąd)",
        "correct": false
      },
      {
        "text": "każdy interpreter wykorzystuje trzy podstawowe typy zmiennych: specjalne, środowiska oraz programowe",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "błędne wykonanie komendy w linii komend można rozpoznać m. in. po zapisach do urządzenia /dev/null",
        "inline_explanation": "(/dev/null to 'czarna dziura', zapisane tam błędy znikają bezpowrotnie)",
        "correct": false
      }
    ],
    "explanation": "Standardowo Ctrl-D wysyła EOF (End Of File) i zamyka shella, ale ustawienie IGNOREEOF wymusza użycie komendy 'exit' lub wielokrotnego naciśnięcia Ctrl-D. W Unixie kod powrotu 0 oznacza sukces, a kody niezerowe oznaczają błąd."
  },
  {
    "id": 40,
    "question": "W systemie operacyjnym UNIX:",
    "options": [
      {
        "text": "nie ma możliwości odnotowywania nieudanych prób podłączania się do systemu",
        "inline_explanation": "(Można, np. przez PAM lub logi systemowe)",
        "correct": false
      },
      {
        "text": "każda komenda posiada inną składnię",
        "inline_explanation": "(Zgodnie z kluczem uznane za prawdę, choć dyskusyjne)",
        "correct": true
      },
      {
        "text": "istnieje możliwość zabronienia podłączania się do systemu wybranemu użytkownikowi z wykorzystaniem protokołu SSH",
        "inline_explanation": "(np. w pliku konfiguracyjnym sshd_config)",
        "correct": true
      },
      {
        "text": "każdy użytkownik posiada unikalną nazwę oraz unikalny numer",
        "inline_explanation": "(Tylko nazwę musi mieć unikalną, UID teoretycznie może się powtarzać)",
        "correct": false
      }
    ],
    "explanation": "Systemy Unixowe mają rozbudowane mechanizmy logowania zdarzeń (syslog, auth.log). Konfiguracja SSH (DenyUsers/AllowUsers) pozwala precyzyjnie zarządzać dostępem."
  },
  {
    "id": 41,
    "question": "W systemie plików systemu UNIX:",
    "options": [
      {
        "text": "system plików składa się z ciągu bloków logicznych zawierających 512, 1024, 2048 lub dowolną inną wielokrotność 512 bajtów",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "system plików przed użyciem należy zamontować, gdyż inaczej zawarte w nim dane nie będą dostępne",
        "inline_explanation": "(Komenda mount)",
        "correct": true
      },
      {
        "text": "prawo SUID obowiązuje dla pliku i dla katalogu: w przypadku pliku oznacza, iż program uruchamiany jest z UID właściciela pliku, zaś w przypadku katalogu, że użytkownik pracuje w nim (katalogu) z UID właściciela",
        "inline_explanation": "(Dla katalogów SUID/SGID dotyczy zazwyczaj dziedziczenia grupy dla nowych plików)",
        "correct": false
      },
      {
        "text": "cofnięcie prawa zapisu do pliku dla jego właściciela uniemożliwia usunięcie go",
        "inline_explanation": "(O możliwości usunięcia pliku decydują uprawnienia do katalogu, w którym plik się znajduje)",
        "correct": false
      }
    ],
    "explanation": "Aby system operacyjny widział pliki na partycji, musi ona zostać zamontowana w drzewie katalogów. Uprawnienia do usuwania plików są związane z prawem zapisu (w) do katalogu nadrzędnego, a nie samego pliku."
  },
  {
    "id": 42,
    "question": "W systemie plików systemu UNIX (część 2):",
    "options": [
      {
        "text": "stosowany w systemach plików systemu UNIX system kontyngentów (quota) jest zorientowany na użytkownika i obejmuje wszystkie jego pliki w całym drzewie katalogów od katalogu głównego począwszy",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "każdy plik opisuje dokładnie jeden i-węzeł",
        "inline_explanation": "(Nawet jeśli ma wiele nazw/hardlinków, i-węzeł jest jeden)",
        "correct": true
      },
      {
        "text": "prawo SUID nadane plikowi przechowującemu kod wykonywalny np. komendy passwd umożliwia modyfikację zawartości plików, których właścicielem jest właściciel pliku /bin/passwd",
        "inline_explanation": "(Dzięki temu zwykły użytkownik może zmienić swoje hasło w /etc/shadow)",
        "correct": true
      },
      {
        "text": "i-węzły są przechowywane w systemach plików na dysku oraz kopiowane do tablic jądra systemu w chwili montowania systemu plików",
        "inline_explanation": "(Jądro wczytuje je w momencie dostępu do pliku, a nie przy montowaniu)",
        "correct": false
      }
    ],
    "explanation": "Mechanizm SUID sprawia, że proces uruchomiony przez użytkownika działa z uprawnieniami właściciela pliku wykonywalnego (często roota), co pozwala na wykonywanie uprzywilejowanych operacji."
  },
  {
    "id": 43,
    "question": "Szyfrowanie kluczem publicznym w szyfrowaniu asymetrycznym:",
    "options": [
      {
        "text": "pozwala jedynie właściwemu odbiorcy odkodować komunikat",
        "inline_explanation": "(Technicznie: pozwala temu, kto ma klucz prywatny)",
        "correct": false
      },
      {
        "text": "tylko posiadacz klucza prywatnego może odkodować komunikat",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "wystarczy użyć tego samego klucza do deszyfrowania wiadomości",
        "inline_explanation": "(To opis szyfrowania symetrycznego)",
        "correct": false
      },
      {
        "text": "wiadomość zaszyfrowana za pomocą klucza publicznego może być odszyfrowana tylko za pomocą klucza prywatnego",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "tworzy funkcję skrótu w podpisie elektronicznym",
        "inline_explanation": "(Klucz prywatny służy do podpisywania skrótu)",
        "correct": true
      },
      {
        "text": "pozwala każdemu odkodować komunikat",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "W kryptografii asymetrycznej para kluczy (prywatny i publiczny) jest matematycznie powiązana. To, co zaszyfrowano kluczem publicznym, można odszyfrować tylko prywatnym (poufność). To, co zaszyfrowano (podpisano) prywatnym, można zweryfikować publicznym (autentyczność/podpis)."
  },
  {
    "id": 44,
    "question": "Jeżeli elementy w tablicy są posortowane możliwe jest wyszukiwanie:",
    "options": [
      {
        "text": "sekwencyjne",
        "inline_explanation": "(Możliwe zawsze, niezależnie od posortowania)",
        "correct": true
      },
      {
        "text": "binarne",
        "inline_explanation": "(Wymaga posortowania, złożoność O(log n))",
        "correct": true
      },
      {
        "text": "interpolacyjne",
        "inline_explanation": "(Ulepszone binarne, szacuje pozycję, wymaga posortowania)",
        "correct": true
      },
      {
        "text": "żadne z wymienionych",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Posortowanie tablicy otwiera drogę do szybszych algorytmów wyszukiwania (binarne, interpolacyjne), ale nie zabrania stosowania najprostszego wyszukiwania sekwencyjnego (liniowego)."
  },
  {
    "id": 45,
    "question": "Przy rozmieszczaniu algorytmicznym (hashing) kolizja może wystąpić, gdy:",
    "options": [
      {
        "text": "klucze w dwóch rozmieszczanych rekordach są identyczne",
        "inline_explanation": "(Wtedy hasze muszą być identyczne)",
        "correct": true
      },
      {
        "text": "klucze w dwóch rozmieszczanych rekordach są różne",
        "inline_explanation": "(Dwa różne klucze mogą dać ten sam hash)",
        "correct": true
      },
      {
        "text": "znumeryzowane klucze dwóch rekordów są różne",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "znumeryzowane klucze dwóch rekordów są identyczne",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Kolizja w tablicy mieszającej występuje wtedy, gdy funkcja skrótu (hashująca) zwraca ten sam indeks dla dwóch różnych kluczy (co jest naturalne przy ograniczonej wielkości tablicy). Oczywiście dla identycznych kluczy wynik funkcji też jest ten sam."
  },
  {
    "id": 46,
    "question": "Najszybsza metoda sortowania oparta o porównywanie kluczy posiada złożoność:",
    "options": [
      {
        "text": "liniową",
        "inline_explanation": "(O(n) osiągalne tylko dla metod nieporównujących, np. Counting Sort)",
        "correct": false
      },
      {
        "text": "liniowo-logarytmiczną",
        "inline_explanation": "(O(n log n))",
        "correct": true
      },
      {
        "text": "stałą",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "kwadratową",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Udowodniono matematycznie, że dolną granicą złożoności pesymistycznej dla dowolnego algorytmu sortowania opartego na porównaniach jest Ω(n log n)."
  },
  {
    "id": 47,
    "question": "Ekstensywna metoda sortowania to:",
    "options": [
      {
        "text": "taka, w której czas sortowania wzrasta wraz ze wzrostem tablicy",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "taka, która wymaga dodatkowej pamięci porównywalnej z rozmiarem sortowanej struktury",
        "inline_explanation": "(Złożoność pamięciowa O(n))",
        "correct": true
      },
      {
        "text": "taka, która wymaga dodatkowej pamięci porównywalnej z rozmiarem pojedynczego rekordu",
        "inline_explanation": "(To algorytmy 'w miejscu' / in-place)",
        "correct": false
      },
      {
        "text": "każda szybka metoda sortowania",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Algorytmy ekstensywne (out-of-place) potrzebują dodatkowego bufora pamięci o rozmiarze zależnym od n (np. Merge Sort w typowej implementacji na tablicach). Przeciwieństwem są algorytmy 'in-place' (w miejscu), np. Bubble Sort czy Heap Sort."
  },
  {
    "id": 48,
    "question": "Stabilną metodą sortowania jest sortowanie:",
    "options": [
      {
        "text": "bąbelkowe",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "grzebieniowe",
        "inline_explanation": "(Niestabilne)",
        "correct": false
      },
      {
        "text": "kubełkowe",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "pozycyjne",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "przez kopcowanie",
        "inline_explanation": "(Niestabilne)",
        "correct": false
      },
      {
        "text": "przez scalanie",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "przez wstawianie",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "szybkie",
        "inline_explanation": "(Quicksort jest niestabilny)",
        "correct": false
      },
      {
        "text": "przez zliczanie",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Sortowanie stabilne zachowuje względną kolejność elementów o tych samych kluczach. Do niestabilnych należą m.in.: QuickSort, HeapSort (przez kopcowanie), Selection Sort (przez wybieranie)."
  },
  {
    "id": 49,
    "question": "Które metody sortowania mają złożoność $O(n)$?",
    "options": [
      {
        "text": "bąbelkowe",
        "inline_explanation": "($O(n^2)$)",
        "correct": false
      },
      {
        "text": "kubełkowe",
        "inline_explanation": "(Bucket Sort)",
        "correct": true
      },
      {
        "text": "pozycyjne",
        "inline_explanation": "(Radix Sort)",
        "correct": true
      },
      {
        "text": "przez scalanie",
        "inline_explanation": "($O(n \\log n)$)",
        "correct": false
      },
      {
        "text": "przez zliczanie",
        "inline_explanation": "(Counting Sort)",
        "correct": true
      },
      {
        "text": "szybkie",
        "inline_explanation": "($O(n \\log n)$)",
        "correct": false
      }
    ],
    "explanation": "Złożoność liniową $O(n)$ mogą osiągnąć tylko algorytmy nieoparte na porównywaniu elementów (non-comparison sorts), takie jak sortowanie przez zliczanie, kubełkowe czy pozycyjne, zazwyczaj przy pewnych założeniach dotyczących danych wejściowych."
  },
  {
    "id": 50,
    "question": "Które metody sortowania mają złożoność $O(n^2)$?",
    "options": [
      {
        "text": "bąbelkowe",
        "inline_explanation": "(Bubble Sort)",
        "correct": true
      },
      {
        "text": "kubełkowe",
        "inline_explanation": "($O(n)$)",
        "correct": false
      },
      {
        "text": "przez scalanie",
        "inline_explanation": "($O(n \\log n)$)",
        "correct": false
      },
      {
        "text": "przez wstawianie",
        "inline_explanation": "(Insertion Sort)",
        "correct": true
      },
      {
        "text": "przez wybieranie",
        "inline_explanation": "(Selection Sort)",
        "correct": true
      },
      {
        "text": "szybkie",
        "inline_explanation": "(Średnio $O(n \\log n)$)",
        "correct": false
      }
    ],
    "explanation": "Do algorytmów o złożoności kwadratowej należą proste algorytmy takie jak bąbelkowe, przez wstawianie i przez wybieranie. Są one nieefektywne dla dużych zbiorów danych."
  },
  {
    "id": 51,
    "question": "Drzewo BST jest drzewem AVL, gdy:",
    "options": [
      {
        "text": "dla każdego wierzchołka rozmiary jego poddrzew różnią się co najwyżej o 1",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "dla każdego wierzchołka wysokości jego poddrzew różnią się co najwyżej o 1",
        "inline_explanation": "(Warunek zrównoważenia)",
        "correct": true
      },
      {
        "text": "dla każdego wierzchołka wysokości jego poddrzew różnią się dokładnie o 1",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "dla każdego wierzchołka rozmiary jego poddrzew różnią się dokładnie o 1",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Drzewo AVL to zrównoważone drzewo poszukiwań binarnych (BST), w którym wysokość lewego i prawego poddrzewa każdego węzła różni się co najwyżej o jeden."
  },
  {
    "id": 52,
    "question": "Drzewo binarne pełne o N poziomach posiada:",
    "options": [
      {
        "text": "N węzłów",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "$2*N$ węzłów",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "$2^N$ węzłów",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "$(2^N)-1$ węzłów",
        "inline_explanation": "(Suma ciągu geometrycznego: $2^0 + ... + 2^{N-1}$)",
        "correct": true
      }
    ],
    "explanation": "Na poziomie k (licząc od 0) znajduje się $2^k$ węzłów. Suma węzłów dla N poziomów (od 0 do N-1) wynosi $\\sum_{i=0}^{N-1} 2^i = 2^N - 1$."
  },
  {
    "id": 53,
    "question": "Złożoność wyszukiwania w drzewie AVL jest:",
    "options": [
      {
        "text": "liniowa ze względu na liczbę poziomów",
        "inline_explanation": "(Bo musimy zejść w dół drzewa)",
        "correct": true
      },
      {
        "text": "kwadratowa ze względu na liczbę poziomów",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "liniowa ze względu na liczbę węzłów",
        "inline_explanation": "(To dotyczy niezrównoważonego BST)",
        "correct": false
      },
      {
        "text": "logarytmiczna ze względu na liczbę węzłów",
        "inline_explanation": "(Wysokość drzewa AVL to $O(\\log n)$)",
        "correct": true
      }
    ],
    "explanation": "Wyszukiwanie w drzewie binarnym zależy od jego wysokości. Drzewo AVL jest zrównoważone, więc jego wysokość (liczba poziomów) jest rzędu $O(\\log n)$, gdzie n to liczba węzłów."
  },
  {
    "id": 54,
    "question": "Drzewo rozpinające graf zawiera:",
    "options": [
      {
        "text": "niektóre wierzchołki grafu",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "wszystkie wierzchołki grafu",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "żadne z wymienionych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "cykl Hamiltona",
        "inline_explanation": "(Drzewo z definicji nie posiada cykli)",
        "correct": false
      }
    ],
    "explanation": "Drzewo rozpinające (Spanning Tree) to podgraf, który jest drzewem i zawiera wszystkie wierzchołki grafu wyjściowego, połączone minimalną liczbą krawędzi."
  },
  {
    "id": 55,
    "question": "Ile cykli Hamiltona posiada graf pełny o N wierzchołkach?",
    "options": [
      {
        "text": "N",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "1",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "0",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "$N^2$",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "N!",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "$(N-1)!/2$",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Mamy $(N-1)$ kandydatów na pierwszą krawędź (z ustalonego wierzchołka startowego), $(N-2)$ na drugą, itd., co daje $(N-1)!$ permutacji. Ponieważ graf jest nieskierowany (cykl A-B-C to to samo co C-B-A), dzielimy wynik przez 2."
  },
  {
    "id": 56,
    "question": "Zadanie o rozmiarze n, realizowane pewnym algorytmem o złożoności $f(n)$, zostało sprowadzone do dwóch podzadań o rozmiarze $n/2$ każde oraz do n działań o stałym czasie wykonania, zapewniających rozbicie i scalenie zadania. Złożoność $f(n)$ wynosi:",
    "options": [
      {
        "text": "$f(n) = O(\\log(n))$",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "$f(n) = O(n \\log(n))$",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "$f(n) = O(n + \\log(n))$",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "$f(n) = O(n)$",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Jest to opis algorytmu Sortowania przez Scalanie (Merge Sort). Rekurencja ma postać $T(n) = 2T(n/2) + O(n)$, co zgodnie z Twierdzeniem o Rekurencji Uniwersalnej (Master Theorem) daje złożoność $O(n \\log n)$."
  },
  {
    "id": 57,
    "question": "Dla problemu komiwojażera algorytm pozwalający wyznaczyć rozwiązanie optymalne:",
    "options": [
      {
        "text": "istnieje i ma złożoność wielomianową",
        "inline_explanation": "(Problem jest NP-trudny, więc nie znamy takiego algorytmu)",
        "correct": false
      },
      {
        "text": "istnieje i ma złożoność wykładniczą",
        "inline_explanation": "(Np. algorytm Helda-Karpa o złożoności $O(n^2 2^n)$)",
        "correct": true
      },
      {
        "text": "nie istnieje",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Problem komiwojażera jest problemem NP-trudnym. Istnieją algorytmy dokładne (znajdujące optimum), ale mają one złożoność wykładniczą. Algorytmy wielomianowe istnieją tylko dla rozwiązań przybliżonych."
  },
  {
    "id": 58,
    "question": "Dana jest procedura: Proc(n) { if (warunek(x)) then { A(x); Proc(f(n)); B(x) } else C(x) }. Przyjmijmy konwencję, że np. zapis AAABCC oznacza trzykrotne wykonanie instrukcji A, itd. Następujące sekwencje instrukcji mogą być wynikiem wywołania powyższej procedury:",
    "options": [
      {
        "text": "AACBB",
        "inline_explanation": "(2 razy A, 1 raz C, 2 razy B - poprawne)",
        "correct": true
      },
      {
        "text": "ACBB",
        "inline_explanation": "(Liczba A musi być równa liczbie B)",
        "correct": false
      },
      {
        "text": "AACCBB",
        "inline_explanation": "(C wykonuje się tylko raz w warunku stopu)",
        "correct": false
      },
      {
        "text": "ACCB",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "C",
        "inline_explanation": "(Przypadek, gdy warunek od razu jest fałszywy - poprawne)",
        "correct": true
      },
      {
        "text": "AAACCCBBB",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "AABBC",
        "inline_explanation": "(Zła kolejność, C musi być w środku)",
        "correct": false
      }
    ],
    "explanation": "Struktura procedury odpowiada gramatyce bezkontekstowej $S \\to ASB | C$. Każde wywołanie rekurencyjne dokłada jedno A przed i jedno B po. Rekurencja kończy się pojedynczym wywołaniem C. Zatem poprawne ciągi to $A^n C B^n$ (tyle samo A co B, z C w środku)."
  },
  {
    "id": 59,
    "question": "Dana w C, C++, czy Javie umieszczana jest w spójnym obszarze pamięci operacyjnej:",
    "options": [
      {
        "text": "tylko dla danych typów predefiniowanych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "tylko dla danych skalarnych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "tylko dla danych złożonych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "i dla danych skalarnych, i dla danych złożonych",
        "inline_explanation": "(Wymienione języki dążą do spójnej reprezentacji struktur/tablic)",
        "correct": true
      }
    ],
    "explanation": "W językach takich jak C czy C++ tablice i struktury zajmują ciągły blok pamięci. W Javie obiekty również alokowane są w stercie jako spójne bloki (choć tablice obiektów to tablice referencji)."
  },
  {
    "id": 60,
    "question": "W językach imperatywnych (również obiektowych) przy wyborze reprezentacji dla danych rzeczywistych (zmiennoprzecinkowych) pojawiają się problemy:",
    "options": [
      {
        "text": "wystąpienia nadmiaru",
        "inline_explanation": "(Overflow - przekroczenie zakresu wykładnika na plus)",
        "correct": true
      },
      {
        "text": "wystąpienia niedomiaru",
        "inline_explanation": "(Underflow - liczba zbyt bliska zera, by ją zapisać)",
        "correct": true
      },
      {
        "text": "dokładności",
        "inline_explanation": "(Ograniczona precyzja mantysy)",
        "correct": true
      },
      {
        "text": "braku możliwości zapisu liczby 0",
        "inline_explanation": "(Zero ma swoją reprezentację w standardzie IEEE 754)",
        "correct": false
      }
    ],
    "explanation": "Arytmetyka zmiennoprzecinkowa (floating point) jest ze swojej natury przybliżona i ograniczona. Problemy obejmują skończoną precyzję (zaokrąglenia) oraz ograniczony zakres (możliwość wygenerowania nieskończoności przy nadmiarze lub utraty precyzji przy niedomiarze)."
  },
  {
    "id": 61,
    "question": "Wskazania (pointers) w C, C++ używane są do reprezentowania (wskazywania):",
    "options": [
      {
        "text": "obszarów pamięci operacyjnej",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "zmiennych złożonych",
        "inline_explanation": "(np. struktur, tablic)",
        "correct": true
      },
      {
        "text": "zmiennych skalarnych",
        "inline_explanation": "(np. int, char)",
        "correct": true
      },
      {
        "text": "funkcji i metod",
        "inline_explanation": "(Wskaźniki na funkcje)",
        "correct": true
      }
    ],
    "explanation": "Wskaźnik w C/C++ to po prostu zmienna przechowywująca adres w pamięci. Ponieważ w pamięci może znajdować się wszystko (kod, dane proste, dane złożone), wskaźnik może wskazywać na każdy z tych elementów."
  },
  {
    "id": 62,
    "question": "W jaki sposób można obliczyć długość tekstu przekazanego jako argument w poniższej funkcji w języku C? void foo (const char* txt) { ... }",
    "options": [
      {
        "text": "sizeof (txt)",
        "inline_explanation": "(Zwróci rozmiar wskaźnika, np. 4 lub 8 bajtów)",
        "correct": false
      },
      {
        "text": "strlen (txt)",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "txt.length()",
        "inline_explanation": "(To składnia C++, obiekt string)",
        "correct": false
      },
      {
        "text": "zliczając, ile znaków występuje w tekście od znaku na który wskazuje wskaźnik do znaku końca łańcucha znaków ('\\0')",
        "inline_explanation": "(To dokładnie robi funkcja strlen)",
        "correct": true
      }
    ],
    "explanation": "W C łańcuchy znaków (C-strings) są zakończone znakiem null ('\\0'). Aby poznać ich długość, trzeba policzyć znaki aż do napotkania zera (robi to funkcja `strlen`). Operator `sizeof` na wskaźniku zwróci tylko rozmiar adresu w pamięci."
  },
  {
    "id": 63,
    "question": "Co możesz powiedzieć o poniższej deklaracji w języku C? int t[10] = {1, 2, [4]=1};",
    "options": [
      {
        "text": "zgodnie ze standardem C99 spowoduje ona utworzenie tablicy zawierającej 10 elementów, z których 7 ma wartość 0",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "da ona taki sam efekt, jak deklaracja: int t[] = {1, 2, 0, 0, 1}",
        "inline_explanation": "(Nie, bo t[] miałaby rozmiar 5, a t[10] ma rozmiar 10)",
        "correct": false
      },
      {
        "text": "jest to błąd składniowy",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Jest to tzw. 'designated initializer' wprowadzony w C99. Tablica ma rozmiar 10. Indeksy 0, 1 i 4 są zainicjalizowane jawnie (wartości 1, 2, 1). Pozostałe elementy są automatycznie zerowane. Tablica wygląda tak: {1, 2, 0, 0, 1, 0, 0, 0, 0, 0}."
  },
  {
    "id": 64,
    "question": "W jaki sposób obliczyć długość tablicy w funkcji foo() w języku C? void foo (double t[]) { // dlugosc tablicy t? }",
    "options": [
      {
        "text": "nie da się obliczyć",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "po wykonaniu poniższej instrukcji długość tablicy będzie umieszczona w zmiennej len: int len; for(len=0; t[len]; len++);",
        "inline_explanation": "(Działa tylko dla tablic zakończonych wartownikiem, tu byłby błąd)",
        "correct": false
      },
      {
        "text": "używając operatora sizeof(t) / sizeof(double)",
        "inline_explanation": "(Zwróci rozmiar wskaźnika dzielony przez rozmiar doubla - bzdura)",
        "correct": false
      }
    ],
    "explanation": "Przy przekazywaniu tablicy do funkcji w C następuje degradacja do wskaźnika (decay to pointer). Funkcja otrzymuje tylko adres początku danych, tracąc informację o rozmiarze bufora. Rozmiar musi być przekazany jako osobny argument."
  },
  {
    "id": 65,
    "question": "Która z implementacji funkcji zwracającej tablicę w języku C jest poprawna?",
    "options": [
      {
        "text": "int[] getTable() { int tab [10]; return tab; }",
        "inline_explanation": "(Błąd: zwraca adres zmiennej lokalnej, która przestaje istnieć po wyjściu z funkcji)",
        "correct": false
      },
      {
        "text": "int* getTable (int n) { return (int*) malloc(n * sizeof(int)); }",
        "inline_explanation": "(Poprawne: alokacja na stercie)",
        "correct": true
      },
      {
        "text": "int* getTable (int n) { return (int*) calloc(n, sizeof(int)); }",
        "inline_explanation": "(Poprawne: alokacja na stercie z zerowaniem)",
        "correct": true
      },
      {
        "text": "żadna z wymienionych",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "W języku C nie można zwracać tablic utworzonych lokalnie na stosie (opcja a), ponieważ pamięć ta jest zwalniana po zakończeniu funkcji. Aby zwrócić tablicę, należy zaalokować ją dynamicznie (malloc/calloc) lub użyć tablicy statycznej (static)."
  },
  {
    "id": 66,
    "question": "Przeanalizuj poniższą deklarację w języku C: int (*x) (int, int);",
    "options": [
      {
        "text": "zmienna x jest dwuwymiarową tablicą wskaźników typu int* o zmiennym rozmiarze",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "deklaracja jest niezgodna ze składnią języka",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "zmienna x jest wskaźnikiem na funkcję przyjmującą dwa argumenty typu int, zwracającą wartość typu int",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "zmienna x jest funkcją zwracającą wskaźnik na int",
        "inline_explanation": "(To byłoby: int* x(int, int))",
        "correct": false
      }
    ],
    "explanation": "Nawiasy `(*x)` wskazują, że x jest wskaźnikiem. Nawiasy `(int, int)` po prawej oznaczają, że wskazuje on na funkcję przyjmującą dwa inty. Typ `int` na początku określa typ zwracany przez tę funkcję."
  },
  {
    "id": 67,
    "question": "Które stwierdzenia dotyczące operatorów w języku C/C++ są poprawne:",
    "options": [
      {
        "text": "operatory addytywne (+, -) mają mniejszy priorytet niż multiplikatywne (*, /, %)",
        "inline_explanation": "(Standardowa kolejność działań)",
        "correct": true
      },
      {
        "text": "wyrażenie z==++z jest zawsze fałszywe",
        "inline_explanation": "(To zachowanie niezdefiniowane - undefined behavior)",
        "correct": false
      },
      {
        "text": "operator przypisania (=) ma wyższy priorytet niż operator porównania (==)",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "żadne z pozostałych",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "W C/C++ mnożenie i dzielenie są wykonywane przed dodawaniem i odejmowaniem (mają wyższy priorytet), podobnie jak w matematyce."
  },
  {
    "id": 68,
    "question": "Dzięki konwencji wywołania funkcji w języku C/C++ znanej jako _cdecl możliwa jest implementacja funkcji o zmiennej liczbie argumentów (jak printf). Które stwierdzenia są prawdziwe?",
    "options": [
      {
        "text": "w wygenerowanym kodzie wywołania funkcji argumenty umieszczane są na stosie od końca (od prawej do lewej)",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "analizując pierwszy argument na szczycie stosu można określić liczbę argumentów (dzięki kolejności odkładania)",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "to funkcja wołana (callee) czyści stos po wykonaniu",
        "inline_explanation": "(W _cdecl robi to wołający - caller)",
        "correct": false
      },
      {
        "text": "w języku C kompilator może utworzyć kod wywołania funkcji typu _cdecl nie mając żadnych informacji o typach jej parametrów",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "W konwencji `_cdecl` (domyślnej dla C) argumenty odkłada się na stos od prawej do lewej. Dzięki temu pierwszy argument (np. format string w printf) jest zawsze w znanym miejscu na wierzchu stosu, co pozwala funkcji określić, ile i jakich argumentów pobrać dalej."
  },
  {
    "id": 69,
    "question": "W jaki sposób przekazywany jest parametr będący tablicą do funkcji w języku C? np. int main(int argc, char* argv[])",
    "options": [
      {
        "text": "cała zawartość tablicy kopiowana jest na stos",
        "inline_explanation": "(Byłoby to nieefektywne)",
        "correct": false
      },
      {
        "text": "na stos przekazywany jest adres pierwszego elementu tablicy",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "tablice są zawsze przekazywane do funkcji jako wskaźnik",
        "inline_explanation": "(Decay to pointer)",
        "correct": true
      },
      {
        "text": "tablice są przekazywane przez referencję",
        "inline_explanation": "(C nie posiada referencji w sensie C++, używa wskaźników)",
        "correct": false
      }
    ],
    "explanation": "W C nie można przekazać tablicy przez wartość. Zapis `char* argv[]` jest tylko lukrem składniowym (syntactic sugar) dla `char** argv`. Do funkcji zawsze trafia wskaźnik na pierwszy element."
  },
  {
    "id": 70,
    "question": "Aby sprawdzić, czy dwa obiekty typu String w języku Java mają taką samą zawartość, można:",
    "options": [
      {
        "text": "użyć metody equals()",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "użyć operatora ==",
        "inline_explanation": "(Sprawdza identyczność referencji/adresów w pamięci, a nie treść)",
        "correct": false
      },
      {
        "text": "użyć metody compareTo() i sprawdzić czy zwraca 0",
        "inline_explanation": "(To też działa, choć equals jest bardziej standardowe do równości)",
        "correct": true
      },
      {
        "text": "rzutować na char[] i porównać długości",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "W Javie operator `==` dla obiektów porównuje referencje (czy to ten sam obiekt w pamięci). Do porównywania zawartości logicznej (czy napisy są takie same) służy metoda `.equals()`."
  },
  {
    "id": 71,
    "question": "Który z poniższych fragmentów kodu w języku Java sprawdza, czy obiekt wskazywany przez referencję xyz należy do klasy XYZ?",
    "options": [
      {
        "text": "if (xyz instanceof XYZ)",
        "inline_explanation": "(Standardowy operator sprawdzania typu)",
        "correct": true
      },
      {
        "text": "if (xyz.dynamicCastTo(XYZ.class) != null)",
        "inline_explanation": "(Składnia nieistniejąca w Javie)",
        "correct": false
      },
      {
        "text": "XYZ.class.isInstance(xyz)",
        "inline_explanation": "(Dynamiczne sprawdzenie przez refleksję)",
        "correct": true
      },
      {
        "text": "XYZ.class.isAssignableFrom(xyz.getClass())",
        "inline_explanation": "(Sprawdzenie czy klasę obiektu można przypisać do zmiennej typu XYZ)",
        "correct": true
      }
    ],
    "explanation": "W Javie podstawowym sposobem jest operator `instanceof`. Mechanizmy refleksji (`isInstance`, `isAssignableFrom`) pozwalają na to samo w sposób dynamiczny (gdy typ nie jest znany w czasie kompilacji)."
  },
  {
    "id": 72,
    "question": "Tablica w języku Java jest zadeklarowana jako: int tab[] = {3, 2, 1, 0}; Który z fragmentów kodu poprawnie wypisze jej elementy?",
    "options": [
      {
        "text": "for (int i: tab) System.out.println(tab[i] + \" \");",
        "inline_explanation": "(Wypisze '0 1 2 3' zamiast elementów, bo używa wartości jako indeksów)",
        "correct": false
      },
      {
        "text": "for (int i=0; i < tab.length; i++) System.out.println(tab[i] + \" \");",
        "inline_explanation": "(Klasyczna pętla for)",
        "correct": true
      },
      {
        "text": "for (int i: tab) System.out.println(i + \" \");",
        "inline_explanation": "(Pętla for-each, i przyjmuje wartości elementów)",
        "correct": true
      },
      {
        "text": "System.out.println(tab);",
        "inline_explanation": "(Wypisze tylko adres/hashcode tablicy)",
        "correct": false
      }
    ],
    "explanation": "Pętla 'for-each' (`for (int i: tab)`) iteruje po wartościach, więc `i` to kolejny element tablicy. W opcji pierwszej błędnie użyto tej wartości jako indeksu (`tab[i]`)."
  },
  {
    "id": 73,
    "question": "Które zdanie opisujące własności klas w języku Java jest prawdziwe?",
    "options": [
      {
        "text": "aby zaznaczyć, że klasa dziedziczy po kilku klasach, należy podać ich listę po słowie kluczowym extends",
        "inline_explanation": "(Java nie wspiera wielodziedziczenia klas)",
        "correct": false
      },
      {
        "text": "dla każdej klasy w języku Java możliwe jest zdefiniowanie klasy potomnej",
        "inline_explanation": "(Nie dla klas oznaczonych jako final)",
        "correct": false
      },
      {
        "text": "klasa może implementować wiele interfejsów",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "w języku Java zawsze bezpośrednio możemy dziedziczyć po (maksymalnie) jednej klasie",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Java stosuje model pojedynczego dziedziczenia klas (`extends`), ale pozwala na implementację dowolnej liczby interfejsów (`implements`), co pozwala ominąć niektóre ograniczenia tego modelu."
  },
  {
    "id": 74,
    "question": "W jaki sposób usuwane są obiekty w języku Java?",
    "options": [
      {
        "text": "usuwa się je przez przekazanie referencji do usuwanego obiektu do metody System.gc()",
        "inline_explanation": "(Metoda ta nie przyjmuje argumentów i jest tylko sugestią)",
        "correct": false
      },
      {
        "text": "nie są programowo usuwane, to środowisko wykonawcze podejmuje decyzje czy i kiedy je usunąć",
        "inline_explanation": "(Garbage Collection)",
        "correct": true
      },
      {
        "text": "za pomocą operatora delete",
        "inline_explanation": "(To C++, w Javie nie ma delete)",
        "correct": false
      },
      {
        "text": "automatycznie po wyjściu z bloku kodu",
        "inline_explanation": "(Tylko referencje znikają, obiekt na stercie może żyć dłużej)",
        "correct": false
      }
    ],
    "explanation": "W Javie zarządzanie pamięcią jest automatyczne. Garbage Collector (GC) działający w tle sam wykrywa obiekty, do których nie prowadzą żadne aktywne referencje, i zwalnia zajmowaną przez nie pamięć."
  },
  {
    "id": 75,
    "question": "Które z poniższych stwierdzeń odnoszące się do klas wewnętrznych i zagnieżdżonych w języku Java są prawdziwe?",
    "options": [
      {
        "text": "w metodach klasy zagnieżdżonej (zadeklarowanej z modyfikatorem static) jest dostępna referencja Outer.this",
        "inline_explanation": "(Klasa statyczna nie ma dostępu do instancji klasy zewnętrznej)",
        "correct": false
      },
      {
        "text": "obiekt klasy wewnętrznej ma swój stan niezależny od innych obiektów powiązanych z obiektem klasy zewnętrznej",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "klasa wewnętrzna (zadeklarowana bez modyfikatora static) nie ma dostępu do prywatnych zmiennych klasy zewnętrznej",
        "inline_explanation": "(Ma pełny dostęp)",
        "correct": false
      },
      {
        "text": "klasy wewnętrzne muszą dziedziczyć po otaczających je klasach zewnętrznych",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Klasa wewnętrzna (niestatyczna) jest związana z instancją klasy zewnętrznej i ma dostęp do jej pól (nawet prywatnych). Statyczna klasa zagnieżdżona zachowuje się jak zwykła klasa, tyle że zdefiniowana wewnątrz innej (nie ma niejawnego powiązania z instancją 'Outer')."
  },
  {
    "id": 76,
    "question": "Jaki typ w Haskellu będzie miało następujące wyrażenie: r x = x : r x ?",
    "options": [
      {
        "text": "r :: [a]",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "r :: a -> [a]",
        "inline_explanation": "(Funkcja bierze element 'a' i tworzy nieskończoną listę [a])",
        "correct": true
      },
      {
        "text": "r :: Integer -> [Integer]",
        "inline_explanation": "(Zbyt wąski typ, działa dla dowolnego 'a')",
        "correct": false
      },
      {
        "text": "r :: a -> a",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Operator dwukropka `:` w Haskellu służy do konstruowania listy (dodaje element na początek). Funkcja `r` bierze argument `x` i zwraca listę, której głową jest `x`, a ogonem wynik rekurencyjnego wywołania `r x`. Tworzy to nieskończoną listę samych elementów `x`."
  },
  {
    "id": 77,
    "question": "Jak wygląda poprawna wartość w Haskellu dla typu: data Tree a = L a | N (Tree a) a (Tree a)",
    "options": [
      {
        "text": "Tree 5 Nil Nil",
        "inline_explanation": "(Tree to nazwa typu, nie konstruktora)",
        "correct": false
      },
      {
        "text": "N (L 4) 5 (L 14')",
        "inline_explanation": "(Błąd typów: 4 to liczba, '4' to znak)",
        "correct": false
      },
      {
        "text": "N (L 4) 5 (L 4)",
        "inline_explanation": "(Poprawne: węzeł N ma lewe poddrzewo (liść 4), wartość 5 i prawe poddrzewo (liść 4))",
        "correct": true
      },
      {
        "text": "N (L '4') '5' (L '4')",
        "inline_explanation": "(Poprawne dla typu Tree Char)",
        "correct": true
      }
    ],
    "explanation": "Typ `Tree a` jest typem algebraicznym z dwoma konstruktorami: `L a` (liść z wartością) oraz `N (Tree a) a (Tree a)` (węzeł z lewym poddrzewem, wartością i prawym poddrzewem). Typ `a` musi być spójny w całym wyrażeniu (albo same liczby, albo same znaki)."
  },
  {
    "id": 78,
    "question": "Haskell jest językiem opartym o paradygmat:",
    "options": [
      {
        "text": "funkcyjny",
        "inline_explanation": "(Czysto funkcyjny - purely functional)",
        "correct": true
      },
      {
        "text": "strukturalny",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "imperatywny",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "obiektowy",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Haskell to najpopularniejszy przedstawiciel języków czysto funkcyjnych, opartych na rachunku lambda, z leniwym wartościowaniem i silnym, statycznym typowaniem."
  },
  {
    "id": 79,
    "question": "Zaznacz prawdziwe zdania odnoszące się do programowania funkcyjnego:",
    "options": [
      {
        "text": "w programowaniu funkcyjnym koncepcja funkcji jest taka, jak w algebrze",
        "inline_explanation": "(Funkcja zawsze zwraca ten sam wynik dla tych samych argumentów)",
        "correct": true
      },
      {
        "text": "programowanie funkcyjne opiera się na rachunku lambda",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "dobrym nawykiem w programowaniu funkcyjnym jest, aby zmienne były niemutowalne",
        "inline_explanation": "(Immutability to podstawa tego paradygmatu)",
        "correct": true
      },
      {
        "text": "funkcyjny styl programowania można uprawiać w ograniczonym zakresie w językach imperatywnych jak C albo JavaScript",
        "inline_explanation": "(Np. używając wskaźników na funkcje w C lub funkcji wyższego rzędu w JS)",
        "correct": true
      },
      {
        "text": "niektóre języki imperatywne zostały wyposażone w konstrukcje z języków funkcyjnych",
        "inline_explanation": "(Np. wyrażenia lambda w Javie czy C++)",
        "correct": true
      },
      {
        "text": "można używać funkcyjnego stylu programowania w języku JavaScript",
        "inline_explanation": "(JS ma silne wsparcie dla funkcji jako obywateli pierwszej kategorii)",
        "correct": true
      }
    ],
    "explanation": "Programowanie funkcyjne kładzie nacisk na obliczanie wartości funkcji matematycznych, unikanie zmiennych stanów i efektów ubocznych (side effects). Wiele nowoczesnych języków wieloparadygmatowych (Python, JS, C#) adaptuje te koncepcje."
  },
  {
    "id": 80,
    "question": "Funkcje wyższego rzędu (Higher-Order Functions) w programowaniu funkcyjnym to:",
    "options": [
      {
        "text": "funkcje zwracające inne funkcje jako rezultat obliczeń",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "funkcje, które przyjmują inne funkcje jako parametry",
        "inline_explanation": "(Np. map, filter, reduce)",
        "correct": true
      },
      {
        "text": "funkcje rekurencyjne",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "funkcje operujące na zmiennych globalnych",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Funkcja wyższego rzędu to taka, która traktuje inne funkcje jak dane: może je przyjmować jako argumenty lub je tworzyć i zwracać."
  },
  {
    "id": 81,
    "question": "Jaki mechanizm w językach funkcyjnych pozwala na wykonanie operacji na zbiorze danych (zamiast pętli)?",
    "options": [
      {
        "text": "iteracja",
        "inline_explanation": "(Pętle są typowe dla języków imperatywnych)",
        "correct": false
      },
      {
        "text": "rekurencja",
        "inline_explanation": "(Podstawowy mechanizm powtarzania czynności)",
        "correct": true
      },
      {
        "text": "funkcje specyficzne dla języka",
        "inline_explanation": "(Np. map/fold, które pod spodem używają rekurencji)",
        "correct": true
      },
      {
        "text": "warunkowy skok do etykiety",
        "inline_explanation": "(GOTO)",
        "correct": false
      }
    ],
    "explanation": "W czystym programowaniu funkcyjnym nie ma pętli (for/while) opartych na zmianie stanu licznika. Zamiast tego używa się rekurencji (często optymalizowanej jako rekurencja ogonowa) lub funkcji wyższego rzędu operujących na kolekcjach (map, fold, filter)."
  },
  {
    "id": 82,
    "question": "Wskaż, w których przypadkach klauzule instrukcji select są ułożone we właściwej kolejności:",
    "options": [
      {
        "text": "from, group by, where, having, order by",
        "inline_explanation": "(Błąd: WHERE musi być przed GROUP BY)",
        "correct": false
      },
      {
        "text": "from, where, group by, having, order by",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "from, group by, having, where, order by",
        "inline_explanation": "(Błąd: WHERE musi być przed GROUP BY)",
        "correct": false
      }
    ],
    "explanation": "Prawidłowa kolejność logiczna i składniowa w SQL to: SELECT -> FROM -> JOIN/ON -> WHERE -> GROUP BY -> HAVING -> ORDER BY. Klauzula WHERE filtruje wiersze przed grupowaniem, a HAVING filtruje grupy po zgrupowaniu."
  },
  {
    "id": 83,
    "question": "Dana jest relacja R o schemacie H={A,B,C,D,E} oraz zbiór zależności funkcyjnych F={{B,C}->{D,E}, {C, D} -> {B, E}, {D} -> {C}, {E} -> {B}}. W jakiej maksymalnie postaci normalnej jest relacja R? Zakładamy, że jest w 1NF.",
    "options": [
      {
        "text": "1NF",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "2NF",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "3NF",
        "inline_explanation": "(Wszystkie atrybuty należą do jakiegoś klucza kandydującego)",
        "correct": true
      },
      {
        "text": "BCNF",
        "inline_explanation": "(Niespełniona, bo lewa strona {B,C}->{D,E} nie jest superkluczem - brakuje A)",
        "correct": false
      },
      {
        "text": "4NF",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Klucze kandydujące to {A, B, C}, {A, D} oraz {A, C, E}. Ponieważ każdy atrybut relacji należy do któregoś z kluczy (jest atrybutem pierwotnym), relacja automatycznie spełnia warunki 3NF. Nie spełnia BCNF, ponieważ istnieją zależności (np. {D}->{C}), gdzie lewa strona nie jest nadkluczem (nie zawiera A)."
  },
  {
    "id": 84,
    "question": "Wskaż wszystkie prawdziwe stwierdzenia dotyczące trzeciej postaci normalnej (3NF):",
    "options": [
      {
        "text": "jeżeli wszystkie atrybuty ze schematu relacji są atrybutami kluczowymi, to relacja jest w 3NF",
        "inline_explanation": "(Tylko atrybuty niekluczowe mogą łamać 3NF)",
        "correct": true
      },
      {
        "text": "dowolną relację można sprowadzić do 3NF stosując dekompozycję bezstratną i zachowującą zależności funkcyjne",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "3NF oznacza, że każdy atrybut niekluczowy (informacyjny) zależy wyłącznie od klucza",
        "inline_explanation": "(Brak zależności przechodnich)",
        "correct": true
      },
      {
        "text": "BCNF jest nieco bardziej restrykcyjną wersją 3NF - w BCNF wszystkie atrybuty (również kluczowe) muszą spełniać warunek zależności wyłącznie od klucza",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "jeżeli relacja jest w BCNF, to jest również w 3NF",
        "inline_explanation": "(BCNF implikuje 3NF)",
        "correct": true
      },
      {
        "text": "jeżeli relacja jest w 3NF, to możliwe jest występowanie pewnych redundancji",
        "inline_explanation": "(Dlatego wprowadzono BCNF)",
        "correct": true
      }
    ],
    "explanation": "3NF wymaga, aby relacja była w 2NF i żaden atrybut niekluczowy nie zależał przechodnio od klucza głównego (czyli zależał 'bezpośrednio' od klucza, całego klucza i tylko od klucza)."
  },
  {
    "id": 85,
    "question": "Wskaż wszystkie prawdziwe stwierdzenia dotyczące postaci normalnej Boyce'a-Codda (BCNF):",
    "options": [
      {
        "text": "dowolną relację można sprowadzić do BCNF stosując dekompozycję bezstratną, ale niekoniecznie zachowującą zależności funkcyjne",
        "inline_explanation": "(Czasem tracimy zależności przy BCNF)",
        "correct": true
      },
      {
        "text": "dowolna relacja dwuatrybutowa jest w BCNF",
        "inline_explanation": "(Nie ma miejsca na łamanie reguł)",
        "correct": true
      },
      {
        "text": "jeżeli schemat relacji znajduje się w postaci normalnej Boyce'a-Codda, to nie ma w nim redundancji (wynikającej z zależności funkcyjnych)",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "BCNF oznacza, że lewa strona każdej nietrywialnej zależności funkcyjnej zawiera klucz",
        "inline_explanation": "(Lewa strona musi być superkluczem)",
        "correct": true
      },
      {
        "text": "atrybut z prawej strony zależności może być podstawowy",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "schematy relacji zawsze należy doprowadzać do postaci BCNF",
        "inline_explanation": "(Nie zawsze, czasem koszt utraty zależności jest zbyt duży)",
        "correct": false
      }
    ],
    "explanation": "BCNF to wzmocniona 3NF. Wymaga, aby dla każdej zależności funkcyjnej X->Y, X było superkluczem. Eliminuje to anomalie, które mogą pozostać w 3NF, gdy klucze kandydujące na siebie zachodzą."
  },
  {
    "id": 86,
    "question": "Wskaż wszystkie prawdziwe stwierdzenia dotyczące kluczy obcych w relacyjnym modelu danych:",
    "options": [
      {
        "text": "wartości klucza obcego muszą być unikatowe",
        "inline_explanation": "(Nie muszą, to relacja 1:N)",
        "correct": false
      },
      {
        "text": "klucze obce są sposobem łączenia przechowywanych danych w różnych tabelach",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "klucz obcy jest kolumną lub grupą kolumn, która czerpie swoje wartości z tej samej dziedziny, co klucz główny powiązanej z nią tabeli",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "klucz obcy musi odnosić się do istniejącej krotki lub przyjmować wartość NULL",
        "inline_explanation": "(Integralność referencyjna)",
        "correct": true
      },
      {
        "text": "klucz obcy nie musi być unikatowy w obrębie tabeli",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "klucz obcy może pochodzić z tej samej tabeli",
        "inline_explanation": "(Związek rekurencyjny, np. pracownik-szef)",
        "correct": true
      },
      {
        "text": "klucz obcy i klucz do którego się on odwołuje muszą mieć tyle samo atrybutów",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "powinny wskazywać na klucz główny (lub unikalny) w tabeli głównej",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Klucz obcy (Foreign Key) służy do wymuszania integralności referencyjnej między tabelami. Gwarantuje, że wartość w kolumnie podrzędnej odpowiada istniejącemu wierszowi w tabeli nadrzędnej (lub jest NULL)."
  },
  {
    "id": 87,
    "question": "Wskaż wszystkie prawdziwe stwierdzenia dotyczące transakcji:",
    "options": [
      {
        "text": "wykonanie instrukcji ROLLBACK powoduje anulowanie transakcji i wycofanie wprowadzonych zmian",
        "inline_explanation": "(Standardowe polecenie SQL)",
        "correct": true
      },
      {
        "text": "transakcja jest ciągiem operacji w bazie danych, które należy wykonać wszystkie lub nie wykonywać żadnej z nich",
        "inline_explanation": "(Własność Atomicity - Atomowość)",
        "correct": true
      },
      {
        "text": "równolegle wykonywane transakcje mają ten sam poziom izolacji",
        "inline_explanation": "(Zazwyczaj definiowany per sesja)",
        "correct": true
      },
      {
        "text": "dane zmodyfikowane przez transakcję, która nie została jeszcze zakończona, nigdy nie są dostępne dla innych równolegle realizowanych transakcji",
        "inline_explanation": "(Własność Isolation - Izolacja, chroni przed dirty read)",
        "correct": true
      }
    ],
  "explanation": "Transakcje w bazach danych muszą spełniać zasady ACID: Atomicity (niepodzielność), Consistency (spójność), Isolation (izolacja), Durability (trwałość)."
  },
  {
    "id": 88,
    "question": "Wskaż, które ograniczenia można definiować na poziomie kolumny (w instrukcji create table):",
    "options": [
      {
        "text": "wartość domyślna atrybutu",
        "inline_explanation": "(DEFAULT)",
        "correct": true
      },
      {
        "text": "krótsze ścieżki na płycie głównej",
        "inline_explanation": "(To kwestia sprzętowa)",
        "correct": false
      },
      {
        "text": "większy bufor",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "unikalne wartości atrybutu",
        "inline_explanation": "(UNIQUE)",
        "correct": true
      },
      {
        "text": "proste klucze główne",
        "inline_explanation": "(PRIMARY KEY)",
        "correct": true
      },
      {
        "text": "NULL/NOT NULL",
        "inline_explanation": "(Wymagalność wartości)",
        "correct": true
      },
      {
        "text": "wyzwalacze typu 'zdarzenie, warunek, akcja'",
        "inline_explanation": "(Triggery to osobne obiekty bazy danych)",
        "correct": false
      }
    ],
  "explanation": "Standardowe ograniczenia (constraints) w SQL to: NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK oraz DEFAULT."
  },
  {
    "id": 89,
    "question": "Wskaż wszystkie prawdziwe stwierdzenia dotyczące wartości NULL:",
    "options": [
      {
        "text": "w modelu relacyjnym wartość NULL jest traktowana jako trzecia, różna od false i true, wartość logiczna",
        "inline_explanation": "(Logika trójwartościowa: True, False, Unknown)",
        "correct": true
      },
      {
        "text": "dwie wartości NULL są traktowane jako równe",
        "inline_explanation": "(NULL != NULL, wynik porównania to Unknown)",
        "correct": false
      },
      {
        "text": "wartości NULL są różne od spacji, zera czy też pustego łańcucha znaków",
        "inline_explanation": "(NULL oznacza brak wartości, zero to konkretna wartość)",
        "correct": true
      },
      {
        "text": "jeżeli wystąpi w wartości atrybutu NULL, to suma po tym atrybucie też jest NULL",
        "inline_explanation": "(Każda operacja arytmetyczna z NULL daje NULL)",
        "correct": true
      },
      {
        "text": "wartość NULL oznacza zero",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Wartość NULL reprezentuje brak danych lub wartość nieznaną. Nie jest równoważna zeru ani pustemu stringowi. W logice SQL wprowadza stan 'nieznany' (Unknown), co wymaga stosowania operatorów `IS NULL` zamiast `==`."
  },
  {
    "id": 90,
    "question": "Które wyrażenie SQL zwraca wszystkie wiersze tabeli 'Osoby' posortowane malejąco według atrybutu 'Imie'?",
    "options": [
      {
        "text": "SELECT * FROM Osoby SORT BY 'Imie' DESC",
        "inline_explanation": "(Nie ma słowa kluczowego SORT BY)",
        "correct": false
      },
      {
        "text": "SELECT * FROM Osoby ORDER BY Imie DESC",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "SELECT * FROM Osoby SORT 'Imie' DESC",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "SELECT * FROM Osoby ORDER Imie DESC",
        "inline_explanation": "(Brakuje słowa BY)",
        "correct": false
      }
    ],
  "explanation": "Poprawna składnia sortowania w SQL to klauzula `ORDER BY`. Kierunek malejący określa słowo `DESC` (descending)."
  },
  {
    "id": 91,
    "question": "Jak możesz zmienić wartość 'Kowalski' na 'Nowak' w atrybucie 'Nazwisko' w tabeli 'Osoby'?",
    "options": [
      {
        "text": "MODIFY Osoby SET Nazwisko ='Nowak' WHERE Nazwisko ='Kowalski'",
        "inline_explanation": "(MODIFY służy zazwyczaj do zmiany struktury tabeli)",
        "correct": false
      },
      {
        "text": "UPDATE Osoby SET Nazwisko ='Kowalski' INTO Nazwisko ='Nowak'",
        "inline_explanation": "(Błędna składnia)",
        "correct": false
      },
      {
        "text": "UPDATE Osoby SET Nazwisko ='Nowak' WHERE Nazwisko ='Kowalski'",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "CHANGE Osoby Nazwisko 'Nowak' WHERE 'Kowalski'",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Instrukcja `UPDATE` służy do modyfikacji danych w istniejących rekordach. Składnia to: `UPDATE tabela SET kolumna = nowa_wartość WHERE warunek`."
  },
  {
    "id": 92,
    "question": "Jak można przy pomocy SQL uzyskać informację o liczbie wierszy w tabeli 'Osoby'?",
    "options": [
      {
        "text": "SELECT COUNT(*) FROM Osoby",
        "inline_explanation": "(Standardowa funkcja agregująca zliczająca wiersze)",
        "correct": true
      },
      {
        "text": "SELECT COUNT() FROM Osoby",
        "inline_explanation": "(Błąd składni, funkcja wymaga argumentu)",
        "correct": false
      },
      {
        "text": "SELECT COLUMNS() FROM Osoby",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "SELECT COLUMNS(*) FROM Osoby",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Funkcja `COUNT(*)` zlicza wszystkie wiersze w tabeli, włącznie z tymi zawierającymi wartości NULL. Można też użyć `COUNT(kolumna)`, co zliczy wiersze z wartościami niepustymi w danej kolumnie."
  },
  {
    "id": 93,
    "question": "Jak można przy pomocy SQL wybrać wszystkie wiersze z tabeli 'Osoby', w których wartość atrybutu 'Imie' zaczyna się od 'a'?",
    "options": [
      {
        "text": "SELECT * FROM Osoby WHERE Imie LIKE '%a'",
        "inline_explanation": "(To oznacza 'kończy się na a')",
        "correct": false
      },
      {
        "text": "SELECT * FROM Osoby WHERE Imie ='%a%'",
        "inline_explanation": "(To szuka dosłownego ciągu znaków '%a%')",
        "correct": false
      },
      {
        "text": "SELECT * FROM Osoby WHERE Imie LIKE 'a%'",
        "inline_explanation": "(Znak % zastępuje dowolny ciąg znaków po literze 'a')",
        "correct": true
      },
      {
        "text": "SELECT * FROM Osoby WHERE Imie = 'a'",
        "inline_explanation": "(To szuka imienia równego 'a')",
        "correct": false
      }
    ],
    "explanation": "Operator `LIKE` używa wieloznaczników: `%` (dowolny ciąg znaków) i `_` (pojedynczy znak). Wzorzec `'a%'` oznacza: pierwsza litera to 'a', a potem cokolwiek."
  },
  {
    "id": 94,
    "question": "Którą z poniższych cech musi posiadać klucz właściwy (kandydujący)?",
    "options": [
      {
        "text": "jego wartość jednoznacznie wyznacza wiersz w danej tabeli",
        "inline_explanation": "(Unikalność)",
        "correct": true
      },
      {
        "text": "jest automatycznie generowany przez System Zarządzania Bazą Danych",
        "inline_explanation": "(Może, ale nie musi)",
        "correct": false
      },
      {
        "text": "nie może być generowany przez SZBD",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "jego wartość składa się tylko z jednego atrybutu",
        "inline_explanation": "(Może być złożony)",
        "correct": false
      },
      {
        "text": "nie może być pomniejszony o żaden atrybut",
        "inline_explanation": "(Minimalność - usunięcie atrybutu powoduje utratę unikalności)",
        "correct": true
      },
      {
        "text": "żaden podzbiór jego atrybutów nie może być kluczem",
        "inline_explanation": "(To inna definicja minimalności)",
        "correct": true
      }
    ],
    "explanation": "Klucz właściwy (candidate key) to minimalny nadklucz. Musi być unikalny (identyfikować krotkę) i minimalny (nie zawierać zbędnych atrybutów)."
  },
  {
    "id": 95,
    "question": "Algebra relacji jest podstawą dla:",
    "options": [
      {
        "text": "realizacji przez relacyjny SZBD operacji języka manipulacji danymi",
        "inline_explanation": "(SQL jest oparty na algebrze relacji)",
        "correct": true
      },
      {
        "text": "budowy diagramów ERD",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "budowy diagramów DFD",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "algorytmicznych języków relacyjnych baz danych",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Algebra relacji to teoretyczny język zapytań, składający się z operatorów (selekcja, rzutowanie, złączenie itd.), który stanowi fundament działania baz relacyjnych i optymalizacji zapytań SQL."
  },
  {
    "id": 96,
    "question": "Które z poniższych cech posiadają widoki (view)?",
    "options": [
      {
        "text": "mogą realizować politykę ograniczania dostępu do danych",
        "inline_explanation": "(Np. udostępniając tylko wybrane kolumny)",
        "correct": true
      },
      {
        "text": "ułatwiają konstrukcję zapytań SQL do bazy danych",
        "inline_explanation": "(Ukrywają skomplikowane złączenia)",
        "correct": true
      },
      {
        "text": "zabezpieczają dane przed ich utratą w trakcie realizacji złożonych transakcji",
        "inline_explanation": "(Nie, to rola logów i backupów)",
        "correct": false
      },
      {
        "text": "powodują problemy z konstrukcją zapytań SQL do bazy danych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "dostarczają prostego mechanizmu uaktualniania danych",
        "inline_explanation": "(Widoki często są tylko do odczytu, zwłaszcza te ze złączeniami)",
        "correct": false
      }
    ],
    "explanation": "Widok to 'wirtualna tabela' będąca zapisanym zapytaniem SQL. Pozwala uprościć dostęp do danych (użytkownik widzi prostą tabelę zamiast 5 złączeń) oraz zwiększyć bezpieczeństwo (ukrywając wrażliwe kolumny)."
  },
  {
    "id": 97,
    "question": "Z jakim problemem trzeba się uporać przy odwzorowaniu w schemacie relacyjnej bazy danych relacji typu n:m (wiele do wiele)?",
    "options": [
      {
        "text": "zdefiniować podwójne indeksowanie plików odpowiadających każdej z tabel",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "trzeba zaprojektować dodatkową tabelę",
        "inline_explanation": "(Tzw. tabela łącznikowa / asocjacyjna)",
        "correct": true
      },
      {
        "text": "dobrać odpowiedni klucz obcy w drugiej z tabel",
        "inline_explanation": "(To zadziała tylko dla relacji 1:n)",
        "correct": false
      },
      {
        "text": "trzeba użyć dodatkowo widoku (view)",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Relacyjne bazy danych nie obsługują bezpośrednio relacji wiele-do-wielu. Aby ją zrealizować, tworzy się trzecią tabelę (łącznikową), która zawiera klucze obce do obu łączonych tabel, rozbijając relację n:m na dwie relacje 1:n."
  },
  {
    "id": 98,
    "question": "Które z poniższych stwierdzeń są prawdziwe, jeśli dotyczą systemów baz danych realizowanych w architekturze klient-serwer?",
    "options": [
      {
        "text": "mocno obciążają sieć w stosunku do systemów scentralizowanych",
        "inline_explanation": "(Obciążenie jest zoptymalizowane, przesyłane są tylko wyniki zapytań)",
        "correct": false
      },
      {
        "text": "pozwalają klientom pracować w różnych systemach operacyjnych",
        "inline_explanation": "(Komunikacja odbywa się przez standardowy protokół sieciowy)",
        "correct": true
      },
      {
        "text": "uniezależniają sposób realizacji aplikacji od serwera",
        "inline_explanation": "(Logika prezentacji jest po stronie klienta, dane po stronie serwera)",
        "correct": true
      },
      {
        "text": "wymagają co najmniej dwóch komputerów",
        "inline_explanation": "(Klient i serwer mogą działać na jednej maszynie)",
        "correct": false
      }
    ],
    "explanation": "Architektura klient-serwer rozdziela warstwę danych (DBMS na serwerze) od warstwy prezentacji/aplikacji (klient). Pozwala to na elastyczność (różne OS u klientów) i skalowalność."
  },
  {
    "id": 99,
    "question": "Systemy OLTP (Online Transaction Processing) i OLAP (Online Analytical Processing) różnią się przede wszystkim:",
    "options": [
      {
        "text": "czasem reakcji na zapytanie",
        "inline_explanation": "(OLTP: milisekundy vs OLAP: sekundy/minuty)",
        "correct": true
      },
      {
        "text": "stopniem szczegółowości przechowywanych danych",
        "inline_explanation": "(OLTP: szczegółowe vs OLAP: zagregowane)",
        "correct": true
      },
      {
        "text": "zakresem realizowanych funkcji użytkowych",
        "inline_explanation": "(Bieżąca obsługa vs analityka/planowanie)",
        "correct": true
      },
      {
        "text": "językiem zapytań",
        "inline_explanation": "(Oba zazwyczaj używają SQL)",
        "correct": false
      }
    ],
    "explanation": "OLTP służy do bieżącej obsługi operacji biznesowych (szybkie, proste transakcje). OLAP służy do analizy, raportowania i wspomagania decyzji (złożone zapytania na dużej ilości danych historycznych)."
  },
  {
    "id": 100,
    "question": "Rolą hurtowni danych jest:",
    "options": [
      {
        "text": "przygotowanie danych do szybkiej analizy",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "kontrola poprawności danych realizowana podczas wykonywania transakcji",
        "inline_explanation": "(To rola systemów transakcyjnych OLTP)",
        "correct": false
      },
      {
        "text": "minimalizacja plików fizycznych przez ujednolicenie sposobu przechowywania danych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "przechowywanie danych w sposób scentralizowany",
        "inline_explanation": "(Integracja danych z wielu źródeł)",
        "correct": true
      },
      {
        "text": "wydajne odpowiadanie na zapytania o charakterze analitycznym",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Hurtownia danych (Data Warehouse) to centralne repozytorium zintegrowanych danych z różnych źródeł. Jest zoptymalizowana pod kątem wydajnego odczytu i analizy (OLAP), a nie pod kątem szybkiego zapisu transakcji."
  },
  {
    "id": 101,
    "question": "Modele danych w postaci gwiazdy i płatka śniegu:",
    "options": [
      {
        "text": "ich implementacja przyspiesza analizę danych",
        "inline_explanation": "(Są zoptymalizowane pod zapytania analityczne)",
        "correct": true
      },
      {
        "text": "pozwalają oddać sens złożonej struktury danych",
        "inline_explanation": "(Szczególnie model płatka śniegu, który normalizuje wymiary)",
        "correct": true
      },
      {
        "text": "zapewniają brak redundancji danych",
        "inline_explanation": "(Model gwiazdy jest celowo zdenormalizowany i zawiera redundancję)",
        "correct": false
      },
      {
        "text": "służą głównie do obsługi bieżących transakcji sprzedażowych",
        "inline_explanation": "(Nie, służą do analizy w hurtowniach danych)",
        "correct": false
      }
    ],
    "explanation": "Są to schematy używane w hurtowniach danych. Schemat gwiazdy składa się z tabeli faktów i tabel wymiarów (prostszy, szybszy). Schemat płatka śniegu normalizuje tabele wymiarów (bardziej złożony, mniej redundancji)."
  },
  {
    "id": 102,
    "question": "System operacyjny jest:",
    "options": [
      {
        "text": "zbiorem składników sprzętowych (hardware routines)",
        "inline_explanation": "(To byłby sprzęt/firmware)",
        "correct": false
      },
      {
        "text": "zbiorem driverów obsługujących urządzenia wejścia-wyjścia",
        "inline_explanation": "(To tylko część systemu)",
        "correct": false
      },
      {
        "text": "zbiorem składników programowych (software routines)",
        "inline_explanation": "(Zarządza zasobami i dostarcza interfejs)",
        "correct": true
      },
      {
        "text": "fizycznym elementem płyty głównej",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "System operacyjny to oprogramowanie (software), które pełni rolę zarządcy zasobów (procesor, pamięć, urządzenia I/O) oraz dostarcza maszynę wirtualną/rozszerzoną, ukrywając złożoność sprzętu przed użytkownikiem."
  },
  {
    "id": 103,
    "question": "Proces transferowania danych, które mają być docelowo wyprowadzone na urządzenie peryferyjne, do przestrzeni pamięci pomocniczej i transferowanie ich na to urządzenie w dogodniejszym czasie nosi nazwę:",
    "options": [
      {
        "text": "spooling",
        "inline_explanation": "(Simultaneous Peripheral Operations On-Line)",
        "correct": true
      },
      {
        "text": "virtualization",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "caching",
        "inline_explanation": "(Caching przechowuje dane często używane, spooling to buforowanie zadań)",
        "correct": false
      },
      {
        "text": "throttling",
        "inline_explanation": "(Dławienie wydajności)",
        "correct": false
      }
    ],
    "explanation": "Spooling (np. przy drukowaniu) polega na zrzuceniu danych do bufora na dysku, dzięki czemu procesor nie musi czekać na wolne urządzenie peryferyjne i może zająć się innym zadaniem."
  },
  {
    "id": 104,
    "question": "Centralny Procesor, po otrzymaniu informacji o przerwaniu z urządzenia wejścia/wyjścia:",
    "options": [
      {
        "text": "zatrzymuje się na określony okres czasu",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "przekazuje sterowanie do systemu obsługi przerwań po zakończeniu wykonywania bieżącej instrukcji",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "natychmiast przerywa wykonywanie bieżącej instrukcji w połowie jej cyklu",
        "inline_explanation": "(Musi dokończyć instrukcję, by zachować spójność stanu)",
        "correct": false
      },
      {
        "text": "ignoruje przerwanie, jeśli pochodzi z urządzenia zewnętrznego",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Obsługa przerwania (Interrupt Service Routine) następuje po zakończeniu cyklu bieżącej instrukcji. Procesor zapisuje stan, odczytuje wektor przerwań i skacze do odpowiedniej procedury obsługi."
  },
  {
    "id": 105,
    "question": "Buforowanie plików realizowane jest w celu:",
    "options": [
      {
        "text": "zwiększenia wydajności dostępu do pamięci pomocniczej",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "wspomagania obsługi przerwań",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "zwiększenia wydajności procesora",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "wyrównania różnic prędkości przesyłania danych między różnymi urządzeniami",
        "inline_explanation": "(Np. między szybkim RAM a wolnym dyskiem)",
        "correct": true
      }
    ],
    "explanation": "Buforowanie pozwala gromadzić dane w szybkiej pamięci, aby niwelować różnice prędkości między nadawcą a odbiorcą (np. CPU a dyskiem), co pozwala na płynniejszą pracę systemu."
  },
  {
    "id": 106,
    "question": "Zaznacz prawdziwe stwierdzenia na temat stronicowania:",
    "options": [
      {
        "text": "stronicowanie rozwiązuje problem zewnętrznej fragmentacji pamięci",
        "inline_explanation": "(Przydzielamy dowolne wolne ramki, nie muszą być ciągłe)",
        "correct": true
      },
      {
        "text": "tablica stron jest stosowana do translacji adresu logicznego na adres fizyczny",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "podczas stronicowania przyjmuje się, że pamięć fizyczna jest podzielona na strony, a pamięć logiczna na ramki",
        "inline_explanation": "(Odwrotnie: fizyczna na ramki, logiczna na strony)",
        "correct": false
      },
      {
        "text": "stronicowanie rozwiązuje problem wewnętrznej fragmentacji pamięci",
        "inline_explanation": "(Wprowadza ją - ostatnia strona rzadko jest pełna)",
        "correct": false
      },
      {
        "text": "podczas stronicowania przyjmuje się, że pamięć fizyczna jest podzielona na ramki, a pamięć logiczna na strony, i że rozmiary stron i ramek są jednakowe",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Stronicowanie dzieli pamięć na stałe bloki. Pamięć fizyczna to ramki (frames), logiczna to strony (pages). Dzięki temu proces nie musi zajmować ciągłego obszaru pamięci fizycznej (brak fragmentacji zewnętrznej), ale pojawia się fragmentacja wewnętrzna (nepełna ostatnia strona)."
  },
  {
    "id": 107,
    "question": "Zaznacz prawdziwe stwierdzenia na temat segmentacji:",
    "options": [
      {
        "text": "segmentacja ułatwia nadanie częściom procesu odpowiednich atrybutów ochrony (odczyt, zapis, wykonanie)",
        "inline_explanation": "(Segmenty odpowiadają logicznym częściom programu, np. kod jest read-only)",
        "correct": true
      },
      {
        "text": "zastosowanie segmentacji wyklucza użycie stronicowania",
        "inline_explanation": "(Można stosować segmentację ze stronicowaniem)",
        "correct": false
      },
      {
        "text": "mogą istnieć następujące przykładowe rodzaje segmentów: kodu, danych, stosu",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "elementy tablicy segmentów zawierają adresy/numery ramek oraz rozmiary poszczególnych segmentów",
        "inline_explanation": "(Tablica segmentów zawiera adres bazowy i limit/rozmiar, a nie numery ramek)",
        "correct": false
      }
    ],
    "explanation": "Segmentacja dzieli pamięć na logiczne jednostki (segmenty) o różnej wielkości, co odpowiada widokowi programu przez programistę (funkcje, stos, zmienne). Ułatwia to ochronę pamięci (np. segment kodu tylko do odczytu)."
  },
  {
    "id": 108,
    "question": "Zaznacz prawdziwe stwierdzenia na temat algorytmów wywłaszczania stron:",
    "options": [
      {
        "text": "zaletą algorytmu FIFO jest to, że nie zachodzi w nim efekt zwany anomalią Belady'ego",
        "inline_explanation": "(Fałsz: anomalia Belady'ego dotyczy właśnie FIFO)",
        "correct": false
      },
      {
        "text": "w algorytmie LRU zastępowana jest strona, która najdłużej nie była używana",
        "inline_explanation": "(Least Recently Used)",
        "correct": true
      },
      {
        "text": "w algorytmie drugiej szansy wykorzystuje się bit odniesienia, który określa, czy w pewnym przedziale czasu nastąpiło odwołanie do strony",
        "inline_explanation": "(Przybliżenie LRU)",
        "correct": true
      },
      {
        "text": "zasadą działania algorytmu optymalnego jest to, że zastąpiona zostaje strona, która najdłużej nie będzie używana",
        "inline_explanation": "(Wymaga znajomości przyszłości)",
        "correct": true
      },
      {
        "text": "w algorytmie LRU zachodzi efekt zwany anomalią Belady'ego",
        "inline_explanation": "(LRU jest algorytmem stosowym, więc jest wolne od tej anomalii)",
        "correct": false
      },
      {
        "text": "optymalny algorytm wywłaszczania stron zapewnia minimalną ilość wywłaszczeń stron przy ustalonej liczbie ramek",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Anomalia Belady'ego to zjawisko, w którym zwiększenie liczby ramek pamięci powoduje zwiększenie liczby błędów strony. Występuje w FIFO, ale nie w LRU czy algorytmie optymalnym."
  },
  {
    "id": 109,
    "question": "Zaznacz prawdziwe stwierdzenia dotyczące pamięci wirtualnej:",
    "options": [
      {
        "text": "stronicowanie na żądanie jest jednym ze sposobów realizacji pamięci wirtualnej",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "procedura leniwej wymiany (lazy swapper) polega na tym, że nie wykonuje się wymiany stron w pamięci, jeśli nie zachodzi taka potrzeba",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "pamięć wirtualna umożliwia wykonywanie procesów, które nie są w całości przechowywane w pamięci operacyjnej",
        "inline_explanation": "(Wykorzystuje dysk/swap)",
        "correct": true
      },
      {
        "text": "przydział ramek oparty na globalnym algorytmie zastępowania może ograniczyć szamotanie (thrashing)",
        "inline_explanation": "(Odwrotnie: lokalny algorytm izoluje procesy i ogranicza wpływ szamotania jednego na inne)",
        "correct": false
      }
    ],
    "explanation": "Pamięć wirtualna tworzy abstrakcję dużej, ciągłej pamięci dla procesów, fizycznie mapując ją na mniejszą pamięć RAM i pamięć masową (dysk). Strony są ładowane do RAM tylko wtedy, gdy są potrzebne (on-demand)."
  },
  {
    "id": 110,
    "question": "Który z problemów rozwiązuje zaproponowany przez Dijkstrę algorytm bankiera?",
    "options": [
      {
        "text": "wzajemnego wykluczania (mutual exclusion)",
        "inline_explanation": "(To rozwiązują np. semafory/mutexy)",
        "correct": false
      },
      {
        "text": "wykluczania zakleszczenia (deadlock exclusion)",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "unikania zakleszczenia (deadlock avoidance)",
        "inline_explanation": "(Decyduje, czy przyznanie zasobu jest bezpieczne)",
        "correct": true
      },
      {
        "text": "unikania wykluczania (exclusion avoidance)",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Algorytm bankiera symuluje alokację zasobów. Przed przyznaniem zasobu sprawdza, czy system pozostanie w stanie bezpiecznym (tzn. czy istnieje sekwencja wykonania procesów, która pozwoli wszystkim się zakończyć). Jeśli nie, wstrzymuje żądanie, unikając zakleszczenia."
  },
  {
    "id": 111,
    "question": "Dla uniknięcia błędów uwarunkowanych czasowo (race conditions), maksymalna liczba procesów, które mogą znajdować się wewnątrz sekcji krytycznej, wynosi:",
    "options": [
      {
        "text": "8",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "1",
        "inline_explanation": "(Wzajemne wykluczanie - Mutual Exclusion)",
        "correct": true
      },
      {
        "text": "0",
        "inline_explanation": "(Wtedy żaden proces nie wykonuje pracy)",
        "correct": false
      },
      {
        "text": "16",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Sekcja krytyczna to fragment kodu, w którym procesor korzysta z zasobu współdzielonego. Aby uniknąć niespójności danych, w sekcji krytycznej w danej chwili może przebywać wyłącznie jeden proces."
  },
  {
    "id": 112,
    "question": "Inicjalna wartość semafora uogólnionego implementującego sekcję krytyczną (działającego jak mutex) wynosi:",
    "options": [
      {
        "text": "0",
        "inline_explanation": "(Zablokowałoby to pierwszy proces)",
        "correct": false
      },
      {
        "text": "1",
        "inline_explanation": "(Jeden 'żeton' wstępu)",
        "correct": true
      },
      {
        "text": "-1",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "dowolna liczba dodatnia",
        "inline_explanation": "(To pozwoliłoby wejść wielu procesom naraz)",
        "correct": false
      }
    ],
    "explanation": "Aby semafor działał jako mechanizm wzajemnego wykluczania, musi on pozwalać na jednokrotne wykonanie operacji opuszczenia (P) przed zablokowaniem. Dlatego inicjuje się go wartością 1."
  },
  {
    "id": 113,
    "question": "Zaznacz prawdziwe zdania na temat semaforów:",
    "options": [
      {
        "text": "zaletą aktywnego czekania w trybie użytkownika jest brak konieczności kosztownego przejścia do trybu uprzywilejowanego (systemowego)",
        "inline_explanation": "(Wirujące semafory nie usypiają procesu, więc nie wymagają przełączania kontekstu)",
        "correct": false
      },
      {
        "text": "semafor może być użyty do synchronizacji dostępu do sekcji krytycznej",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "aktywne czekanie oznacza ciągłe testowanie wartości wyrażenia do momentu, gdy przyjmie ono wartość, dla której czekanie może być zakończone",
        "inline_explanation": "(Zużywa cykle procesora)",
        "correct": true
      },
      {
        "text": "semafor nie nadaje się do zdeterminowania kolejności wykonywanych operacji w grupie współbieżnych procesów",
        "inline_explanation": "(Nadaje się, np. przez inicjalizację na 0)",
        "correct": false
      },
      {
        "text": "semafor może być użyty do synchronizacji dostępu do sekcji krytycznej, poprzez sygnalizowanie (V) przed wejściem i czekanie (P) po zakończeniu",
        "inline_explanation": "(Odwrotnie: P przed wejściem, V po wyjściu)",
        "correct": false
      }
    ],
    "explanation": "Semafory to klasyczny mechanizm synchronizacji. Aktywne czekanie (spinlock) polega na pętli sprawdzającej warunek ('czy już wolne?'), co nie usypia wątku, ale zużywa procesor. Zwykłe semafory usypiają czekający proces."
  },
  {
    "id": 114,
    "question": "Semafory:",
    "options": [
      {
        "text": "posiadają operacje czekaj (P) i sygnalizuj (V)",
        "inline_explanation": "(Od holenderskich słów Proberen i Verhogen)",
        "correct": true
      },
      {
        "text": "przed wejściem do sekcji krytycznej wykonywana jest operacja sygnalizuj (V)",
        "inline_explanation": "(Przed wejściem wykonuje się P - opuszczenie)",
        "correct": false
      },
      {
        "text": "aktywne czekanie polega na uśpieniu procesu i aktywnym oczekiwaniu na sygnał wybudzający",
        "inline_explanation": "(To definicja blokowania/uśpienia, a nie aktywnego czekania)",
        "correct": false
      },
      {
        "text": "można stworzyć semafor zliczający z 2 semaforów binarnych i zmiennej zliczającej wykorzystującej te semafory",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Operacja P (Wait/Down) zmniejsza wartość semafora i blokuje proces, jeśli wartość spadnie poniżej zera. Operacja V (Signal/Up) zwiększa wartość i ewentualnie odblokowuje czekający proces."
  },
  {
    "id": 115,
    "question": "Rola metod komputerowych w trójkącie 'teoria - eksperyment - symulacja' to:",
    "options": [
      {
        "text": "opracowywanie nowych praw o charakterze podstawowym dla danej dziedziny",
        "inline_explanation": "(To rola teorii)",
        "correct": false
      },
      {
        "text": "realizacja symulacji w oparciu o prawa podstawowe, sugerowanie nowych eksperymentów, sugerowanie teorii",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "zastępowanie kosztownych eksperymentów i weryfikowanie teorii",
        "inline_explanation": "(Symulacja nie zastępuje w pełni eksperymentu, a jedynie go uzupełnia)",
        "correct": false
      },
      {
        "text": "realizacja symulacji w oparciu o prawa podstawowe, sterowanie eksperymentami",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Symulacje komputerowe stanowią trzeci filar nauki. Pozwalają badać modele wynikające z praw podstawowych, co pomaga w planowaniu eksperymentów i rozwoju teorii, ale nie tworzą same z siebie nowych praw podstawowych."
  },
  {
    "id": 116,
    "question": "Dokładność reprezentacji zmiennoprzecinkowej jest określona przez:",
    "options": [
      {
        "text": "liczbę bitów mantysy",
        "inline_explanation": "(Im więcej bitów mantysy, tym większa precyzja)",
        "correct": true
      },
      {
        "text": "liczbę bitów mantysy i wykładnika",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "zakres wykładnika",
        "inline_explanation": "(Wykładnik decyduje o zakresie liczb, a nie dokładności)",
        "correct": false
      },
      {
        "text": "liczbę bitów mantysy i zakres wykładnika",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "W standardzie IEEE 754 mantysa przechowuje cyfry znaczące liczby. Wykładnik (cecha) określa rząd wielkości (przesunięcie przecinka). Zatem za precyzję odpowiada wyłącznie długość mantysy."
  },
  {
    "id": 117,
    "question": "Jeśli niewielkie względne zaburzenia danych wejściowych powodują niewielkie względne zmiany wyników, to wówczas:",
    "options": [
      {
        "text": "współczynnik uwarunkowania osiąga wysoką wartość",
        "inline_explanation": "(Wysoka wartość oznacza złe uwarunkowanie)",
        "correct": false
      },
      {
        "text": "współczynnik uwarunkowania osiąga niską wartość",
        "inline_explanation": "(Zadanie dobrze uwarunkowane)",
        "correct": true
      },
      {
        "text": "zadanie jest numerycznie niestabilne",
        "inline_explanation": "(Stabilność dotyczy algorytmu, uwarunkowanie dotyczy zadania)",
        "correct": false
      },
      {
        "text": "nie można stwierdzić nic o uwarunkowaniu",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Współczynnik uwarunkowania (condition number) miary wrażliwość wyniku na błędy w danych wejściowych. Wartość bliska 1 oznacza dobre uwarunkowanie (małe błędy wejścia -> małe błędy wyjścia)."
  },
  {
    "id": 118,
    "question": "Wybierz poprawną odpowiedź dotyczącą numeryki:",
    "options": [
      {
        "text": "uwarunkowanie to cecha wynikająca tylko z dokładności operacji zmiennoprzecinkowych",
        "inline_explanation": "(Uwarunkowanie to cecha zadania matematycznego, niezależna od komputera)",
        "correct": false
      },
      {
        "text": "wskaźniki uwarunkowania określają poprawność numeryczną",
        "inline_explanation": "(Poprawność numeryczna to cecha algorytmu)",
        "correct": false
      },
      {
        "text": "uwarunkowanie i stabilność numeryczna są cechami zadania",
        "inline_explanation": "(Stabilność jest cechą algorytmu)",
        "correct": false
      },
      {
        "text": "algorytmy numerycznie poprawne dają rozwiązanie będące nieco zaburzonym dokładnym rozwiązaniem zadania o nieco zaburzonych danych",
        "inline_explanation": "(Definicja numerycznej poprawności)",
        "correct": true
      }
    ],
    "explanation": "Należy odróżnić uwarunkowanie zadania (czy sam problem jest wrażliwy na błędy) od stabilności/poprawności algorytmu (czy metoda obliczeń nie wprowadza nadmiernych błędów)."
  },
  {
    "id": 119,
    "question": "Błędy związane z ograniczeniem nieskończonego ciągu wymaganych obliczeń do skończonej liczby działań nazywamy:",
    "options": [
      {
        "text": "błędami zaokrągleń (ang. rounding errors)",
        "inline_explanation": "(Te wynikają ze skończonej precyzji arytmetyki)",
        "correct": false
      },
      {
        "text": "błędami obcięcia (ang. truncation errors)",
        "inline_explanation": "(Te wynikają z metody, np. ucięcie szeregu Taylora)",
        "correct": true
      },
      {
        "text": "błędami grubymi",
        "inline_explanation": "(Pomyłki ludzkie)",
        "correct": false
      },
      {
        "text": "błędami danych wejściowych",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Błąd obcięcia powstaje, gdy matematycznie dokładny wzór (np. granica, całka, szereg nieskończony) zastępujemy przybliżonym wzorem obliczalnym w skończonej liczbie kroków (np. suma częściowa szeregu)."
  },
  {
    "id": 120,
    "question": "Macierz Hilberta osiąga wysokie wartości współczynnika uwarunkowania (ang. condition number). Na tej podstawie możemy stwierdzić, że:",
    "options": [
      {
        "text": "macierz Hilberta jest dobrze uwarunkowana",
        "inline_explanation": "(Niski współczynnik = dobre uwarunkowanie)",
        "correct": false
      },
      {
        "text": "macierz Hilberta jest źle uwarunkowana",
        "inline_explanation": "(Wysoki współczynnik = złe uwarunkowanie)",
        "correct": true
      },
      {
        "text": "macierz Hilberta jest zawsze diagonalnie dominująca",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "macierz Hilberta jest macierzą jednostkową",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Wskaźnik uwarunkowania mówi nam, jak bardzo błąd danych wejściowych może zostać powiększony w wyniku. Wysoka wartość tego wskaźnika (jak w przypadku macierzy Hilberta) oznacza, że zadanie jest źle uwarunkowane (bardzo wrażliwe na błędy)."
  },
  {
    "id": 121,
    "question": "Efekt Rungego w interpolacji wielomianowej to:",
    "options": [
      {
        "text": "wynik wyboru złej funkcji interpolującej",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "wynik braku jednoznaczności rozwiązania zadania interpolacji",
        "inline_explanation": "(Rozwiązanie jest jednoznaczne)",
        "correct": false
      },
      {
        "text": "konsekwencja arytmetyki zmiennoprzecinkowej",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "wynik błędu metody",
        "inline_explanation": "(Metody doboru węzłów równoodległych)",
        "correct": true
      }
    ],
    "explanation": "Efekt Rungego to pogorszenie jakości interpolacji wielomianowej (pojawienie się silnych oscylacji na krańcach przedziału) mimo zwiększania stopnia wielomianu. Wynika on z natury wielomianów wysokiego stopnia przy zastosowaniu węzłów równoodległych."
  },
  {
    "id": 122,
    "question": "Aby wyeliminować lub znacząco ograniczyć efekt Rungego przy zadaniu interpolacji można:",
    "options": [
      {
        "text": "zastosować interpolację funkcjami sklejanymi zamiast metody Lagrange'a",
        "inline_explanation": "(Splajny unikają wysokich stopni wielomianów na całym przedziale)",
        "correct": true
      },
      {
        "text": "zastosować interpolację z węzłami gęściej upakowanymi na końcach przedziału",
        "inline_explanation": "(Np. węzły Czebyszewa)",
        "correct": true
      },
      {
        "text": "zwiększyć stopień wielomianu interpolacyjnego przy węzłach równoodległych",
        "inline_explanation": "(To właśnie pogarsza efekt Rungego)",
        "correct": false
      },
      {
        "text": "zastosować ekstrapolację zamiast interpolacji",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Efekt Rungego można zniwelować na dwa sposoby: zmieniając rozmieszczenie węzłów (zagęszczenie na krańcach, np. węzły Czebyszewa) lub zmieniając metodę interpolacji na taką, która nie używa jednego wielomianu wysokiego stopnia dla całego zbioru (funkcje sklejane)."
  },
  {
    "id": 123,
    "question": "Efekt Rungego jest charakterystyczny dla następujących metod interpolacji:",
    "options": [
      {
        "text": "interpolacji funkcjami sklejanymi 1 stopnia dla węzłów równoodległych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "interpolacji funkcjami sklejanymi 3 stopnia dla węzłów równoodległych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "interpolacji metodą Lagrange'a (wielomianowej) dla węzłów równoodległych",
        "inline_explanation": "(Szczególnie dla wysokich stopni wielomianu)",
        "correct": true
      },
      {
        "text": "interpolacji metodą Lagrange'a dla węzłów będących zerami wielomianów Czebyszewa",
        "inline_explanation": "(Tu efekt jest zminimalizowany)",
        "correct": false
      }
    ],
    "explanation": "Efekt ten występuje przy interpolacji wielomianowej (gdzie jeden wielomian opisuje cały zbiór punktów), gdy stopień wielomianu jest wysoki, a węzły są rozmieszczone równomiernie."
  },
  {
    "id": 124,
    "question": "Wskaż zdania prawdziwe dotyczące zagadnienia interpolacji wielomianowej z wykorzystaniem jednomianów (tzw. bazy naturalnej):",
    "options": [
      {
        "text": "jest to zadanie dobrze uwarunkowane",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "ma zdecydowanie lepsze właściwości obliczeniowe niż metoda Lagrange'a",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "jest to zadanie źle uwarunkowane",
        "inline_explanation": "(Macierz Vandermonde'a ma wysoki wskaźnik uwarunkowania)",
        "correct": true
      },
      {
        "text": "nie wymaga rozwiązywania układu równań",
        "inline_explanation": "(Wymaga rozwiązania układu z macierzą Vandermonde'a)",
        "correct": false
      }
    ],
    "explanation": "Interpolacja w bazie naturalnej ($1, x, x^2, ...$) prowadzi do konieczności rozwiązania układu równań z macierzą Vandermonde'a. Macierz ta dla większych stopni jest bardzo źle uwarunkowana, co prowadzi do dużych błędów numerycznych."
  },



  {
    "id": 140,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 141,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 142,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 143,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 144,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 145,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 146,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 147,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 148,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 149,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 150,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 151,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 152,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 153,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 154,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 155,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 156,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 157,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 158,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 159,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 160,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 161,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 162,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 163,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 164,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 165,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 166,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 167,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 168,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 169,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 170,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 171,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 172,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 173,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 174,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 175,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 176,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 177,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 178,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 179,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 180,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 181,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 182,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 183,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 184,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 185,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 186,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 187,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 188,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 189,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 190,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 191,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 192,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 193,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 194,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 195,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 196,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 197,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 198,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 199,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 200,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 201,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 202,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 203,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 204,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 205,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 206,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 207,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 208,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 209,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 210,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 211,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 212,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 213,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 214,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 215,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 216,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 217,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 218,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 219,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 220,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 221,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 222,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 223,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 224,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 225,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 226,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 227,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 228,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 229,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 230,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 231,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 232,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 233,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 234,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 235,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 236,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 237,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 238,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 239,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 240,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 241,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 242,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 243,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 244,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 245,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 246,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 247,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 248,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 249,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 250,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 251,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 252,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 253,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 254,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 255,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 256,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 257,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 258,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 259,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 260,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 261,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 262,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 263,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 264,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 265,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 266,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 267,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 268,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 269,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 270,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 271,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 272,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 273,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 274,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 275,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 276,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 277,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 278,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 279,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 280,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 281,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 282,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 283,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 284,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 285,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 286,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 287,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 288,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 289,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 290,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 291,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 292,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 293,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 294,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 295,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 296,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 297,
    "question": "",
    "options": [
      {
        "text": "",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  }
]