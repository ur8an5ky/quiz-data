[
  {
    "id": 1,
    "question": "Najbardziej prymitywnym systemem liczbowym jest:",
    "options": [
      {
        "text": "jedynkowy system liczbowy",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "dwójkowy system liczbowy",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "ósemkowy system liczbowy",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "dziesiętny system liczbowy",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "szesnastkowy system liczbowy",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "W systemie jedynkowym piszemy po prostu tyle jedynek, jak duża jest liczba, np. 3 w systemie dziesiętnym to 111 w jedynkowym."
  },
  {
    "id": 2,
    "question": "Wartość 5/16 ma postać w systemie binarnym:",
    "options": [
      {
        "text": "0.0101",
        "inline_explanation": "= 5/16",
        "correct": true
      },
      {
        "text": "0.1011",
        "inline_explanation": "= 11/16",
        "correct": false
      },
      {
        "text": "0.1010",
        "inline_explanation": "= 5/8",
        "correct": false
      }
    ],
    "explanation": "Liczymy osobno część całkowitą i ułamkową (po przecinku).\n\nDla części całkowitej: dzielimy przez 2, dopisujemy resztę z dzielenia (0 lub 1) z lewej strony budowanej liczby, powtarzamy aż dojdziemy do 0.\n\nDla części ułamkowej: mnożymy przez 2, dopisujemy część całkowitą (0 lub 1) z prawej strony budowanej liczby, jako kolejną liczbę bierzemy ułamek z uzyskanej liczby (w razie czego trzeba będzie odciąć 1), powtarzamy aż dojdziemy do 0.\nJeżeli w ułamku zauważymy, że coś zaczyna się powtarzać (wpadamy w pętlę z wartościami), to mamy ułamek okresowy."
  },
  {
    "id": 3,
    "question": "Wartość 1/10 ma postać w systemie binarnym:",
    "options": [
      {
        "text": "0.1010",
        "inline_explanation": "= 5/8",
        "correct": false
      },
      {
        "text": "0.0(0011)",
        "inline_explanation": "= 1/10",
        "correct": true
      },
      {
        "text": "0.(1010)",
        "inline_explanation": "= 2/3",
        "correct": false
      },
      {
        "text": "0.0(1010)",
        "inline_explanation": "= 1/3",
        "correct": false
      }
    ],
    "explanation": "Liczymy osobno część całkowitą i ułamkową (po przecinku).\n\nDla części całkowitej: dzielimy przez 2, dopisujemy resztę z dzielenia (0 lub 1) z lewej strony budowanej liczby, powtarzamy aż dojdziemy do 0.\n\nDla części ułamkowej: mnożymy przez 2, dopisujemy część całkowitą (0 lub 1) z prawej strony budowanej liczby, jako kolejną liczbę bierzemy ułamek z uzyskanej liczby (w razie czego trzeba będzie odciąć 1), powtarzamy aż dojdziemy do 0.\nJeżeli w ułamku zauważymy, że coś zaczyna się powtarzać (wpadamy w pętlę z wartościami), to mamy ułamek okresowy.\n\n0.1 * 2 = 0.2 liczba: 0.0\n0.2 * 2 = 0.4 liczba: 0.00\n0.4 * 2 = 0.8 liczba: 0.000\n0.8 * 2 = 1.6 -> 0.6 liczba: 0.0001\n0.6 * 2 = 1.2 -> 0.2 liczba: 0.00011\nZauważamy, że wróciliśmy do początku 2 linijki, czyli od wtedy jest okres:\n0.0010... = 0.0(0011)"
  },
  {
    "id": 4,
    "question": "Ile informacji zawiera 8-znakowe słowo, którego każdy znak jest jedną z liter a,b? Prawdopodobieństwo pojawienia się (na każdej pozycji) samogłoski jest dwukrotnie większe od prawdopodobieństwa pojawienia się spółgłoski.",
    "options": [
      {
        "text": "więcej niż 8 bitów",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "mniej niż 8 bitów",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "dokładnie 8 bitów",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Wykorzystuje się tutaj wzór na entropię informacji Shannona:\n$H(X) = -\\sum_{i=1}^{n} p_i \\log_2 (p_i)$,\ngdzie $(p_i)$ jest prawdopodobieństwem wystąpienia elementu $x_i$.\n\nŻeby obliczyć na X-znakowego słowa: dla każdego znaku (np. 0/1, a/b/c…) liczymy powyższy wzór, mnożymy przez liczbę miejsc X (zakładając, że dla każdego miejsca jest takie samo prawdopodobieństwo) i potem sumujemy dla poszczególnych znaków. Ważne jest dla nas tylko przyrównanie tego do 8 (jednostką jest bit).\n\n$H(X) = -8 * [2/3 * log_2(2/3) + 1/3 * log_2(1/3)] =...=-8 * [2/3 - log_2(3)]"
  },
  {
    "id": 5,
    "question": "Algorytm to:",
    "options": [
      {
        "text": "uporządkowany zbiór operacji",
        "inline_explanation": "(Definicja ogólna)",
        "correct": true
      },
      {
        "text": "specyfikacja ciągu elementarnych operacji, które przekształcają dane wejściowe na wynik",
        "inline_explanation": "(Definicja ścisła)",
        "correct": true
      },
      {
        "text": "zbiór losowych instrukcji bez określonego celu",
        "inline_explanation": "(Algorytm musi być celowy i uporządkowany)",
        "correct": false
      },
      {
        "text": "fizyczna część komputera wykonująca obliczenia",
        "inline_explanation": "(To procesor, a nie algorytm)",
        "correct": false
      }
    ],
    "explanation": "Algorytm to skończony ciąg jasno zdefiniowanych czynności koniecznych do wykonania pewnego rodzaju zadań. Cechuje go: skończoność, określoność (jednoznaczność), posiadanie danych wejściowych i wyjściowych oraz efektywność."
  },
  {
    "id": 6,
    "question": "Język formalny w informatyce jest:",
    "options": [
      {
        "text": "zbiorem słów nad danym alfabetem, określonym przez ścisłe reguły (gramatykę)",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "sposobem zapisu algorytmów opartym na blokach operacyjnych",
        "inline_explanation": "(To schemat blokowy)",
        "correct": false
      },
      {
        "text": "językiem naturalnym (np. polskim) służącym do luźnej komunikacji",
        "inline_explanation": "(Języki naturalne są niejednoznaczne)",
        "correct": false
      },
      {
        "text": "graficzną reprezentacją struktury bazy danych",
        "inline_explanation": "(To diagram ERD)",
        "correct": false
      }
    ],
    "explanation": "Język formalny to pojęcie z teorii języków i automatów. Jest to zbiór ciągów symboli (słów) wygenerowanych przez ściśle określoną gramatykę. Języki programowania są podzbiorem języków formalnych, w przeciwieństwie do języków naturalnych, które dopuszczają wieloznaczność."
  },
  {
    "id": 7,
    "question": "Syntaktyka języka programowania opisuje:",
    "options": [
      {
        "text": "znaczenie instrukcji w języku",
        "inline_explanation": "(To semantyka)",
        "correct": false
      },
      {
        "text": "formalnie poprawne programy",
        "inline_explanation": "(Syntaktyka określa reguły, ale nie gwarantuje poprawności logicznej)",
        "correct": false
      },
      {
        "text": "budowę instrukcji w języku",
        "inline_explanation": "(Reguły pisowni, np. gdzie postawić średnik)",
        "correct": true
      },
      {
        "text": "działanie poprawnego programu",
        "inline_explanation": "(To semantyka)",
        "correct": false
      }
    ],
    "explanation": "Syntaktyka (Syntax) zajmuje się formą i strukturą zapisu. Odpowiada na pytanie 'jak to napisać, żeby kompilator zrozumiał?'. Określa np. użycie nawiasów, średników czy słów kluczowych. "
  },
  {
    "id": 8,
    "question": "Semantyka języka programowania opisuje:",
    "options": [
      {
        "text": "znaczenie instrukcji w języku",
        "inline_explanation": "(Co się stanie po uruchomieniu kodu)",
        "correct": true
      },
      {
        "text": "formalnie poprawne programy",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "budowę instrukcji w języku",
        "inline_explanation": "(To syntaktyka)",
        "correct": false
      },
      {
        "text": "działanie poprawnego programu",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Semantyka (Semantics) zajmuje się znaczeniem i działaniem kodu. Odpowiada na pytanie 'co ten kod robi?'. Kod może być poprawny syntaktycznie (bez błędów kompilacji), ale błędny semantycznie (robić coś innego niż zamierzono). "
  },
  {
    "id": 9,
    "question": "Nawiasy <> w notacji EBNF oznaczają:",
    "options": [
      {
        "text": "symbol nieterminalny",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "opcjonalne wystąpienie elementu",
        "inline_explanation": "[]",
        "correct": false
      },
      {
        "text": "symbol terminalny",
        "inline_explanation": "(litery, liczby, ciągi znaków)",
        "correct": false
      },
      {
        "text": "wielokrotne występowanie elementu",
        "inline_explanation": "{}",
        "correct": false
      }
    ],
    "explanation": "Sposób zapisu gramatyki bezkontekstowej. W szczególności jest używana do opisywania składni (syntaktyki) języków programowania. Ważne elementy notacji:\n● litery, liczby, ciągi znaków - symbole terminalne (końcowe)\n● <> - symbole nieterminalne (pomocnicze)\n● ::= - produkcja\n● | - alternatywa\n● [] - wystąpienie 0 lub 1 raz\n● {} - wystąpienie 0 lub więcej razy"
  },
  {
    "id": 10,
    "question": "Semantyka denotacyjna to:",
    "options": [
      {
        "text": "opis w postaci funkcji przekształcającej dane wejściowe w dane wyjściowe",
        "inline_explanation": "(Skupia się na efekcie działania programu, a nie na krokach)",
        "correct": true
      },
      {
        "text": "opis budowy poprawnych semantycznie programów",
        "inline_explanation": "(To zbyt ogólne określenie)",
        "correct": false
      },
      {
        "text": "stan maszyny przed i po wykonaniu instrukcji",
        "inline_explanation": "(To definicja semantyki operacyjnej)",
        "correct": false
      },
      {
        "text": "zbiór aksjomatów i reguł wnioskowania dla instrukcji",
        "inline_explanation": "(To definicja semantyki aksjomatycznej)",
        "correct": false
      }
    ],
    "explanation": "Semantyka denotacyjna przypisuje fragmentom programu obiekty matematyczne (denotacje), zazwyczaj funkcje. \n  \n Ignoruje ona to, 'jak' program liczy (kroki, rejestry procesora), a skupia się na tym 'co' liczy (matematyczny związek wejścia z wyjściem)."
  },
  {
    "id": 11,
    "question": "Kodem ASCII możemy zakodować:",
    "options": [
      {
        "text": "dowolny znak z zakresu 0-127",
        "inline_explanation": "(Standard ASCII jest 7-bitowy, co daje 128 znaków)",
        "correct": true
      },
      {
        "text": "dowolny znak z zakresu 0-128",
        "inline_explanation": "(Błąd logiczny: zakres 0-128 to 129 znaków)",
        "correct": false
      },
      {
        "text": "dowolny znak z zakresu 0-255",
        "inline_explanation": "(To zakres rozszerzonego ASCII / ISO-8859-1)",
        "correct": false
      },
      {
        "text": "dowolny znak z zakresu 32-255",
        "inline_explanation": "(Pomija znaki sterujące 0-31)",
        "correct": false
      }
    ],
    "explanation": "ASCII:\n● najstarszy format kodowania znaków\n● standardowo tylko znaki z języka angielskiego, zapisywane na 7 bitach\n● 1 znak ASCII zajmuje 1 bajt, czyli 8 bitów; ostatni bit zgodnie ze standardem nie jest używany (są różne rozszerzenia)\n● realnie są to liczby z zakresu 0-127, zapisywane binarnie"
  },
  {
    "id": 12,
    "question": "Kodowanie znaków metodą UTF-8 cechuje:",
    "options": [
      {
        "text": "pozwala zakodować dowolne znaki Unicode",
        "inline_explanation": "(Jest pełną implementacją standardu)",
        "correct": true
      },
      {
        "text": "zmienna długość kodu",
        "inline_explanation": "(Znak może zajmować od 1 do 4 bajtów)",
        "correct": true
      },
      {
        "text": "pozwala zakodować dowolne znaki ASCII za pomocą 1 bajta",
        "inline_explanation": "(Pełna kompatybilność wsteczna z ASCII)",
        "correct": true
      },
      {
        "text": "pozwala zakodować dowolne znaki ASCII za pomocą 8 bajtów",
        "inline_explanation": "(Nieefektywne i niezgodne ze standardem)",
        "correct": false
      },
      {
        "text": "pozwala zakodować dowolne znaki Unicode za pomocą nie więcej niż 6 bajtów",
        "inline_explanation": "(Oryginalna specyfikacja dopuszczała 6, obecna RFC ogranicza do 4, ale technicznie jest to prawda w starszych definicjach)",
        "correct": true
      },
      {
        "text": "kod znaku ASCII może być częścią dłuższego kodu",
        "inline_explanation": "(Nie, UTF-8 ma własność prefiksową - bajt ASCII nigdy nie wystąpi w środku znaku wielobajtowego)",
        "correct": false
      }
    ],
    "explanation": "Unicode:\n● znaki z praktycznie wszystkich języków\n● przyporządkowuje każdemu znakowi liczbę - to, jak ta liczba będzie zakodowana, to już inna sprawa\n● wstecznie kompatybilne z ASCII - pierwsze 128 znaków to właśnie ASCII\n● zmienna długość: 1 bajt dla znaków ASCII, do 4 bajtów dla innych języków\n● standardowo używa kodowania UTF-8\n\nUTF-8:\n● 8-bit Unicode Transformation Format\n● koduje znaki standardu Unicode\n● znaki ASCII zapisuje na 8 bitach, późniejsze zestawy na 16, 24 i 32 bitach (czyli 1-4 bajty)\n● rozróżnia zestaw znaków po pierwszych bajtach, np. znaki ASCII to 0xxxxxxx, a znaki z drugiej serii to 110xxxxx 10xxxxxx etc.\n● jeden znak zgodnie z powyższą zasadą można by zapisać na kilka sposobów, dlatego poprawny jest tylko najkrótszy możliwy zapis danego znaku"
  },
  {
    "id": 13,
    "question": "Od czego zależy dokładność liczb zmiennopozycyjnych w komputerze?",
    "options": [
      {
        "text": "od długości cechy",
        "inline_explanation": "(Cecha decyduje o zakresie liczb, a nie dokładności)",
        "correct": false
      },
      {
        "text": "od długości mantysy",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "od długości cechy i mantysy",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "od bazy systemu liczbowego",
        "inline_explanation": "",
        "correct": false
      }
    ],
  "explanation": "Precyzja reprezentacji (ilość cyfr znaczących) zależy bezpośrednio od liczby bitów przeznaczonych na mantysę. Cecha (wykładnik) determinuje zakres liczb (jak duże lub jak małe liczby bliskie zeru możemy zapisać)."
  },
  {
    "id": 14,
    "question": "Cechami kodu uzupełnień do dwóch (U2) są:",
    "options": [
      {
        "text": "podwójna reprezentacja zera",
        "inline_explanation": "(Występuje np. w kodzie Znak-Moduł)",
        "correct": false
      },
      {
        "text": "pojedyncza reprezentacja zera",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "symetryczny zakres liczb",
        "inline_explanation": "(Zakres jest asymetryczny)",
        "correct": false
      },
      {
        "text": "asymetryczny zakres liczb",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Kod U2 posiada tylko jedno zero (reprezentowane samymi zerami). Jest asymetryczny: liczb ujemnych jest o jedną więcej niż dodatnich (jedna liczba dodatnia jest 'zużywana' na reprezentację zera). Zakres wynosi [-2^(n-1), 2^(n-1)-1]."
  },
  {
    "id": 15,
    "question": "Liczby stałopozycyjne w komputerze są reprezentowane w kodzie uzupełnień do 2. Dla jakich wartości funkcja abs(x) (wartość bezwzględna) będzie obliczona prawidłowo?",
    "options": [
      {
        "text": "tylko dla liczb ujemnych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "tylko dla liczb nieujemnych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "dla wszystkich liczb typu integer",
        "inline_explanation": "(Błąd dla najmniejszej ujemnej)",
        "correct": false
      },
      {
        "text": "wszystkich poza najmniejszą liczbą w reprezentacji",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Ze względu na asymetrię kodu U2, najmniejsza liczba ujemna (np. -128 dla 8 bitów) nie posiada swojego dodatniego odpowiednika (zakres dodatni kończy się na 127). Próba obliczenia jej wartości bezwzględnej spowoduje nadmiar (overflow)."
  },
  {
    "id": 16,
    "question": "Dana jest następująca reprezentacja liczb zmiennopozycyjnych: mantysa zajmuje 20 bitów, wykładnik zajmuje 8 bitów. Wykładnik i mantysa zapisywane są w kodzie U2. Z dokładnością do ilu cyfr dziesiętnych można pamiętać liczby w tej reprezentacji?",
    "options": [
      {
        "text": "około 10",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "około 6",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "około 3",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "14",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Decydująca jest długość mantysy. Jedna cyfra dziesiętna wymaga około log_2(10) ≈ 3.32 bita. Mając 20 bitów mantysy, precyzja wynosi: 20 / 3.32 ≈ 6 miejsc dziesiętnych."
  },
  {
    "id": 17,
    "question": "Dana jest następująca reprezentacja liczb zmiennopozycyjnych: mantysa zajmuje 22 bity (w tym bit znaku), cecha zajmuje 10 bitów (w tym bit znaku). Obie w kodzie U2. Mantysa jest ułamkiem [1/2, 1). Jaka jest największa możliwa liczba w tym systemie?",
    "options": [
      {
        "text": "10^10",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "(1 - 2^(-21)) * 2^(2^9 - 1)",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "2^(2^9)",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "(1 - 2^(-22)) * 2^(2^10 - 1)",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Cecha ma 9 bitów wartości (plus znak), więc w kodzie U2 jej maksymalna wartość to 2^9 - 1. Mantysa ma 21 bitów wartości (plus znak). Największa mantysa mniejsza od 1 to suma ciągu geometrycznego (same jedynki), co daje 1 - 2^(-21). Stąd wynik: maksymalna mantysa * 2^(maksymalna cecha)."
  },
  {
    "id": 18,
    "question": "Jaka jest minimalna liczba bitów, aby reprezentować liczby zmiennopozycyjne z zakresu -10^6 ... 10^6 z dokładnością do 2 miejsc znaczących?",
    "options": [
      {
        "text": "8 bitów",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "12 bitów",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "4 bity",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "14 bitów",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Wymagany jest 1 bit na znak. Mantysa musi zapewnić dokładność 2 miejsc po przecinku, co wg wzoru N/3.3 daje około 7 bitów (2 * 3.3 = 6.6). Wykładnik musi pokryć odpowiedni zakres (wg źródła przyjęto 4 bity). Sumarycznie daje to 1 + 4 + 7 = 12 bitów."
  },
  {
    "id": 19,
    "question": "Dana jest reprezentacja liczb zmiennopozycyjnych: mantysa zajmuje 16 bitów, wykładnik 8 bitów (obie w U2). Przecinek leży na lewo od mantysy. Z dokładnością do ilu cyfr dziesiętnych można pamiętać liczby w tej reprezentacji?",
    "options": [
      {
        "text": "7-8",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "15-16",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "4-5",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "2-3",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "O precyzji decyduje długość mantysy. Stosując przybliżenie, że 1 cyfra dziesiętna to ok. 3.32 bita: 16 bitów / 3.32 ≈ 4.8. Pozwala to na zapamiętanie około 4-5 cyfr znaczących."
  },
  {
    "id": 20,
    "question": "Liczba 10010 reprezentowana w systemie U2 (uzupełnień do dwóch) ma wartość:",
    "options": [
      {
        "text": "2",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "-14",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "14",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "6",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "-18",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Najstarszy bit to 1, co oznacza liczbę ujemną. Aby obliczyć jej wartość bezwzględną, odwracamy bity (01101) i dodajemy 1, co daje 01110 (czyli 14 w systemie dziesiętnym). Zatem wynikiem jest -14."
  },
  {
    "id": 21,
    "question": "W standardzie IEEE 754 liczby zmiennopozycyjne podwójnej precyzji:",
    "options": [
      {
        "text": "posiadają mantysę o długości 52 bitów",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "posiadają mantysę o długości 53 bitów",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "posiadają wykładnik o długości 11 bitów",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "posiadają wykładnik o długości 12 bitów",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "gwarantują 7-8 dziesiętnych miejsc znaczących",
        "inline_explanation": "(Prawda na zasadzie implikacji: skoro gwarantują ok. 15, to gwarantują też 7-8)",
        "correct": true
      },
      {
        "text": "posiadają wykładnik o długości 8 bitów",
        "inline_explanation": "(To cecha pojedynczej precyzji - float)",
        "correct": false
      }
    ],
    "explanation": "Liczba typu double zajmuje 64 bity: 1 bit znaku, 11 bitów wykładnika i 52 bity mantysy (plus jeden bit domyślny, co daje 53 bity precyzji). Taka długość mantysy przekłada się na około 15-17 cyfr znaczących (więc stwierdzenie o 7-8 cyfrach jest logicznie prawdziwe, choć nieprecyzyjne)."
  },
  {
    "id": 22,
    "question": "Bramki wykonują operacje na:",
    "options": [
      {
        "text": "słowach",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "wartościach logicznych",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "liczbach całkowitych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "ciągach znaków",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 23,
    "question": "Bramka NAND wykonuje:",
    "options": [
      {
        "text": "najpierw operację iloczynu logicznego, potem negację",
        "inline_explanation": "(NOT AND)",
        "correct": true
      },
      {
        "text": "najpierw operację negacji, potem iloczynu logicznego",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "operację różnicy symetrycznej",
        "inline_explanation": "(To bramka XOR)",
        "correct": false
      },
      {
        "text": "operację sumy logicznej",
        "inline_explanation": "(To bramka OR)",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 24,
    "question": "Zbiór przerzutników służących do przechowywania informacji cyfrowej to:",
    "options": [
      {
        "text": "procesor",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "rejestr",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "sumator",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "multiplekser",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Inne elementy służące do przechowywania to np. pamięć i bufory. Rejestr jest najszybszą formą pamięci wewnątrz procesora."
  },
  {
    "id": 25,
    "question": "Do czego służy stos systemowy?",
    "options": [
      {
        "text": "do przechowywania wszystkich zmiennych w programie",
        "inline_explanation": "(Zmienne globalne/statyczne są w innym segmencie)",
        "correct": false
      },
      {
        "text": "do przechowywania zmiennych alokowanych procedurą new(p)",
        "inline_explanation": "(One trafiają na stertę - heap)",
        "correct": false
      },
      {
        "text": "dla przechowywania zmiennych lokalnych procedur i funkcji",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "do przechowywania adresów powrotu z funkcji",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "do przechowywania zmiennych alokowanych dynamicznie",
        "inline_explanation": "(To sterta)",
        "correct": false
      }
    ],
    "explanation": "Stos (Stack) służy do obsługi wywołań funkcji: przechowuje ramki stosu zawierające zmienne lokalne, argumenty funkcji oraz adres powrotu. Dynamiczna alokacja (malloc/new) korzysta ze sterty (Heap)."
  },
  {
    "id": 26,
    "question": "Zmienna typu wskaźnik zajmuje 4 bajty. Ile pamięci można zaadresować takim wskaźnikiem?",
    "options": [
      {
        "text": "64 kilobajty",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "4 gigabajty",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "2 megabajty",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "6 gigabajtów",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "8 kilobajtów",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "4 bajty to 32 bity. Liczba możliwych adresów wynosi $2^{32}$. Zakładając, że jeden adres wskazuje na 1 bajt (adresowanie bajtowe), otrzymujemy $2^{32}$ bajtów = 4 GB."
  },
  {
    "id": 27,
    "question": "Jaki paradygmat programowania jest realizowany w języku C?",
    "options": [
      {
        "text": "aplikatywny",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "imperatywny",
        "inline_explanation": "(Opisujemy instrukcje krok po kroku)",
        "correct": true
      },
      {
        "text": "deklaratywny",
        "inline_explanation": "(Np. SQL)",
        "correct": false
      },
      {
        "text": "strukturalny",
        "inline_explanation": "(Używa bloków, funkcji, pętli zamiast GOTO)",
        "correct": true
      },
      {
        "text": "obiektowy",
        "inline_explanation": "(C nie jest obiektowy, C++ jest)",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 28,
    "question": "Jeżeli w programie następuje odwołanie poza obszar tablicy:",
    "options": [
      {
        "text": "zawsze sygnalizowany jest błąd wykonania",
        "inline_explanation": "(Nie zawsze, zależy czy trafimy w chronioną pamięć)",
        "correct": false
      },
      {
        "text": "nie jest sygnalizowany błąd, jeżeli pamięć jest zaalokowana",
        "inline_explanation": "(Dla procesu)",
        "correct": true
      },
      {
        "text": "kompilator zawsze wykryje błąd podczas kompilacji",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "wartość pod tym indeksem jest automatycznie zerowana",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Jest to tzw. Undefined Behaviour (zachowanie niezdefiniowane). Jeśli odwołamy się do pamięci, która należy do naszego programu (np. sąsiednia zmienna), system operacyjny nie zgłosi błędu (Segmentation Fault), a program może działać dalej na błędnych danych."
  },
  {
    "id": 29,
    "question": "Których nawiasów trzeba użyć w Odwrotnej Notacji Polskiej do zmiany kolejności wykonywania działań?",
    "options": [
      {
        "text": "{}",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "o kolejności działań nie decydują nawiasy",
        "inline_explanation": "(Jest to notacja beznawiasowa)",
        "correct": true
      },
      {
        "text": "()",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "[]",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "ONP (Odwrotna Notacja Polska) charakteryzuje się tym, że operatory stoją za argumentami. Kolejność wykonywania działań jest jednoznacznie określona przez pozycję operatorów, co eliminuje konieczność stosowania nawiasów."
  },
  {
    "id": 30,
    "question": "Jaki wynik da następujące wyrażenie zapisane w ONP: 2 3 4 5 + * +",
    "options": [
      {
        "text": "25",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "29",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "20",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "35",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Algorytm:\n1. Na stos: 2, 3, 4, 5\n2. Operator +: zdejmij 5 i 4, oblicz 4+5=9. Stos: 2, 3, 9\n3. Operator *: zdejmij 9 i 3, oblicz 3*9=27. Stos: 2, 27\n4. Operator +: zdejmij 27 i 2, oblicz 2+27=29."
  },
  {
    "id": 31,
    "question": "Co oznacza, że algorytm sortowania tablicy posiada złożoność $O(n^2)$?",
    "options": [
      {
        "text": "wykonywana liczba porównań wynosi $n^2$",
        "inline_explanation": "(Oznaczałoby to dokładną wartość, a O to rząd wielkości)",
        "correct": false
      },
      {
        "text": "wykonywana liczba porównań jest rzędu $n^2$",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "wykonywana liczba przestawień elementów tablicy w algorytmie wynosi $n^7$",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "dwukrotne zwiększenie rozmiaru tablicy spowoduje czterokrotne zwiększenie czasu sortowania",
        "inline_explanation": "(Dla n=2x, czas ~ (2x)^2 = 4x^2)",
        "correct": true
      }
    ],
    "explanation": "Złożoność obliczeniowa 'duże O' opisuje asymptotyczne tempo wzrostu czasu wykonywania algorytmu w zależności od rozmiaru danych wejściowych (n). Dla funkcji kwadratowej podwojenie danych skutkuje czterokrotnym wydłużeniem czasu."
  },
  {
    "id": 32,
    "question": "Co oznacza, że algorytm sortowania tablicy posiada złożoność $O(n^2)$?",
    "options": [
      {
        "text": "wykonywana liczba porównań i wykonywana liczba przestawień elementów tablicy w algorytmie wynosi $n^2$",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "wykonywana liczba porównań lub wykonywana liczba przestawień elementów tablicy w algorytmie wynosi $n^2$",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "żadne z powyższych",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Notacja $O(n^2)$ jest górnym ograniczeniem rzędu wielkości, a nie stwierdzeniem o dokładnej liczbie konkretnych operacji (która zależy od implementacji i stałych ukrytych w notacji O)."
  },
  {
    "id": 33,
    "question": "Translacja analizuje symbole:",
    "options": [
      {
        "text": "od lewej do prawej strony",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "od prawej do lewej strony",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "w dowolnej kolejności",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "z góry na dół",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Większość kompilatorów i interpreterów przetwarza kod źródłowy (strumień znaków/tokenów) sekwencyjnie, czytając go od lewej do prawej."
  },
  {
    "id": 34,
    "question": "Prawo dostępu do pliku 453 pozwala:",
    "options": [
      {
        "text": "właścicielowi czytać plik",
        "inline_explanation": "(4 = r--)",
        "correct": true
      },
      {
        "text": "wszystkim czytać plik",
        "inline_explanation": "(Inni mają 3, czyli -wx)",
        "correct": false
      },
      {
        "text": "właścicielowi na odczyt, grupie na odczyt i uruchomienie, pozostałym na zapis i uruchomienie",
        "inline_explanation": "(To pełny opis uprawnień 453)",
        "correct": true
      },
      {
        "text": "grupie na odczyt i zapis, pozostałym tylko na odczyt",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Uprawnienia w notacji ósemkowej to r=4, w=2, x=1. \n4 (Właściciel) = r-- (tylko odczyt).\n5 (Grupa) = r-x (odczyt i wykonanie).\n3 (Inni) = -wx (zapis i wykonanie).\nPełny zapis tekstowy: r--r-x-wx."
  },
  {
    "id": 35,
    "question": "Przy konfiguracji obsługi sieci w Unixie:",
    "options": [
      {
        "text": "plik /etc/hosts przechowuje listę znanych hostów i interfejsów sieciowych",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "plik /etc/hosts zawiera tylko adresy IP lokalnych interfejsów",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "plik /etc/networks zawiera adresy IP znanych sieci IP",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "plik /etc/networks przechowuje listę lokalnych interfejsów",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": ""
  },
  {
    "id": 36,
    "question": "W systemie operacyjnym UNIX prawdziwe są następujące stwierdzenia dotyczące użytkownika i jego sesji:",
    "options": [
      {
        "text": "praca programu logującego (login) jest sterowana m. in. zawartością plików /etc/nologin lub /etc/motd",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "o możliwościach użytkownika w systemie decyduje przynależność do odpowiednich grup użytkowników",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "w zależności od konfiguracji systemu mogą być odnotowywane podłączenia do systemu poprzez zmianę kontekstu użytkownika (komenda su)",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "grupy użytkowników wprowadzono, aby ułatwić zarządzanie użytkownikami oraz podnieść bezpieczeństwo systemu",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "/etc/motd to plik 'message of the day' wyświetlany przy logowaniu. Logowania przez zmianę kontekstu (su/sudo) są logowane w dziennikach systemowych i mogą być blokowane."
  },
  {
    "id": 37,
    "question": "W systemie operacyjnym UNIX prawdziwe są następujące stwierdzenia dotyczące procesu logowania się i uprawnień użytkowników:",
    "options": [
      {
        "text": "o postaci hasła decyduje administrator systemu zapisując ograniczenia w różnych wersjach systemu w różnych plikach konfiguracyjnych",
        "inline_explanation": "(np. w /etc/pam.d/)",
        "correct": true
      },
      {
        "text": "wszystkie grupy użytkowników dają im jednakowe uprawnienia",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "cała informacja dotycząca konfiguracji użytkownika w systemie jest zapisana jedynie w pliku /etc/passwd",
        "inline_explanation": "(Są też inne pliki, np. /etc/group, /etc/shadow)",
        "correct": false
      },
      {
        "text": "nazwa użytkownika w systemie UNIX musi być unikalna, zaś numer identyfikacyjny może się powtarzać",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "system PAM umożliwia m.in. odnotowywanie nieudanych prób podłączania się do systemu",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "technika shadow umożliwia podglądnięcie postaci zaszyfrowanej hasła każdego użytkownika przez dowolnego użytkownika",
        "inline_explanation": "(Tylko root ma dostęp do shadow)",
        "correct": false
      }
    ],
    "explanation": "System PAM (Pluggable Authentication Modules) zarządza polityką uwierzytelniania. Informacje o użytkownikach są rozproszone (passwd, shadow, group). UID teoretycznie może się powtarzać (wskazując na tego samego użytkownika logicznego), ale nazwa (login) musi być unikalna."
  },
  {
    "id": 38,
    "question": "Zaznacz prawdziwe stwierdzenia na temat procesów:",
    "options": [
      {
        "text": "proces jest wykonaniem programu i składa się ze zbiorowości bajtów, w których wyróżnia się instrukcje maszynowe (tzw. tekst), dane i stos",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "w kategoriach praktycznych proces jest jednostką utworzoną za pomocą funkcji systemowej fork (z wyjątkiem procesu o numerze 0)",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "każdy uruchomiony w systemie UNIX proces otrzymuje od procesu potomnego dostęp do jego zmiennych środowiskowych",
        "inline_explanation": "(Na odwrót: potomny dziedziczy od macierzystego)",
        "correct": false
      },
      {
        "text": "każdy uruchomiony w systemie UNIX proces otrzymuje od systemu trzy otwarte pliki o numerach 0, 1 i 2",
        "inline_explanation": "(STDIN, STDOUT, STDERR)",
        "correct": true
      },
      {
        "text": "rekord w tablicy procesów znajdującej się w jądrze systemu zawiera podstawowe informacje o procesie (właściciele, lista segmentów, wskaźniki do U-obszaru)",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "liczba możliwych do uruchomienia procesów jest ograniczona jedynie rozmiarem pamięci RAM",
        "inline_explanation": "(Ogranicza ją też tabela procesów/PID)",
        "correct": false
      }
    ],
    "explanation": "Każdy proces otrzymuje standardowe strumienie: 0 (wejście), 1 (wyjście), 2 (błędy). Struktura procesu obejmuje segment tekstu (kod), danych (zmienne) oraz stos."
  },
  {
    "id": 39,
    "question": "Interpretery poleceń systemu UNIX:",
    "options": [
      {
        "text": "w niektórych interpreterach poleceń można uniemożliwić odłączanie się od systemu poprzez wykorzystanie sekwencji Ctrl-D dzięki ustawieniu wartości odpowiedniej zmiennej środowiskowej",
        "inline_explanation": "(np. zmienna IGNOREEOF)",
        "correct": true
      },
      {
        "text": "wszystkie polecenia shella zwracają wartość 0 (zero), kiedy wykonanie ich zakończy się niepowodzeniem lub wartość różną od 0 (zazwyczaj 1) w przypadku przeciwnym",
        "inline_explanation": "(Na odwrót: 0 oznacza sukces, >0 błąd)",
        "correct": false
      },
      {
        "text": "każdy interpreter wykorzystuje trzy podstawowe typy zmiennych: specjalne, środowiska oraz programowe",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "błędne wykonanie komendy w linii komend można rozpoznać m. in. po zapisach do urządzenia /dev/null",
        "inline_explanation": "(/dev/null to 'czarna dziura', zapisane tam błędy znikają bezpowrotnie)",
        "correct": false
      }
    ],
    "explanation": "Standardowo Ctrl-D wysyła EOF (End Of File) i zamyka shella, ale ustawienie IGNOREEOF wymusza użycie komendy 'exit' lub wielokrotnego naciśnięcia Ctrl-D. W Unixie kod powrotu 0 oznacza sukces, a kody niezerowe oznaczają błąd."
  },
  {
    "id": 40,
    "question": "W systemie operacyjnym UNIX:",
    "options": [
      {
        "text": "nie ma możliwości odnotowywania nieudanych prób podłączania się do systemu",
        "inline_explanation": "(Można, np. przez PAM lub logi systemowe)",
        "correct": false
      },
      {
        "text": "każda komenda posiada inną składnię",
        "inline_explanation": "(Zgodnie z kluczem uznane za prawdę, choć dyskusyjne)",
        "correct": true
      },
      {
        "text": "istnieje możliwość zabronienia podłączania się do systemu wybranemu użytkownikowi z wykorzystaniem protokołu SSH",
        "inline_explanation": "(np. w pliku konfiguracyjnym sshd_config)",
        "correct": true
      },
      {
        "text": "każdy użytkownik posiada unikalną nazwę oraz unikalny numer",
        "inline_explanation": "(Tylko nazwę musi mieć unikalną, UID teoretycznie może się powtarzać)",
        "correct": false
      }
    ],
    "explanation": "Systemy Unixowe mają rozbudowane mechanizmy logowania zdarzeń (syslog, auth.log). Konfiguracja SSH (DenyUsers/AllowUsers) pozwala precyzyjnie zarządzać dostępem."
  },
  {
    "id": 41,
    "question": "W systemie plików systemu UNIX:",
    "options": [
      {
        "text": "system plików składa się z ciągu bloków logicznych zawierających 512, 1024, 2048 lub dowolną inną wielokrotność 512 bajtów",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "system plików przed użyciem należy zamontować, gdyż inaczej zawarte w nim dane nie będą dostępne",
        "inline_explanation": "(Komenda mount)",
        "correct": true
      },
      {
        "text": "prawo SUID obowiązuje dla pliku i dla katalogu: w przypadku pliku oznacza, iż program uruchamiany jest z UID właściciela pliku, zaś w przypadku katalogu, że użytkownik pracuje w nim (katalogu) z UID właściciela",
        "inline_explanation": "(Dla katalogów SUID/SGID dotyczy zazwyczaj dziedziczenia grupy dla nowych plików)",
        "correct": false
      },
      {
        "text": "cofnięcie prawa zapisu do pliku dla jego właściciela uniemożliwia usunięcie go",
        "inline_explanation": "(O możliwości usunięcia pliku decydują uprawnienia do katalogu, w którym plik się znajduje)",
        "correct": false
      }
    ],
    "explanation": "Aby system operacyjny widział pliki na partycji, musi ona zostać zamontowana w drzewie katalogów. Uprawnienia do usuwania plików są związane z prawem zapisu (w) do katalogu nadrzędnego, a nie samego pliku."
  },
  {
    "id": 42,
    "question": "W systemie plików systemu UNIX:",
    "options": [
      {
        "text": "stosowany w systemach plików systemu UNIX system kontyngentów (quota) jest zorientowany na użytkownika i obejmuje wszystkie jego pliki w całym drzewie katalogów od katalogu głównego począwszy",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "każdy plik opisuje dokładnie jeden i-węzeł",
        "inline_explanation": "(Nawet jeśli ma wiele nazw/hardlinków, i-węzeł jest jeden)",
        "correct": true
      },
      {
        "text": "prawo SUID nadane plikowi przechowującemu kod wykonywalny np. komendy passwd umożliwia modyfikację zawartości plików, których właścicielem jest właściciel pliku /bin/passwd",
        "inline_explanation": "(Dzięki temu zwykły użytkownik może zmienić swoje hasło w /etc/shadow)",
        "correct": true
      },
      {
        "text": "i-węzły są przechowywane w systemach plików na dysku oraz kopiowane do tablic jądra systemu w chwili montowania systemu plików",
        "inline_explanation": "(Jądro wczytuje je w momencie dostępu do pliku, a nie przy montowaniu)",
        "correct": false
      }
    ],
    "explanation": "Mechanizm SUID sprawia, że proces uruchomiony przez użytkownika działa z uprawnieniami właściciela pliku wykonywalnego (często roota), co pozwala na wykonywanie uprzywilejowanych operacji."
  },
  {
    "id": 43,
    "question": "Szyfrowanie kluczem publicznym w szyfrowaniu asymetrycznym:",
    "options": [
      {
        "text": "pozwala jedynie właściwemu odbiorcy odkodować komunikat",
        "inline_explanation": "(Technicznie: pozwala temu, kto ma klucz prywatny)",
        "correct": false
      },
      {
        "text": "tylko posiadacz klucza prywatnego może odkodować komunikat",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "wystarczy użyć tego samego klucza do deszyfrowania wiadomości",
        "inline_explanation": "(To opis szyfrowania symetrycznego)",
        "correct": false
      },
      {
        "text": "wiadomość zaszyfrowana za pomocą klucza publicznego może być odszyfrowana tylko za pomocą klucza prywatnego",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "tworzy funkcję skrótu w podpisie elektronicznym",
        "inline_explanation": "(Klucz prywatny służy do podpisywania skrótu)",
        "correct": true
      },
      {
        "text": "pozwala każdemu odkodować komunikat",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "W kryptografii asymetrycznej para kluczy (prywatny i publiczny) jest matematycznie powiązana. To, co zaszyfrowano kluczem publicznym, można odszyfrować tylko prywatnym (poufność). To, co zaszyfrowano (podpisano) prywatnym, można zweryfikować publicznym (autentyczność/podpis)."
  },
  {
    "id": 44,
    "question": "Jeżeli elementy w tablicy są posortowane możliwe jest wyszukiwanie:",
    "options": [
      {
        "text": "sekwencyjne",
        "inline_explanation": "(Możliwe zawsze, niezależnie od posortowania)",
        "correct": true
      },
      {
        "text": "binarne",
        "inline_explanation": "(Wymaga posortowania, złożoność O(log n))",
        "correct": true
      },
      {
        "text": "interpolacyjne",
        "inline_explanation": "(Ulepszone binarne, szacuje pozycję, wymaga posortowania)",
        "correct": true
      },
      {
        "text": "żadne z wymienionych",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Posortowanie tablicy otwiera drogę do szybszych algorytmów wyszukiwania (binarne, interpolacyjne), ale nie zabrania stosowania najprostszego wyszukiwania sekwencyjnego (liniowego)."
  },
  {
    "id": 45,
    "question": "Przy rozmieszczaniu algorytmicznym kolizja może wystąpić, gdy:",
    "options": [
      {
        "text": "klucze w dwóch rozmieszczanych rekordach są identyczne",
        "inline_explanation": "(Wtedy hasze muszą być identyczne)",
        "correct": true
      },
      {
        "text": "klucze w dwóch rozmieszczanych rekordach są różne",
        "inline_explanation": "(Dwa różne klucze mogą dać ten sam hash)",
        "correct": true
      },
      {
        "text": "znumeryzowane klucze dwóch rekordów są różne",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "znumeryzowane klucze dwóch rekordów są identyczne",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Kolizja w tablicy mieszającej występuje wtedy, gdy funkcja skrótu (hashująca) zwraca ten sam indeks dla dwóch różnych kluczy (co jest naturalne przy ograniczonej wielkości tablicy). Oczywiście dla identycznych kluczy wynik funkcji też jest ten sam."
  },
  {
    "id": 46,
    "question": "Najszybsza metoda sortowania oparta o porównywanie kluczy posiada złożoność:",
    "options": [
      {
        "text": "liniową",
        "inline_explanation": "(O(n) osiągalne tylko dla metod nieporównujących, np. Counting Sort)",
        "correct": false
      },
      {
        "text": "liniowo-logarytmiczną",
        "inline_explanation": "$(O(n log(n)))$",
        "correct": true
      },
      {
        "text": "stałą",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "kwadratową",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Udowodniono matematycznie, że dolną granicą złożoności pesymistycznej dla dowolnego algorytmu sortowania opartego na porównaniach jest Ω(n log n)."
  },
  {
    "id": 47,
    "question": "Ekstensywna metoda sortowania to:",
    "options": [
      {
        "text": "taka, w której czas sortowania wzrasta wraz ze wzrostem tablicy",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "taka, która wymaga dodatkowej pamięci porównywalnej z rozmiarem sortowanej struktury",
        "inline_explanation": "(Złożoność pamięciowa O(n))",
        "correct": true
      },
      {
        "text": "taka, która wymaga dodatkowej pamięci porównywalnej z rozmiarem pojedynczego rekordu",
        "inline_explanation": "(To algorytmy 'w miejscu' / in-place)",
        "correct": false
      },
      {
        "text": "każda szybka metoda sortowania",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Algorytmy ekstensywne (out-of-place) potrzebują dodatkowego bufora pamięci o rozmiarze zależnym od n (np. Merge Sort w typowej implementacji na tablicach). Przeciwieństwem są algorytmy 'in-place' (w miejscu), np. Bubble Sort czy Heap Sort."
  },
  {
    "id": 48,
    "question": "Stabilną metodą sortowania jest sortowanie:",
    "options": [
      {
        "text": "bąbelkowe",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "grzebieniowe",
        "inline_explanation": "(Niestabilne)",
        "correct": false
      },
      {
        "text": "kubełkowe",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "pozycyjne",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "przez kopcowanie",
        "inline_explanation": "(Niestabilne)",
        "correct": false
      },
      {
        "text": "przez scalanie",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "przez wstawianie",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "szybkie",
        "inline_explanation": "(Quicksort jest niestabilny)",
        "correct": false
      },
      {
        "text": "przez zliczanie",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Sortowanie stabilne zachowuje względną kolejność elementów o tych samych kluczach. Do niestabilnych należą m.in.: QuickSort, HeapSort (przez kopcowanie), Selection Sort (przez wybieranie)."
  },
  {
    "id": 49,
    "question": "Które metody sortowania mają złożoność $O(n)$?",
    "options": [
      {
        "text": "bąbelkowe",
        "inline_explanation": "($O(n^2)$)",
        "correct": false
      },
      {
        "text": "kubełkowe",
        "inline_explanation": "(Bucket Sort)",
        "correct": true
      },
      {
        "text": "pozycyjne",
        "inline_explanation": "(Radix Sort)",
        "correct": true
      },
      {
        "text": "przez scalanie",
        "inline_explanation": "($O(n \\log n)$)",
        "correct": false
      },
      {
        "text": "przez zliczanie",
        "inline_explanation": "(Counting Sort)",
        "correct": true
      },
      {
        "text": "szybkie",
        "inline_explanation": "($O(n \\log n)$)",
        "correct": false
      }
    ],
    "explanation": "Złożoność liniową $O(n)$ mogą osiągnąć tylko algorytmy nieoparte na porównywaniu elementów (non-comparison sorts), takie jak sortowanie przez zliczanie, kubełkowe czy pozycyjne, zazwyczaj przy pewnych założeniach dotyczących danych wejściowych."
  },
  {
    "id": 50,
    "question": "Które metody sortowania mają złożoność $O(n^2)$?",
    "options": [
      {
        "text": "bąbelkowe",
        "inline_explanation": "(Bubble Sort)",
        "correct": true
      },
      {
        "text": "kubełkowe",
        "inline_explanation": "($O(n)$)",
        "correct": false
      },
      {
        "text": "przez scalanie",
        "inline_explanation": "($O(n \\log n)$)",
        "correct": false
      },
      {
        "text": "przez wstawianie",
        "inline_explanation": "(Insertion Sort)",
        "correct": true
      },
      {
        "text": "przez wybieranie",
        "inline_explanation": "(Selection Sort)",
        "correct": true
      },
      {
        "text": "szybkie",
        "inline_explanation": "(Średnio $O(n \\log n)$)",
        "correct": false
      }
    ],
    "explanation": "Do algorytmów o złożoności kwadratowej należą proste algorytmy takie jak bąbelkowe, przez wstawianie i przez wybieranie. Są one nieefektywne dla dużych zbiorów danych."
  },
  {
    "id": 51,
    "question": "Drzewo BST jest drzewem AVL, gdy:",
    "options": [
      {
        "text": "dla każdego wierzchołka rozmiary jego poddrzew różnią się co najwyżej o 1",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "dla każdego wierzchołka wysokości jego poddrzew różnią się co najwyżej o 1",
        "inline_explanation": "(Warunek zrównoważenia)",
        "correct": true
      },
      {
        "text": "dla każdego wierzchołka wysokości jego poddrzew różnią się dokładnie o 1",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "dla każdego wierzchołka rozmiary jego poddrzew różnią się dokładnie o 1",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Drzewo AVL to zrównoważone drzewo poszukiwań binarnych (BST), w którym wysokość lewego i prawego poddrzewa każdego węzła różni się co najwyżej o jeden."
  },
  {
    "id": 52,
    "question": "Drzewo binarne pełne o N poziomach posiada:",
    "options": [
      {
        "text": "N węzłów",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "$2*N$ węzłów",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "$2^N$ węzłów",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "$(2^N)-1$ węzłów",
        "inline_explanation": "(Suma ciągu geometrycznego: $2^0 + ... + 2^{N-1}$)",
        "correct": true
      }
    ],
    "explanation": "Na poziomie k (licząc od 0) znajduje się $2^k$ węzłów. Suma węzłów dla N poziomów (od 0 do N-1) wynosi $\\sum_{i=0}^{N-1} 2^i = 2^N - 1$."
  },
  {
    "id": 53,
    "question": "Złożoność wyszukiwania w drzewie AVL jest:",
    "options": [
      {
        "text": "liniowa ze względu na liczbę poziomów",
        "inline_explanation": "(Bo musimy zejść w dół drzewa)",
        "correct": true
      },
      {
        "text": "kwadratowa ze względu na liczbę poziomów",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "liniowa ze względu na liczbę węzłów",
        "inline_explanation": "(To dotyczy niezrównoważonego BST)",
        "correct": false
      },
      {
        "text": "logarytmiczna ze względu na liczbę węzłów",
        "inline_explanation": "(Wysokość drzewa AVL to $O(\\log n)$)",
        "correct": true
      }
    ],
    "explanation": "Wyszukiwanie w drzewie binarnym zależy od jego wysokości. Drzewo AVL jest zrównoważone, więc jego wysokość (liczba poziomów) jest rzędu $O(\\log n)$, gdzie n to liczba węzłów."
  },
  {
    "id": 54,
    "question": "Drzewo rozpinające graf zawiera:",
    "options": [
      {
        "text": "niektóre wierzchołki grafu",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "wszystkie wierzchołki grafu",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "żadne z wymienionych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "cykl Hamiltona",
        "inline_explanation": "(Drzewo z definicji nie posiada cykli)",
        "correct": false
      }
    ],
    "explanation": "Drzewo rozpinające (Spanning Tree) to podgraf, który jest drzewem i zawiera wszystkie wierzchołki grafu wyjściowego, połączone minimalną liczbą krawędzi."
  },
  {
    "id": 55,
    "question": "Ile cykli Hamiltona posiada graf pełny o N wierzchołkach?",
    "options": [
      {
        "text": "N",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "1",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "0",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "$N^2$",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "N!",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "$(N-1)!/2$",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Mamy $(N-1)$ kandydatów na pierwszą krawędź (z ustalonego wierzchołka startowego), $(N-2)$ na drugą, itd., co daje $(N-1)!$ permutacji. Ponieważ graf jest nieskierowany (cykl A-B-C to to samo co C-B-A), dzielimy wynik przez 2."
  },
  {
    "id": 56,
    "question": "Zadanie o rozmiarze n, realizowane pewnym algorytmem o złożoności $f(n)$, zostało sprowadzone do dwóch podzadań o rozmiarze $n/2$ każde oraz do n działań o stałym czasie wykonania, zapewniających rozbicie i scalenie zadania. Złożoność $f(n)$ wynosi:",
    "options": [
      {
        "text": "$f(n) = O(\\log(n))$",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "$f(n) = O(n \\log(n))$",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "$f(n) = O(n + \\log(n))$",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "$f(n) = O(n)$",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Jest to opis algorytmu Sortowania przez Scalanie (Merge Sort). Rekurencja ma postać $T(n) = 2T(n/2) + O(n)$, co zgodnie z Twierdzeniem o Rekurencji Uniwersalnej (Master Theorem) daje złożoność $O(n \\log n)$."
  },
  {
    "id": 57,
    "question": "Dla problemu komiwojażera algorytm pozwalający wyznaczyć rozwiązanie optymalne:",
    "options": [
      {
        "text": "istnieje i ma złożoność wielomianową",
        "inline_explanation": "(Problem jest NP-trudny, więc nie znamy takiego algorytmu)",
        "correct": false
      },
      {
        "text": "istnieje i ma złożoność wykładniczą",
        "inline_explanation": "(Np. algorytm Helda-Karpa o złożoności $O(n^2 2^n)$)",
        "correct": true
      },
      {
        "text": "nie istnieje",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Problem komiwojażera jest problemem NP-trudnym. Istnieją algorytmy dokładne (znajdujące optimum), ale mają one złożoność wykładniczą. Algorytmy wielomianowe istnieją tylko dla rozwiązań przybliżonych."
  },
  {
    "id": 58,
    "question": "Dana jest procedura: `Proc(n) { if (warunek(x)) then { A(x); Proc(f(n)); B(x) } else C(x) }`. Przyjmijmy konwencję, że np. zapis AAABCC oznacza trzykrotne wykonanie instrukcji A, itd. Następujące sekwencje instrukcji mogą być wynikiem wywołania powyższej procedury:",
    "options": [
      {
        "text": "AACBB",
        "inline_explanation": "(2 razy A, 1 raz C, 2 razy B - poprawne)",
        "correct": true
      },
      {
        "text": "ACBB",
        "inline_explanation": "(Liczba A musi być równa liczbie B)",
        "correct": false
      },
      {
        "text": "AACCBB",
        "inline_explanation": "(C wykonuje się tylko raz w warunku stopu)",
        "correct": false
      },
      {
        "text": "ACCB",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "C",
        "inline_explanation": "(Przypadek, gdy warunek od razu jest fałszywy - poprawne)",
        "correct": true
      },
      {
        "text": "AAACCCBBB",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "AABBC",
        "inline_explanation": "(Zła kolejność, C musi być w środku)",
        "correct": false
      }
    ],
    "explanation": "Struktura procedury odpowiada gramatyce bezkontekstowej $S \\to ASB | C$. Każde wywołanie rekurencyjne dokłada jedno A przed i jedno B po. Rekurencja kończy się pojedynczym wywołaniem C. Zatem poprawne ciągi to $A^n C B^n$ (tyle samo A co B, z C w środku)."
  },
  {
    "id": 59,
    "question": "Dana w C, C++, czy Javie umieszczana jest w spójnym obszarze pamięci operacyjnej:",
    "options": [
      {
        "text": "tylko dla danych typów predefiniowanych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "tylko dla danych skalarnych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "tylko dla danych złożonych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "i dla danych skalarnych, i dla danych złożonych",
        "inline_explanation": "(Wymienione języki dążą do spójnej reprezentacji struktur/tablic)",
        "correct": true
      }
    ],
    "explanation": "W językach takich jak C czy C++ tablice i struktury zajmują ciągły blok pamięci. W Javie obiekty również alokowane są w stercie jako spójne bloki (choć tablice obiektów to tablice referencji)."
  },
  {
    "id": 60,
    "question": "W językach imperatywnych (również obiektowych) przy wyborze reprezentacji dla danych rzeczywistych (zmiennoprzecinkowych) pojawiają się problemy:",
    "options": [
      {
        "text": "wystąpienia nadmiaru",
        "inline_explanation": "(Overflow - przekroczenie zakresu wykładnika na plus)",
        "correct": true
      },
      {
        "text": "wystąpienia niedomiaru",
        "inline_explanation": "(Underflow - liczba zbyt bliska zera, by ją zapisać)",
        "correct": true
      },
      {
        "text": "dokładności",
        "inline_explanation": "(Ograniczona precyzja mantysy)",
        "correct": true
      },
      {
        "text": "braku możliwości zapisu liczby 0",
        "inline_explanation": "(Zero ma swoją reprezentację w standardzie IEEE 754)",
        "correct": false
      }
    ],
    "explanation": "Arytmetyka zmiennoprzecinkowa (floating point) jest ze swojej natury przybliżona i ograniczona. Problemy obejmują skończoną precyzję (zaokrąglenia) oraz ograniczony zakres (możliwość wygenerowania nieskończoności przy nadmiarze lub utraty precyzji przy niedomiarze)."
  },
  {
    "id": 61,
    "question": "Wskazania (pointers) w C, C++ używane są do reprezentowania (wskazywania):",
    "options": [
      {
        "text": "obszarów pamięci operacyjnej",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "zmiennych złożonych",
        "inline_explanation": "(np. struktur, tablic)",
        "correct": true
      },
      {
        "text": "zmiennych skalarnych",
        "inline_explanation": "(np. int, char)",
        "correct": true
      },
      {
        "text": "funkcji i metod",
        "inline_explanation": "(Wskaźniki na funkcje)",
        "correct": true
      }
    ],
    "explanation": "Wskaźnik w C/C++ to po prostu zmienna przechowywująca adres w pamięci. Ponieważ w pamięci może znajdować się wszystko (kod, dane proste, dane złożone), wskaźnik może wskazywać na każdy z tych elementów."
  },
  {
    "id": 62,
    "question": "W jaki sposób można obliczyć długość tekstu przekazanego jako argument w poniższej funkcji w języku C? void foo (const char* txt) { ... }",
    "options": [
      {
        "text": "sizeof (txt)",
        "inline_explanation": "(Zwróci rozmiar wskaźnika, np. 4 lub 8 bajtów)",
        "correct": false
      },
      {
        "text": "strlen (txt)",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "txt.length()",
        "inline_explanation": "(To składnia C++, obiekt string)",
        "correct": false
      },
      {
        "text": "zliczając, ile znaków występuje w tekście od znaku na który wskazuje wskaźnik do znaku końca łańcucha znaków ('\\0')",
        "inline_explanation": "(To dokładnie robi funkcja strlen)",
        "correct": true
      }
    ],
    "explanation": "W C łańcuchy znaków (C-strings) są zakończone znakiem null ('\\0'). Aby poznać ich długość, trzeba policzyć znaki aż do napotkania zera (robi to funkcja `strlen`). Operator `sizeof` na wskaźniku zwróci tylko rozmiar adresu w pamięci."
  },
  {
    "id": 63,
    "question": "Co możesz powiedzieć o poniższej deklaracji w języku C?\n`int t[10] = {1, 2, [4]=1};`",
    "options": [
      {
        "text": "zgodnie ze standardem C99 spowoduje ona utworzenie tablicy zawierającej 10 elementów, z których 7 ma wartość 0",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "da ona taki sam efekt, jak deklaracja: int t[] = {1, 2, 0, 0, 1}",
        "inline_explanation": "(Nie, bo t[] miałaby rozmiar 5, a t[10] ma rozmiar 10)",
        "correct": false
      },
      {
        "text": "jest to błąd składniowy",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Jest to tzw. 'designated initializer' wprowadzony w C99. Tablica ma rozmiar 10. Indeksy 0, 1 i 4 są zainicjalizowane jawnie (wartości 1, 2, 1). Pozostałe elementy są automatycznie zerowane. Tablica wygląda tak: {1, 2, 0, 0, 1, 0, 0, 0, 0, 0}."
  },
  {
    "id": 64,
    "question": "W jaki sposób obliczyć długość tablicy w funkcji foo() w języku C? void foo (double t[]) { // dlugosc tablicy t? }",
    "options": [
      {
        "text": "nie da się obliczyć",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "po wykonaniu poniższej instrukcji długość tablicy będzie umieszczona w zmiennej len: int len; for(len=0; t[len]; len++);",
        "inline_explanation": "(Działa tylko dla tablic zakończonych wartownikiem, tu byłby błąd)",
        "correct": false
      },
      {
        "text": "używając operatora sizeof(t) / sizeof(double)",
        "inline_explanation": "(Zwróci rozmiar wskaźnika dzielony przez rozmiar doubla - bzdura)",
        "correct": false
      }
    ],
    "explanation": "Przy przekazywaniu tablicy do funkcji w C następuje degradacja do wskaźnika (decay to pointer). Funkcja otrzymuje tylko adres początku danych, tracąc informację o rozmiarze bufora. Rozmiar musi być przekazany jako osobny argument."
  },
  {
    "id": 65,
    "question": "Która z implementacji funkcji zwracającej tablicę w języku C jest poprawna?",
    "options": [
      {
        "text": "int[] getTable() { int tab [10]; return tab; }",
        "inline_explanation": "(Błąd: zwraca adres zmiennej lokalnej, która przestaje istnieć po wyjściu z funkcji)",
        "correct": false
      },
      {
        "text": "int* getTable (int n) { return (int*) malloc(n * sizeof(int)); }",
        "inline_explanation": "(Poprawne: alokacja na stercie)",
        "correct": true
      },
      {
        "text": "int* getTable (int n) { return (int*) calloc(n, sizeof(int)); }",
        "inline_explanation": "(Poprawne: alokacja na stercie z zerowaniem)",
        "correct": true
      },
      {
        "text": "żadna z wymienionych",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "W języku C nie można zwracać tablic utworzonych lokalnie na stosie (opcja a), ponieważ pamięć ta jest zwalniana po zakończeniu funkcji. Aby zwrócić tablicę, należy zaalokować ją dynamicznie (malloc/calloc) lub użyć tablicy statycznej (static)."
  },
  {
    "id": 66,
    "question": "Przeanalizuj poniższą deklarację w języku C: `int (*x) (int, int);`",
    "options": [
      {
        "text": "zmienna x jest dwuwymiarową tablicą wskaźników typu int* o zmiennym rozmiarze",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "deklaracja jest niezgodna ze składnią języka",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "zmienna x jest wskaźnikiem na funkcję przyjmującą dwa argumenty typu int, zwracającą wartość typu int",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "zmienna x jest funkcją zwracającą wskaźnik na int",
        "inline_explanation": "(To byłoby: int* x(int, int))",
        "correct": false
      }
    ],
    "explanation": "Nawiasy `(*x)` wskazują, że x jest wskaźnikiem. Nawiasy `(int, int)` po prawej oznaczają, że wskazuje on na funkcję przyjmującą dwa inty. Typ `int` na początku określa typ zwracany przez tę funkcję."
  },
  {
    "id": 67,
    "question": "Które stwierdzenia dotyczące operatorów w języku C/C++ są poprawne:",
    "options": [
      {
        "text": "operatory addytywne (+, -) mają mniejszy priorytet niż multiplikatywne (*, /, %)",
        "inline_explanation": "(Standardowa kolejność działań)",
        "correct": true
      },
      {
        "text": "wyrażenie z==++z jest zawsze fałszywe",
        "inline_explanation": "(To zachowanie niezdefiniowane - undefined behavior)",
        "correct": false
      },
      {
        "text": "operator przypisania (=) ma wyższy priorytet niż operator porównania (==)",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "żadne z pozostałych",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "W C/C++ mnożenie i dzielenie są wykonywane przed dodawaniem i odejmowaniem (mają wyższy priorytet), podobnie jak w matematyce."
  },
  {
    "id": 68,
    "question": "Dzięki konwencji wywołania funkcji w języku C/C++ znanej jako `_cdecl` możliwa jest implementacja funkcji o zmiennej liczbie argumentów (jak `printf`). Które stwierdzenia są prawdziwe?",
    "options": [
      {
        "text": "w wygenerowanym kodzie wywołania funkcji argumenty umieszczane są na stosie od końca (od prawej do lewej)",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "analizując pierwszy argument na szczycie stosu można określić liczbę argumentów (dzięki kolejności odkładania)",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "to funkcja wołana (callee) czyści stos po wykonaniu",
        "inline_explanation": "(W _cdecl robi to wołający - caller)",
        "correct": false
      },
      {
        "text": "w języku C kompilator może utworzyć kod wywołania funkcji typu _cdecl nie mając żadnych informacji o typach jej parametrów",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "W konwencji `_cdecl` (domyślnej dla C) argumenty odkłada się na stos od prawej do lewej. Dzięki temu pierwszy argument (np. format string w printf) jest zawsze w znanym miejscu na wierzchu stosu, co pozwala funkcji określić, ile i jakich argumentów pobrać dalej."
  },
  {
    "id": 69,
    "question": "W jaki sposób przekazywany jest parametr będący tablicą do funkcji w języku C? np. `int main(int argc, char* argv[])`",
    "options": [
      {
        "text": "cała zawartość tablicy kopiowana jest na stos",
        "inline_explanation": "(Byłoby to nieefektywne)",
        "correct": false
      },
      {
        "text": "na stos przekazywany jest adres pierwszego elementu tablicy",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "tablice są zawsze przekazywane do funkcji jako wskaźnik",
        "inline_explanation": "(Decay to pointer)",
        "correct": true
      },
      {
        "text": "tablice są przekazywane przez referencję",
        "inline_explanation": "(C nie posiada referencji w sensie C++, używa wskaźników)",
        "correct": false
      }
    ],
    "explanation": "W C nie można przekazać tablicy przez wartość. Zapis `char* argv[]` jest tylko lukrem składniowym (syntactic sugar) dla `char** argv`. Do funkcji zawsze trafia wskaźnik na pierwszy element."
  },
  {
    "id": 70,
    "question": "Aby sprawdzić, czy dwa obiekty typu String w języku Java mają taką samą zawartość, można:",
    "options": [
      {
        "text": "użyć metody equals()",
        "inline_explanation": "Inną możliwością jest wykorzystać metodę `compareTo()` i sprawdzić, czy zwraca 0 (identyczna zawartość).",
        "correct": true
      },
      {
        "text": "użyć operatora ==",
        "inline_explanation": "(Sprawdza identyczność referencji/adresów w pamięci, a nie treść)",
        "correct": false
      },
      {
        "text": "użyć metody compareTo() i sprawdzić czy zwraca 0",
        "inline_explanation": "(To też działa, choć equals jest bardziej standardowe do równości)",
        "correct": true
      },
      {
        "text": "rzutować na char[] i porównać długości",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "W Javie operator `==` dla obiektów porównuje referencje (czy to ten sam obiekt w pamięci). Do porównywania zawartości logicznej (czy napisy są takie same) służy metoda `.equals()`."
  },
  {
    "id": 71,
    "question": "Który z poniższych fragmentów kodu w języku Java sprawdza, czy obiekt wskazywany przez referencję `xyz` należy do klasy `XYZ`?",
    "options": [
      {
        "text": "if (xyz instanceof XYZ)",
        "inline_explanation": "(Standardowy operator sprawdzania typu)",
        "correct": true
      },
      {
        "text": "if (xyz.dynamicCastTo(XYZ.class) != null)",
        "inline_explanation": "(Składnia nieistniejąca w Javie)",
        "correct": false
      },
      {
        "text": "XYZ.class.isInstance(xyz)",
        "inline_explanation": "(Dynamiczne sprawdzenie przez refleksję)",
        "correct": true
      },
      {
        "text": "XYZ.class.isAssignableFrom(xyz.getClass())",
        "inline_explanation": "(Sprawdzenie czy klasę obiektu można przypisać do zmiennej typu XYZ)",
        "correct": true
      }
    ],
    "explanation": "W Javie podstawowym sposobem jest operator `instanceof`. Mechanizmy refleksji (`isInstance`, `isAssignableFrom`) pozwalają na to samo w sposób dynamiczny (gdy typ nie jest znany w czasie kompilacji)."
  },
  {
    "id": 72,
    "question": "Tablica w języku Java jest zadeklarowana jako: `int tab[] = {3, 2, 1, 0};` Który z fragmentów kodu poprawnie wypisze jej elementy?",
    "options": [
      {
        "text": "for (int i: tab) System.out.println(tab[i] + \" \");",
        "inline_explanation": "(Wypisze '0 1 2 3' zamiast elementów, bo używa wartości jako indeksów)",
        "correct": false
      },
      {
        "text": "for (int i=0; i < tab.length; i++) System.out.println(tab[i] + \" \");",
        "inline_explanation": "(Klasyczna pętla for)",
        "correct": true
      },
      {
        "text": "for (int i: tab) System.out.println(i + \" \");",
        "inline_explanation": "(Pętla for-each, i przyjmuje wartości elementów)",
        "correct": true
      },
      {
        "text": "System.out.println(tab);",
        "inline_explanation": "(Wypisze tylko adres/hashcode tablicy)",
        "correct": false
      }
    ],
    "explanation": "Pętla 'for-each' (`for (int i: tab)`) iteruje po wartościach, więc `i` to kolejny element tablicy. W opcji pierwszej błędnie użyto tej wartości jako indeksu (`tab[i]`)."
  },
  {
    "id": 73,
    "question": "Które zdanie opisujące własności klas w języku Java jest prawdziwe?",
    "options": [
      {
        "text": "aby zaznaczyć, że klasa dziedziczy po kilku klasach, należy podać ich listę po słowie kluczowym extends",
        "inline_explanation": "(Java nie wspiera wielodziedziczenia klas)",
        "correct": false
      },
      {
        "text": "dla każdej klasy w języku Java możliwe jest zdefiniowanie klasy potomnej",
        "inline_explanation": "(Nie dla klas oznaczonych jako final)",
        "correct": false
      },
      {
        "text": "klasa może implementować wiele interfejsów",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "w języku Java zawsze bezpośrednio możemy dziedziczyć po (maksymalnie) jednej klasie",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Java stosuje model pojedynczego dziedziczenia klas (`extends`), ale pozwala na implementację dowolnej liczby interfejsów (`implements`), co pozwala ominąć niektóre ograniczenia tego modelu."
  },
  {
    "id": 74,
    "question": "W jaki sposób usuwane są obiekty w języku Java?",
    "options": [
      {
        "text": "usuwa się je przez przekazanie referencji do usuwanego obiektu do metody System.gc()",
        "inline_explanation": "(Metoda ta nie przyjmuje argumentów i jest tylko sugestią)",
        "correct": false
      },
      {
        "text": "nie są programowo usuwane, to środowisko wykonawcze podejmuje decyzje czy i kiedy je usunąć",
        "inline_explanation": "(Garbage Collection)",
        "correct": true
      },
      {
        "text": "za pomocą operatora delete",
        "inline_explanation": "(To C++, w Javie nie ma delete)",
        "correct": false
      },
      {
        "text": "automatycznie po wyjściu z bloku kodu",
        "inline_explanation": "(Tylko referencje znikają, obiekt na stercie może żyć dłużej)",
        "correct": false
      }
    ],
    "explanation": "W Javie zarządzanie pamięcią jest automatyczne. Garbage Collector (GC) działający w tle sam wykrywa obiekty, do których nie prowadzą żadne aktywne referencje, i zwalnia zajmowaną przez nie pamięć."
  },
  {
    "id": 75,
    "question": "Które z poniższych stwierdzeń odnoszące się do klas wewnętrznych i zagnieżdżonych w języku Java są prawdziwe?",
    "options": [
      {
        "text": "w metodach klasy zagnieżdżonej (zadeklarowanej z modyfikatorem static) jest dostępna referencja Outer.this",
        "inline_explanation": "(Klasa statyczna nie ma dostępu do instancji klasy zewnętrznej)",
        "correct": false
      },
      {
        "text": "obiekt klasy wewnętrznej ma swój stan niezależny od innych obiektów powiązanych z obiektem klasy zewnętrznej",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "klasa wewnętrzna (zadeklarowana bez modyfikatora static) nie ma dostępu do prywatnych zmiennych klasy zewnętrznej",
        "inline_explanation": "(Ma pełny dostęp)",
        "correct": false
      },
      {
        "text": "klasy wewnętrzne muszą dziedziczyć po otaczających je klasach zewnętrznych",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Klasa wewnętrzna (niestatyczna) jest związana z instancją klasy zewnętrznej i ma dostęp do jej pól (nawet prywatnych). Statyczna klasa zagnieżdżona zachowuje się jak zwykła klasa, tyle że zdefiniowana wewnątrz innej (nie ma niejawnego powiązania z instancją 'Outer')."
  },
  {
    "id": 76,
    "question": "Jaki typ w Haskellu będzie miało następujące wyrażenie: `r x = x:r x` ?",
    "options": [
      {
        "text": "r :: [a]",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "r :: a -> [a]",
        "inline_explanation": "(Funkcja bierze element 'a' i tworzy nieskończoną listę [a])",
        "correct": true
      },
      {
        "text": "r :: Integer -> [Integer]",
        "inline_explanation": "(Zbyt wąski typ, działa dla dowolnego 'a')",
        "correct": false
      },
      {
        "text": "r :: a -> a",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Operator dwukropka `:` w Haskellu służy do konstruowania listy (dodaje element na początek). Funkcja `r` bierze argument `x` i zwraca listę, której głową jest `x`, a ogonem wynik rekurencyjnego wywołania `r x`. Tworzy to nieskończoną listę samych elementów `x`."
  },
  {
    "id": 77,
    "question": "Jak wygląda poprawna wartość w Haskellu dla typu: `data Tree a = L a | N (Tree a) a (Tree a)`",
    "options": [
      {
        "text": "Tree 5 Nil Nil",
        "inline_explanation": "(Tree to nazwa typu, nie konstruktora)",
        "correct": false
      },
      {
        "text": "N (L 4) 5 (L 14')",
        "inline_explanation": "(Błąd typów: 4 to liczba, '4' to znak)",
        "correct": false
      },
      {
        "text": "N (L 4) 5 (L 4)",
        "inline_explanation": "(Poprawne: węzeł N ma lewe poddrzewo (liść 4), wartość 5 i prawe poddrzewo (liść 4))",
        "correct": true
      },
      {
        "text": "N (L '4') '5' (L '4')",
        "inline_explanation": "(Poprawne dla typu Tree Char)",
        "correct": true
      }
    ],
    "explanation": "Typ `Tree a` jest typem algebraicznym z dwoma konstruktorami: `L a` (liść z wartością) oraz `N (Tree a) a (Tree a)` (węzeł z lewym poddrzewem, wartością i prawym poddrzewem). Typ `a` musi być spójny w całym wyrażeniu (albo same liczby, albo same znaki)."
  },
  {
    "id": 78,
    "question": "Haskell jest językiem opartym o paradygmat:",
    "options": [
      {
        "text": "funkcyjny",
        "inline_explanation": "(Czysto funkcyjny - purely functional)",
        "correct": true
      },
      {
        "text": "strukturalny",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "imperatywny",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "obiektowy",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Haskell to najpopularniejszy przedstawiciel języków czysto funkcyjnych, opartych na rachunku lambda, z leniwym wartościowaniem i silnym, statycznym typowaniem."
  },
  {
    "id": 79,
    "question": "Zaznacz prawdziwe zdania odnoszące się do programowania funkcyjnego:",
    "options": [
      {
        "text": "w programowaniu funkcyjnym koncepcja funkcji jest taka, jak w algebrze",
        "inline_explanation": "(Funkcja zawsze zwraca ten sam wynik dla tych samych argumentów)",
        "correct": true
      },
      {
        "text": "programowanie funkcyjne opiera się na rachunku lambda",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "dobrym nawykiem w programowaniu funkcyjnym jest, aby zmienne były niemutowalne",
        "inline_explanation": "(Immutability to podstawa tego paradygmatu)",
        "correct": true
      },
      {
        "text": "funkcyjny styl programowania można uprawiać w ograniczonym zakresie w językach imperatywnych jak C albo JavaScript",
        "inline_explanation": "(Np. używając wskaźników na funkcje w C lub funkcji wyższego rzędu w JS)",
        "correct": true
      },
      {
        "text": "niektóre języki imperatywne zostały wyposażone w konstrukcje z języków funkcyjnych",
        "inline_explanation": "(Np. wyrażenia lambda w Javie czy C++)",
        "correct": true
      },
      {
        "text": "można używać funkcyjnego stylu programowania w języku JavaScript",
        "inline_explanation": "(JS ma silne wsparcie dla funkcji jako obywateli pierwszej kategorii)",
        "correct": true
      }
    ],
    "explanation": "Programowanie funkcyjne kładzie nacisk na obliczanie wartości funkcji matematycznych, unikanie zmiennych stanów i efektów ubocznych (side effects). Wiele nowoczesnych języków wieloparadygmatowych (Python, JS, C#) adaptuje te koncepcje."
  },
  {
    "id": 80,
    "question": "Funkcje wyższego rzędu w programowaniu funkcyjnym to:",
    "options": [
      {
        "text": "funkcje zwracające inne funkcje jako rezultat obliczeń",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "funkcje, które przyjmują inne funkcje jako parametry",
        "inline_explanation": "(Np. map, filter, reduce)",
        "correct": true
      },
      {
        "text": "funkcje rekurencyjne",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "funkcje operujące na zmiennych globalnych",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Funkcja wyższego rzędu to taka, która traktuje inne funkcje jak dane: może je przyjmować jako argumenty lub je tworzyć i zwracać."
  },
  {
    "id": 81,
    "question": "Jaki mechanizm w językach funkcyjnych pozwala na wykonanie operacji na zbiorze danych?",
    "options": [
      {
        "text": "iteracja",
        "inline_explanation": "(Pętle są typowe dla języków imperatywnych)",
        "correct": false
      },
      {
        "text": "rekurencja",
        "inline_explanation": "(Podstawowy mechanizm powtarzania czynności)",
        "correct": true
      },
      {
        "text": "funkcje specyficzne dla języka",
        "inline_explanation": "(Np. map/fold, które pod spodem używają rekurencji)",
        "correct": true
      },
      {
        "text": "warunkowy skok do etykiety",
        "inline_explanation": "(GOTO)",
        "correct": false
      }
    ],
    "explanation": "W czystym programowaniu funkcyjnym nie ma pętli (for/while) opartych na zmianie stanu licznika. Zamiast tego używa się rekurencji (często optymalizowanej jako rekurencja ogonowa) lub funkcji wyższego rzędu operujących na kolekcjach (map, fold, filter)."
  },
  {
    "id": 82,
    "question": "Wskaż, w których przypadkach klauzule instrukcji select są ułożone we właściwej kolejności:",
    "options": [
      {
        "text": "from, group by, where, having, order by",
        "inline_explanation": "(Błąd: WHERE musi być przed GROUP BY)",
        "correct": false
      },
      {
        "text": "from, where, group by, having, order by",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "from, group by, having, where, order by",
        "inline_explanation": "(Błąd: WHERE musi być przed GROUP BY)",
        "correct": false
      }
    ],
    "explanation": "Prawidłowa kolejność logiczna i składniowa w SQL to: SELECT -> FROM -> JOIN/ON -> WHERE -> GROUP BY -> HAVING -> ORDER BY. Klauzula WHERE filtruje wiersze przed grupowaniem, a HAVING filtruje grupy po zgrupowaniu."
  },
  {
    "id": 83,
    "question": "Dana jest relacja R o schemacie `H={A,B,C,D,E}` oraz zbiór zależności funkcyjnych `F={{B,C}->{D,E}, {C, D} -> {B, E}, {D} -> {C}, {E} -> {B}}`. W jakiej maksymalnie postaci normalnej jest relacja R? Zakładamy, że jest w 1NF.",
    "options": [
      {
        "text": "1NF",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "2NF",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "3NF",
        "inline_explanation": "(Wszystkie atrybuty należą do jakiegoś klucza kandydującego)",
        "correct": true
      },
      {
        "text": "BCNF",
        "inline_explanation": "(Niespełniona, bo lewa strona {B,C}->{D,E} nie jest superkluczem - brakuje A)",
        "correct": false
      },
      {
        "text": "4NF",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Klucze kandydujące to {A, B, C}, {A, D} oraz {A, C, E}. Ponieważ każdy atrybut relacji należy do któregoś z kluczy (jest atrybutem pierwotnym), relacja automatycznie spełnia warunki 3NF. Nie spełnia BCNF, ponieważ istnieją zależności (np. {D}->{C}), gdzie lewa strona nie jest nadkluczem (nie zawiera A)."
  },
  {
    "id": 84,
    "question": "Wskaż wszystkie prawdziwe stwierdzenia dotyczące trzeciej postaci normalnej:",
    "options": [
      {
        "text": "jeżeli wszystkie atrybuty ze schematu relacji są atrybutami kluczowymi, to relacja jest w 3NF",
        "inline_explanation": "(Tylko atrybuty niekluczowe mogą łamać 3NF)",
        "correct": true
      },
      {
        "text": "dowolną relację można sprowadzić do 3NF stosując dekompozycję bezstratną i zachowującą zależności funkcyjne",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "3NF oznacza, że każdy atrybut niekluczowy (informacyjny) zależy wyłącznie od klucza",
        "inline_explanation": "(Brak zależności przechodnich)",
        "correct": true
      },
      {
        "text": "BCNF jest nieco bardziej restrykcyjną wersją 3NF - w BCNF wszystkie atrybuty (również kluczowe) muszą spełniać warunek zależności wyłącznie od klucza",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "jeżeli relacja jest w BCNF, to jest również w 3NF",
        "inline_explanation": "(BCNF implikuje 3NF)",
        "correct": true
      },
      {
        "text": "jeżeli relacja jest w 3NF, to możliwe jest występowanie pewnych redundancji",
        "inline_explanation": "(Dlatego wprowadzono BCNF)",
        "correct": true
      }
    ],
    "explanation": "3NF wymaga, aby relacja była w 2NF i żaden atrybut niekluczowy nie zależał przechodnio od klucza głównego (czyli zależał 'bezpośrednio' od klucza, całego klucza i tylko od klucza)."
  },
  {
    "id": 85,
    "question": "Wskaż wszystkie prawdziwe stwierdzenia dotyczące postaci normalnej Boyce'a-Codda:",
    "options": [
      {
        "text": "dowolną relację można sprowadzić do BCNF stosując dekompozycję bezstratną, ale niekoniecznie zachowującą zależności funkcyjne",
        "inline_explanation": "(Czasem tracimy zależności przy BCNF)",
        "correct": true
      },
      {
        "text": "dowolna relacja dwuatrybutowa jest w BCNF",
        "inline_explanation": "(Nie ma miejsca na łamanie reguł)",
        "correct": true
      },
      {
        "text": "jeżeli schemat relacji znajduje się w postaci normalnej Boyce'a-Codda, to nie ma w nim redundancji (wynikającej z zależności funkcyjnych)",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "BCNF oznacza, że lewa strona każdej nietrywialnej zależności funkcyjnej zawiera klucz",
        "inline_explanation": "(Lewa strona musi być superkluczem)",
        "correct": true
      },
      {
        "text": "atrybut z prawej strony zależności może być podstawowy",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "schematy relacji zawsze należy doprowadzać do postaci BCNF",
        "inline_explanation": "(Nie zawsze, czasem koszt utraty zależności jest zbyt duży)",
        "correct": false
      }
    ],
    "explanation": "BCNF to wzmocniona 3NF. Wymaga, aby dla każdej zależności funkcyjnej X->Y, X było superkluczem. Eliminuje to anomalie, które mogą pozostać w 3NF, gdy klucze kandydujące na siebie zachodzą."
  },
  {
    "id": 86,
    "question": "Wskaż wszystkie prawdziwe stwierdzenia dotyczące kluczy obcych w relacyjnym modelu danych:",
    "options": [
      {
        "text": "wartości klucza obcego muszą być unikatowe",
        "inline_explanation": "(Nie muszą, to relacja 1:N)",
        "correct": false
      },
      {
        "text": "klucze obce są sposobem łączenia przechowywanych danych w różnych tabelach",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "klucz obcy jest kolumną lub grupą kolumn, która czerpie swoje wartości z tej samej dziedziny, co klucz główny powiązanej z nią tabeli",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "klucz obcy musi odnosić się do istniejącej krotki lub przyjmować wartość NULL",
        "inline_explanation": "(Integralność referencyjna)",
        "correct": true
      },
      {
        "text": "klucz obcy nie musi być unikatowy w obrębie tabeli",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "klucz obcy może pochodzić z tej samej tabeli",
        "inline_explanation": "(Związek rekurencyjny, np. pracownik-szef)",
        "correct": true
      },
      {
        "text": "klucz obcy i klucz do którego się on odwołuje muszą mieć tyle samo atrybutów",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "powinny wskazywać na klucz główny (lub unikalny) w tabeli głównej",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Klucz obcy (Foreign Key) służy do wymuszania integralności referencyjnej między tabelami. Gwarantuje, że wartość w kolumnie podrzędnej odpowiada istniejącemu wierszowi w tabeli nadrzędnej (lub jest NULL)."
  },
  {
    "id": 87,
    "question": "Wskaż wszystkie prawdziwe stwierdzenia dotyczące transakcji:",
    "options": [
      {
        "text": "wykonanie instrukcji ROLLBACK powoduje anulowanie transakcji i wycofanie wprowadzonych zmian",
        "inline_explanation": "(Standardowe polecenie SQL)",
        "correct": true
      },
      {
        "text": "transakcja jest ciągiem operacji w bazie danych, które należy wykonać wszystkie lub nie wykonywać żadnej z nich",
        "inline_explanation": "(Własność Atomicity - Atomowość)",
        "correct": true
      },
      {
        "text": "równolegle wykonywane transakcje mają ten sam poziom izolacji",
        "inline_explanation": "(Zazwyczaj definiowany per sesja)",
        "correct": true
      },
      {
        "text": "dane zmodyfikowane przez transakcję, która nie została jeszcze zakończona, nigdy nie są dostępne dla innych równolegle realizowanych transakcji",
        "inline_explanation": "(Własność Isolation - Izolacja, chroni przed dirty read)",
        "correct": true
      }
    ],
  "explanation": "Transakcje w bazach danych muszą spełniać zasady ACID: Atomicity (niepodzielność), Consistency (spójność), Isolation (izolacja), Durability (trwałość)."
  },
  {
    "id": 88,
    "question": "Wskaż, które ograniczenia można definiować na poziomie kolumny (w instrukcji `create table`):",
    "options": [
      {
        "text": "wartość domyślna atrybutu",
        "inline_explanation": "(DEFAULT)",
        "correct": true
      },
      {
        "text": "krótsze ścieżki na płycie głównej",
        "inline_explanation": "(To kwestia sprzętowa)",
        "correct": false
      },
      {
        "text": "większy bufor",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "unikalne wartości atrybutu",
        "inline_explanation": "(UNIQUE)",
        "correct": true
      },
      {
        "text": "proste klucze główne",
        "inline_explanation": "(PRIMARY KEY)",
        "correct": true
      },
      {
        "text": "NULL/NOT NULL",
        "inline_explanation": "(Wymagalność wartości)",
        "correct": true
      },
      {
        "text": "wyzwalacze typu 'zdarzenie, warunek, akcja'",
        "inline_explanation": "(Triggery to osobne obiekty bazy danych)",
        "correct": false
      }
    ],
  "explanation": "Standardowe ograniczenia (constraints) w SQL to: NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK oraz DEFAULT."
  },
  {
    "id": 89,
    "question": "Wskaż wszystkie prawdziwe stwierdzenia dotyczące wartości `NULL`:",
    "options": [
      {
        "text": "w modelu relacyjnym wartość NULL jest traktowana jako trzecia, różna od false i true, wartość logiczna",
        "inline_explanation": "(Logika trójwartościowa: True, False, Unknown)",
        "correct": true
      },
      {
        "text": "dwie wartości NULL są traktowane jako równe",
        "inline_explanation": "(NULL != NULL, wynik porównania to Unknown)",
        "correct": false
      },
      {
        "text": "wartości NULL są różne od spacji, zera czy też pustego łańcucha znaków",
        "inline_explanation": "(NULL oznacza brak wartości, zero to konkretna wartość)",
        "correct": true
      },
      {
        "text": "jeżeli wystąpi w wartości atrybutu NULL, to suma po tym atrybucie też jest NULL",
        "inline_explanation": "(Każda operacja arytmetyczna z NULL daje NULL)",
        "correct": true
      },
      {
        "text": "wartość NULL oznacza zero",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Wartość NULL reprezentuje brak danych lub wartość nieznaną. Nie jest równoważna zeru ani pustemu stringowi. W logice SQL wprowadza stan 'nieznany' (Unknown), co wymaga stosowania operatorów `IS NULL` zamiast `==`."
  },
  {
    "id": 90,
    "question": "Które wyrażenie SQL zwraca wszystkie wiersze tabeli 'Osoby' posortowane malejąco według atrybutu 'Imie'?",
    "options": [
      {
        "text": "SELECT * FROM Osoby SORT BY 'Imie' DESC",
        "inline_explanation": "(Nie ma słowa kluczowego SORT BY)",
        "correct": false
      },
      {
        "text": "SELECT * FROM Osoby ORDER BY Imie DESC",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "SELECT * FROM Osoby SORT 'Imie' DESC",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "SELECT * FROM Osoby ORDER Imie DESC",
        "inline_explanation": "(Brakuje słowa BY)",
        "correct": false
      }
    ],
  "explanation": "Poprawna składnia sortowania w SQL to klauzula `ORDER BY`. Kierunek malejący określa słowo `DESC` (descending)."
  },
  {
    "id": 91,
    "question": "Jak możesz zmienić wartość 'Kowalski' na 'Nowak' w atrybucie 'Nazwisko' w tabeli 'Osoby'?",
    "options": [
      {
        "text": "MODIFY Osoby SET Nazwisko ='Nowak' WHERE Nazwisko ='Kowalski'",
        "inline_explanation": "(MODIFY służy zazwyczaj do zmiany struktury tabeli)",
        "correct": false
      },
      {
        "text": "UPDATE Osoby SET Nazwisko ='Kowalski' INTO Nazwisko ='Nowak'",
        "inline_explanation": "(Błędna składnia)",
        "correct": false
      },
      {
        "text": "UPDATE Osoby SET Nazwisko ='Nowak' WHERE Nazwisko ='Kowalski'",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "CHANGE Osoby Nazwisko 'Nowak' WHERE 'Kowalski'",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Instrukcja `UPDATE` służy do modyfikacji danych w istniejących rekordach. Składnia to: `UPDATE tabela SET kolumna = nowa_wartość WHERE warunek`."
  },
  {
    "id": 92,
    "question": "Jak można przy pomocy SQL uzyskać informację o liczbie wierszy w tabeli 'Osoby'?",
    "options": [
      {
        "text": "SELECT COUNT(*) FROM Osoby",
        "inline_explanation": "(Standardowa funkcja agregująca zliczająca wiersze)",
        "correct": true
      },
      {
        "text": "SELECT COUNT() FROM Osoby",
        "inline_explanation": "(Błąd składni, funkcja wymaga argumentu)",
        "correct": false
      },
      {
        "text": "SELECT COLUMNS() FROM Osoby",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "SELECT COLUMNS(*) FROM Osoby",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Funkcja `COUNT(*)` zlicza wszystkie wiersze w tabeli, włącznie z tymi zawierającymi wartości NULL. Można też użyć `COUNT(kolumna)`, co zliczy wiersze z wartościami niepustymi w danej kolumnie."
  },
  {
    "id": 93,
    "question": "Jak można przy pomocy SQL wybrać wszystkie wiersze z tabeli 'Osoby', w których wartość atrybutu 'Imie' zaczyna się od 'a'?",
    "options": [
      {
        "text": "SELECT * FROM Osoby WHERE Imie LIKE '%a'",
        "inline_explanation": "(To oznacza 'kończy się na a')",
        "correct": false
      },
      {
        "text": "SELECT * FROM Osoby WHERE Imie ='%a%'",
        "inline_explanation": "(To szuka dosłownego ciągu znaków '%a%')",
        "correct": false
      },
      {
        "text": "SELECT * FROM Osoby WHERE Imie LIKE 'a%'",
        "inline_explanation": "(Znak % zastępuje dowolny ciąg znaków po literze 'a')",
        "correct": true
      },
      {
        "text": "SELECT * FROM Osoby WHERE Imie = 'a'",
        "inline_explanation": "(To szuka imienia równego 'a')",
        "correct": false
      }
    ],
    "explanation": "Operator `LIKE` używa wieloznaczników: `%` (dowolny ciąg znaków) i `_` (pojedynczy znak). Wzorzec `'a%'` oznacza: pierwsza litera to 'a', a potem cokolwiek."
  },
  {
    "id": 94,
    "question": "Którą z poniższych cech musi posiadać klucz właściwy?",
    "options": [
      {
        "text": "jego wartość jednoznacznie wyznacza wiersz w danej tabeli",
        "inline_explanation": "(Unikalność)",
        "correct": true
      },
      {
        "text": "jest automatycznie generowany przez System Zarządzania Bazą Danych",
        "inline_explanation": "(Może, ale nie musi)",
        "correct": false
      },
      {
        "text": "nie może być generowany przez SZBD",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "jego wartość składa się tylko z jednego atrybutu",
        "inline_explanation": "(Może być złożony)",
        "correct": false
      },
      {
        "text": "nie może być pomniejszony o żaden atrybut",
        "inline_explanation": "(Minimalność - usunięcie atrybutu powoduje utratę unikalności)",
        "correct": true
      },
      {
        "text": "żaden podzbiór jego atrybutów nie może być kluczem",
        "inline_explanation": "(To inna definicja minimalności)",
        "correct": true
      }
    ],
    "explanation": "Klucz właściwy (candidate key) to minimalny nadklucz. Musi być unikalny (identyfikować krotkę) i minimalny (nie zawierać zbędnych atrybutów)."
  },
  {
    "id": 95,
    "question": "Algebra relacji jest podstawą dla:",
    "options": [
      {
        "text": "realizacji przez relacyjny SZBD operacji języka manipulacji danymi",
        "inline_explanation": "(SQL jest oparty na algebrze relacji)",
        "correct": true
      },
      {
        "text": "budowy diagramów ERD",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "budowy diagramów DFD",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "algorytmicznych języków relacyjnych baz danych",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Algebra relacji to teoretyczny język zapytań, składający się z operatorów (selekcja, rzutowanie, złączenie itd.), który stanowi fundament działania baz relacyjnych i optymalizacji zapytań SQL."
  },
  {
    "id": 96,
    "question": "Które z poniższych cech posiadają widoki ('view')?",
    "options": [
      {
        "text": "mogą realizować politykę ograniczania dostępu do danych",
        "inline_explanation": "(Np. udostępniając tylko wybrane kolumny)",
        "correct": true
      },
      {
        "text": "ułatwiają konstrukcję zapytań SQL do bazy danych",
        "inline_explanation": "(Ukrywają skomplikowane złączenia)",
        "correct": true
      },
      {
        "text": "zabezpieczają dane przed ich utratą w trakcie realizacji złożonych transakcji",
        "inline_explanation": "(Nie, to rola logów i backupów)",
        "correct": false
      },
      {
        "text": "powodują problemy z konstrukcją zapytań SQL do bazy danych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "dostarczają prostego mechanizmu uaktualniania danych",
        "inline_explanation": "(Widoki często są tylko do odczytu, zwłaszcza te ze złączeniami)",
        "correct": false
      }
    ],
    "explanation": "Widok to 'wirtualna tabela' będąca zapisanym zapytaniem SQL. Pozwala uprościć dostęp do danych (użytkownik widzi prostą tabelę zamiast 5 złączeń) oraz zwiększyć bezpieczeństwo (ukrywając wrażliwe kolumny)."
  },
  {
    "id": 97,
    "question": "Z jakim problemem trzeba się uporać przy odwzorowaniu w schemacie relacyjnej bazy danych relacji typu n:m (wiele do wiele)?",
    "options": [
      {
        "text": "zdefiniować podwójne indeksowanie plików odpowiadających każdej z tabel",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "trzeba zaprojektować dodatkową tabelę",
        "inline_explanation": "(Tzw. tabela łącznikowa / asocjacyjna)",
        "correct": true
      },
      {
        "text": "dobrać odpowiedni klucz obcy w drugiej z tabel",
        "inline_explanation": "(To zadziała tylko dla relacji 1:n)",
        "correct": false
      },
      {
        "text": "trzeba użyć dodatkowo widoku (view)",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Relacyjne bazy danych nie obsługują bezpośrednio relacji wiele-do-wielu. Aby ją zrealizować, tworzy się trzecią tabelę (łącznikową), która zawiera klucze obce do obu łączonych tabel, rozbijając relację n:m na dwie relacje 1:n."
  },
  {
    "id": 98,
    "question": "Które z poniższych stwierdzeń są prawdziwe, jeśli dotyczą systemów baz danych realizowanych w architekturze klient-serwer?",
    "options": [
      {
        "text": "mocno obciążają sieć w stosunku do systemów scentralizowanych",
        "inline_explanation": "(Obciążenie jest zoptymalizowane, przesyłane są tylko wyniki zapytań)",
        "correct": false
      },
      {
        "text": "pozwalają klientom pracować w różnych systemach operacyjnych",
        "inline_explanation": "(Komunikacja odbywa się przez standardowy protokół sieciowy)",
        "correct": true
      },
      {
        "text": "uniezależniają sposób realizacji aplikacji od serwera",
        "inline_explanation": "(Logika prezentacji jest po stronie klienta, dane po stronie serwera)",
        "correct": true
      },
      {
        "text": "wymagają co najmniej dwóch komputerów",
        "inline_explanation": "(Klient i serwer mogą działać na jednej maszynie)",
        "correct": false
      }
    ],
    "explanation": "Architektura klient-serwer rozdziela warstwę danych (DBMS na serwerze) od warstwy prezentacji/aplikacji (klient). Pozwala to na elastyczność (różne OS u klientów) i skalowalność."
  },
  {
    "id": 99,
    "question": "Systemy OLTP i OLAP różnią się przede wszystkim:",
    "options": [
      {
        "text": "czasem reakcji na zapytanie",
        "inline_explanation": "(OLTP: milisekundy vs OLAP: sekundy/minuty)",
        "correct": true
      },
      {
        "text": "stopniem szczegółowości przechowywanych danych",
        "inline_explanation": "(OLTP: szczegółowe vs OLAP: zagregowane)",
        "correct": true
      },
      {
        "text": "zakresem realizowanych funkcji użytkowych",
        "inline_explanation": "(Bieżąca obsługa vs analityka/planowanie)",
        "correct": true
      },
      {
        "text": "językiem zapytań",
        "inline_explanation": "(Oba zazwyczaj używają SQL)",
        "correct": false
      }
    ],
    "explanation": "OLTP służy do bieżącej obsługi operacji biznesowych (szybkie, proste transakcje). OLAP służy do analizy, raportowania i wspomagania decyzji (złożone zapytania na dużej ilości danych historycznych)."
  },
  {
    "id": 100,
    "question": "Rolą hurtowni danych jest:",
    "options": [
      {
        "text": "przygotowanie danych do szybkiej analizy",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "kontrola poprawności danych realizowana podczas wykonywania transakcji",
        "inline_explanation": "(To rola systemów transakcyjnych OLTP)",
        "correct": false
      },
      {
        "text": "minimalizacja plików fizycznych przez ujednolicenie sposobu przechowywania danych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "przechowywanie danych w sposób scentralizowany",
        "inline_explanation": "(Integracja danych z wielu źródeł)",
        "correct": true
      },
      {
        "text": "wydajne odpowiadanie na zapytania o charakterze analitycznym",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Hurtownia danych (Data Warehouse) to centralne repozytorium zintegrowanych danych z różnych źródeł. Jest zoptymalizowana pod kątem wydajnego odczytu i analizy (OLAP), a nie pod kątem szybkiego zapisu transakcji."
  },
  {
    "id": 101,
    "question": "Modele danych w postaci gwiazdy i płatka śniegu:",
    "options": [
      {
        "text": "ich implementacja przyspiesza analizę danych",
        "inline_explanation": "(Są zoptymalizowane pod zapytania analityczne)",
        "correct": true
      },
      {
        "text": "pozwalają oddać sens złożonej struktury danych",
        "inline_explanation": "(Szczególnie model płatka śniegu, który normalizuje wymiary)",
        "correct": true
      },
      {
        "text": "zapewniają brak redundancji danych",
        "inline_explanation": "(Model gwiazdy jest celowo zdenormalizowany i zawiera redundancję)",
        "correct": false
      },
      {
        "text": "służą głównie do obsługi bieżących transakcji sprzedażowych",
        "inline_explanation": "(Nie, służą do analizy w hurtowniach danych)",
        "correct": false
      }
    ],
    "explanation": "Są to schematy używane w hurtowniach danych. Schemat gwiazdy składa się z tabeli faktów i tabel wymiarów (prostszy, szybszy). Schemat płatka śniegu normalizuje tabele wymiarów (bardziej złożony, mniej redundancji)."
  },
  {
    "id": 102,
    "question": "System operacyjny jest:",
    "options": [
      {
        "text": "zbiorem składników sprzętowych (hardware routines)",
        "inline_explanation": "(To byłby sprzęt/firmware)",
        "correct": false
      },
      {
        "text": "zbiorem driverów obsługujących urządzenia wejścia-wyjścia",
        "inline_explanation": "(To tylko część systemu)",
        "correct": false
      },
      {
        "text": "zbiorem składników programowych (software routines)",
        "inline_explanation": "(Zarządza zasobami i dostarcza interfejs)",
        "correct": true
      },
      {
        "text": "fizycznym elementem płyty głównej",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "System operacyjny to oprogramowanie (software), które pełni rolę zarządcy zasobów (procesor, pamięć, urządzenia I/O) oraz dostarcza maszynę wirtualną/rozszerzoną, ukrywając złożoność sprzętu przed użytkownikiem."
  },
  {
    "id": 103,
    "question": "Proces transferowania danych, które mają być docelowo wyprowadzone na urządzenie peryferyjne, do przestrzeni pamięci pomocniczej i transferowanie ich na to urządzenie w dogodniejszym czasie nosi nazwę:",
    "options": [
      {
        "text": "spooling",
        "inline_explanation": "(Simultaneous Peripheral Operations On-Line)",
        "correct": true
      },
      {
        "text": "virtualization",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "caching",
        "inline_explanation": "(Caching przechowuje dane często używane, spooling to buforowanie zadań)",
        "correct": false
      },
      {
        "text": "throttling",
        "inline_explanation": "(Dławienie wydajności)",
        "correct": false
      }
    ],
    "explanation": "Spooling (np. przy drukowaniu) polega na zrzuceniu danych do bufora na dysku, dzięki czemu procesor nie musi czekać na wolne urządzenie peryferyjne i może zająć się innym zadaniem."
  },
  {
    "id": 104,
    "question": "Centralny Procesor, po otrzymaniu informacji o przerwaniu z urządzenia wejścia/wyjścia:",
    "options": [
      {
        "text": "zatrzymuje się na określony okres czasu",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "przekazuje sterowanie do systemu obsługi przerwań po zakończeniu wykonywania bieżącej instrukcji",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "natychmiast przerywa wykonywanie bieżącej instrukcji w połowie jej cyklu",
        "inline_explanation": "(Musi dokończyć instrukcję, by zachować spójność stanu)",
        "correct": false
      },
      {
        "text": "ignoruje przerwanie, jeśli pochodzi z urządzenia zewnętrznego",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Obsługa przerwania (Interrupt Service Routine) następuje po zakończeniu cyklu bieżącej instrukcji. Procesor zapisuje stan, odczytuje wektor przerwań i skacze do odpowiedniej procedury obsługi."
  },
  {
    "id": 105,
    "question": "Buforowanie plików realizowane jest w celu:",
    "options": [
      {
        "text": "zwiększenia wydajności dostępu do pamięci pomocniczej",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "wspomagania obsługi przerwań",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "zwiększenia wydajności procesora",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "wyrównania różnic prędkości przesyłania danych między różnymi urządzeniami",
        "inline_explanation": "(Np. między szybkim RAM a wolnym dyskiem)",
        "correct": true
      }
    ],
    "explanation": "Buforowanie pozwala gromadzić dane w szybkiej pamięci, aby niwelować różnice prędkości między nadawcą a odbiorcą (np. CPU a dyskiem), co pozwala na płynniejszą pracę systemu."
  },
  {
    "id": 106,
    "question": "Zaznacz prawdziwe stwierdzenia na temat stronicowania:",
    "options": [
      {
        "text": "stronicowanie rozwiązuje problem zewnętrznej fragmentacji pamięci",
        "inline_explanation": "(Przydzielamy dowolne wolne ramki, nie muszą być ciągłe)",
        "correct": true
      },
      {
        "text": "tablica stron jest stosowana do translacji adresu logicznego na adres fizyczny",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "podczas stronicowania przyjmuje się, że pamięć fizyczna jest podzielona na strony, a pamięć logiczna na ramki",
        "inline_explanation": "(Odwrotnie: fizyczna na ramki, logiczna na strony)",
        "correct": false
      },
      {
        "text": "stronicowanie rozwiązuje problem wewnętrznej fragmentacji pamięci",
        "inline_explanation": "(Wprowadza ją - ostatnia strona rzadko jest pełna)",
        "correct": false
      },
      {
        "text": "podczas stronicowania przyjmuje się, że pamięć fizyczna jest podzielona na ramki, a pamięć logiczna na strony, i że rozmiary stron i ramek są jednakowe",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Stronicowanie dzieli pamięć na stałe bloki. Pamięć fizyczna to ramki (frames), logiczna to strony (pages). Dzięki temu proces nie musi zajmować ciągłego obszaru pamięci fizycznej (brak fragmentacji zewnętrznej), ale pojawia się fragmentacja wewnętrzna (nepełna ostatnia strona)."
  },
  {
    "id": 107,
    "question": "Zaznacz prawdziwe stwierdzenia na temat segmentacji:",
    "options": [
      {
        "text": "segmentacja ułatwia nadanie częściom procesu odpowiednich atrybutów ochrony (odczyt, zapis, wykonanie)",
        "inline_explanation": "(Segmenty odpowiadają logicznym częściom programu, np. kod jest read-only)",
        "correct": true
      },
      {
        "text": "zastosowanie segmentacji wyklucza użycie stronicowania",
        "inline_explanation": "(Można stosować segmentację ze stronicowaniem)",
        "correct": false
      },
      {
        "text": "mogą istnieć następujące przykładowe rodzaje segmentów: kodu, danych, stosu",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "elementy tablicy segmentów zawierają adresy/numery ramek oraz rozmiary poszczególnych segmentów",
        "inline_explanation": "(Tablica segmentów zawiera adres bazowy i limit/rozmiar, a nie numery ramek)",
        "correct": false
      }
    ],
    "explanation": "Segmentacja dzieli pamięć na logiczne jednostki (segmenty) o różnej wielkości, co odpowiada widokowi programu przez programistę (funkcje, stos, zmienne). Ułatwia to ochronę pamięci (np. segment kodu tylko do odczytu)."
  },
  {
    "id": 108,
    "question": "Zaznacz prawdziwe stwierdzenia na temat algorytmów wywłaszczania stron:",
    "options": [
      {
        "text": "zaletą algorytmu FIFO jest to, że nie zachodzi w nim efekt zwany anomalią Belady'ego",
        "inline_explanation": "(Fałsz: anomalia Belady'ego dotyczy właśnie FIFO)",
        "correct": false
      },
      {
        "text": "w algorytmie LRU zastępowana jest strona, która najdłużej nie była używana",
        "inline_explanation": "(Least Recently Used)",
        "correct": true
      },
      {
        "text": "w algorytmie drugiej szansy wykorzystuje się bit odniesienia, który określa, czy w pewnym przedziale czasu nastąpiło odwołanie do strony",
        "inline_explanation": "(Przybliżenie LRU)",
        "correct": true
      },
      {
        "text": "zasadą działania algorytmu optymalnego jest to, że zastąpiona zostaje strona, która najdłużej nie będzie używana",
        "inline_explanation": "(Wymaga znajomości przyszłości)",
        "correct": true
      },
      {
        "text": "w algorytmie LRU zachodzi efekt zwany anomalią Belady'ego",
        "inline_explanation": "(LRU jest algorytmem stosowym, więc jest wolne od tej anomalii)",
        "correct": false
      },
      {
        "text": "optymalny algorytm wywłaszczania stron zapewnia minimalną ilość wywłaszczeń stron przy ustalonej liczbie ramek",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Anomalia Belady'ego to zjawisko, w którym zwiększenie liczby ramek pamięci powoduje zwiększenie liczby błędów strony. Występuje w FIFO, ale nie w LRU czy algorytmie optymalnym."
  },
  {
    "id": 109,
    "question": "Zaznacz prawdziwe stwierdzenia dotyczące pamięci wirtualnej:",
    "options": [
      {
        "text": "stronicowanie na żądanie jest jednym ze sposobów realizacji pamięci wirtualnej",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "procedura leniwej wymiany (lazy swapper) polega na tym, że nie wykonuje się wymiany stron w pamięci, jeśli nie zachodzi taka potrzeba",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "pamięć wirtualna umożliwia wykonywanie procesów, które nie są w całości przechowywane w pamięci operacyjnej",
        "inline_explanation": "(Wykorzystuje dysk/swap)",
        "correct": true
      },
      {
        "text": "przydział ramek oparty na globalnym algorytmie zastępowania może ograniczyć szamotanie (thrashing)",
        "inline_explanation": "(Odwrotnie: lokalny algorytm izoluje procesy i ogranicza wpływ szamotania jednego na inne)",
        "correct": false
      }
    ],
    "explanation": "Pamięć wirtualna tworzy abstrakcję dużej, ciągłej pamięci dla procesów, fizycznie mapując ją na mniejszą pamięć RAM i pamięć masową (dysk). Strony są ładowane do RAM tylko wtedy, gdy są potrzebne (on-demand)."
  },
  {
    "id": 110,
    "question": "Który z problemów rozwiązuje zaproponowany przez Dijkstrę algorytm bankiera?",
    "options": [
      {
        "text": "wzajemnego wykluczania (mutual exclusion)",
        "inline_explanation": "(To rozwiązują np. semafory/mutexy)",
        "correct": false
      },
      {
        "text": "wykluczania zakleszczenia (deadlock exclusion)",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "unikania zakleszczenia (deadlock avoidance)",
        "inline_explanation": "(Decyduje, czy przyznanie zasobu jest bezpieczne)",
        "correct": true
      },
      {
        "text": "unikania wykluczania (exclusion avoidance)",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Algorytm bankiera symuluje alokację zasobów. Przed przyznaniem zasobu sprawdza, czy system pozostanie w stanie bezpiecznym (tzn. czy istnieje sekwencja wykonania procesów, która pozwoli wszystkim się zakończyć). Jeśli nie, wstrzymuje żądanie, unikając zakleszczenia."
  },
  {
    "id": 111,
    "question": "Dla uniknięcia błędów uwarunkowanych czasowo (race conditions), maksymalna liczba procesów, które mogą znajdować się wewnątrz sekcji krytycznej, wynosi:",
    "options": [
      {
        "text": "8",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "1",
        "inline_explanation": "(Wzajemne wykluczanie - Mutual Exclusion)",
        "correct": true
      },
      {
        "text": "0",
        "inline_explanation": "(Wtedy żaden proces nie wykonuje pracy)",
        "correct": false
      },
      {
        "text": "16",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Sekcja krytyczna to fragment kodu, w którym procesor korzysta z zasobu współdzielonego. Aby uniknąć niespójności danych, w sekcji krytycznej w danej chwili może przebywać wyłącznie jeden proces."
  },
  {
    "id": 112,
    "question": "Inicjalna wartość semafora uogólnionego implementującego sekcję krytyczną wynosi:",
    "options": [
      {
        "text": "0",
        "inline_explanation": "(Zablokowałoby to pierwszy proces)",
        "correct": false
      },
      {
        "text": "1",
        "inline_explanation": "(Jeden 'żeton' wstępu)",
        "correct": true
      },
      {
        "text": "-1",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "dowolna liczba dodatnia",
        "inline_explanation": "(To pozwoliłoby wejść wielu procesom naraz)",
        "correct": false
      }
    ],
    "explanation": "Aby semafor działał jako mechanizm wzajemnego wykluczania, musi on pozwalać na jednokrotne wykonanie operacji opuszczenia (P) przed zablokowaniem. Dlatego inicjuje się go wartością 1."
  },
  {
    "id": 113,
    "question": "Zaznacz prawdziwe zdania na temat semaforów:",
    "options": [
      {
        "text": "zaletą aktywnego czekania w trybie użytkownika jest brak konieczności kosztownego przejścia do trybu uprzywilejowanego (systemowego)",
        "inline_explanation": "(Wirujące semafory nie usypiają procesu, więc nie wymagają przełączania kontekstu)",
        "correct": false
      },
      {
        "text": "semafor może być użyty do synchronizacji dostępu do sekcji krytycznej",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "aktywne czekanie oznacza ciągłe testowanie wartości wyrażenia do momentu, gdy przyjmie ono wartość, dla której czekanie może być zakończone",
        "inline_explanation": "(Zużywa cykle procesora)",
        "correct": true
      },
      {
        "text": "semafor nie nadaje się do zdeterminowania kolejności wykonywanych operacji w grupie współbieżnych procesów",
        "inline_explanation": "(Nadaje się, np. przez inicjalizację na 0)",
        "correct": false
      },
      {
        "text": "semafor może być użyty do synchronizacji dostępu do sekcji krytycznej, poprzez sygnalizowanie (V) przed wejściem i czekanie (P) po zakończeniu",
        "inline_explanation": "(Odwrotnie: P przed wejściem, V po wyjściu)",
        "correct": false
      }
    ],
    "explanation": "Semafory to klasyczny mechanizm synchronizacji. Aktywne czekanie (spinlock) polega na pętli sprawdzającej warunek ('czy już wolne?'), co nie usypia wątku, ale zużywa procesor. Zwykłe semafory usypiają czekający proces."
  },
  {
    "id": 114,
    "question": "Semafory:",
    "options": [
      {
        "text": "posiadają operacje czekaj (P) i sygnalizuj (V)",
        "inline_explanation": "(Od holenderskich słów Proberen i Verhogen)",
        "correct": true
      },
      {
        "text": "przed wejściem do sekcji krytycznej wykonywana jest operacja sygnalizuj (V)",
        "inline_explanation": "(Przed wejściem wykonuje się P - opuszczenie)",
        "correct": false
      },
      {
        "text": "aktywne czekanie polega na uśpieniu procesu i aktywnym oczekiwaniu na sygnał wybudzający",
        "inline_explanation": "(To definicja blokowania/uśpienia, a nie aktywnego czekania)",
        "correct": false
      },
      {
        "text": "można stworzyć semafor zliczający z 2 semaforów binarnych i zmiennej zliczającej wykorzystującej te semafory",
        "inline_explanation": "",
        "correct": true
      }
    ],
    "explanation": "Operacja P (Wait/Down) zmniejsza wartość semafora i blokuje proces, jeśli wartość spadnie poniżej zera. Operacja V (Signal/Up) zwiększa wartość i ewentualnie odblokowuje czekający proces."
  },
  {
    "id": 115,
    "question": "Rola metod komputerowych w trójkącie 'teoria - eksperyment - symulacja' to:",
    "options": [
      {
        "text": "opracowywanie nowych praw o charakterze podstawowym dla danej dziedziny",
        "inline_explanation": "(To rola teorii)",
        "correct": false
      },
      {
        "text": "realizacja symulacji w oparciu o prawa podstawowe, sugerowanie nowych eksperymentów, sugerowanie teorii",
        "inline_explanation": "",
        "correct": true
      },
      {
        "text": "zastępowanie kosztownych eksperymentów i weryfikowanie teorii",
        "inline_explanation": "(Symulacja nie zastępuje w pełni eksperymentu, a jedynie go uzupełnia)",
        "correct": false
      },
      {
        "text": "realizacja symulacji w oparciu o prawa podstawowe, sterowanie eksperymentami",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Symulacje komputerowe stanowią trzeci filar nauki. Pozwalają badać modele wynikające z praw podstawowych, co pomaga w planowaniu eksperymentów i rozwoju teorii, ale nie tworzą same z siebie nowych praw podstawowych."
  },
  {
    "id": 116,
    "question": "Dokładność reprezentacji zmiennoprzecinkowej jest określona przez:",
    "options": [
      {
        "text": "liczbę bitów mantysy",
        "inline_explanation": "(Im więcej bitów mantysy, tym większa precyzja)",
        "correct": true
      },
      {
        "text": "liczbę bitów mantysy i wykładnika",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "zakres wykładnika",
        "inline_explanation": "(Wykładnik decyduje o zakresie liczb, a nie dokładności)",
        "correct": false
      },
      {
        "text": "liczbę bitów mantysy i zakres wykładnika",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "W standardzie IEEE 754 mantysa przechowuje cyfry znaczące liczby. Wykładnik (cecha) określa rząd wielkości (przesunięcie przecinka). Zatem za precyzję odpowiada wyłącznie długość mantysy."
  },
  {
    "id": 117,
    "question": "Jeśli niewielkie względne zaburzenia danych wejściowych powodują niewielkie względne zmiany wyników, to wówczas:",
    "options": [
      {
        "text": "współczynnik uwarunkowania osiąga wysoką wartość",
        "inline_explanation": "(Wysoka wartość oznacza złe uwarunkowanie)",
        "correct": false
      },
      {
        "text": "współczynnik uwarunkowania osiąga niską wartość",
        "inline_explanation": "(Zadanie dobrze uwarunkowane)",
        "correct": true
      },
      {
        "text": "zadanie jest numerycznie niestabilne",
        "inline_explanation": "(Stabilność dotyczy algorytmu, uwarunkowanie dotyczy zadania)",
        "correct": false
      },
      {
        "text": "nie można stwierdzić nic o uwarunkowaniu",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Współczynnik uwarunkowania (condition number) miary wrażliwość wyniku na błędy w danych wejściowych. Wartość bliska 1 oznacza dobre uwarunkowanie (małe błędy wejścia -> małe błędy wyjścia)."
  },
  {
    "id": 118,
    "question": "Wybierz poprawną odpowiedź:",
    "options": [
      {
        "text": "uwarunkowanie to cecha wynikająca tylko z dokładności operacji zmiennoprzecinkowych",
        "inline_explanation": "(Uwarunkowanie to cecha zadania matematycznego, niezależna od komputera)",
        "correct": false
      },
      {
        "text": "wskaźniki uwarunkowania określają poprawność numeryczną",
        "inline_explanation": "(Poprawność numeryczna to cecha algorytmu)",
        "correct": false
      },
      {
        "text": "uwarunkowanie i stabilność numeryczna są cechami zadania",
        "inline_explanation": "(Stabilność jest cechą algorytmu)",
        "correct": false
      },
      {
        "text": "algorytmy numerycznie poprawne dają rozwiązanie będące nieco zaburzonym dokładnym rozwiązaniem zadania o nieco zaburzonych danych",
        "inline_explanation": "(Definicja numerycznej poprawności)",
        "correct": true
      }
    ],
    "explanation": "Należy odróżnić uwarunkowanie zadania (czy sam problem jest wrażliwy na błędy) od stabilności/poprawności algorytmu (czy metoda obliczeń nie wprowadza nadmiernych błędów)."
  },
  {
    "id": 119,
    "question": "Błędy związane z ograniczeniem nieskończonego ciągu wymaganych obliczeń do skończonej liczby działań nazywamy:",
    "options": [
      {
        "text": "błędami zaokrągleń (ang. rounding errors)",
        "inline_explanation": "(Te wynikają ze skończonej precyzji arytmetyki)",
        "correct": false
      },
      {
        "text": "błędami obcięcia (ang. truncation errors)",
        "inline_explanation": "(Te wynikają z metody, np. ucięcie szeregu Taylora)",
        "correct": true
      },
      {
        "text": "błędami grubymi",
        "inline_explanation": "(Pomyłki ludzkie)",
        "correct": false
      },
      {
        "text": "błędami danych wejściowych",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Błąd obcięcia powstaje, gdy matematycznie dokładny wzór (np. granica, całka, szereg nieskończony) zastępujemy przybliżonym wzorem obliczalnym w skończonej liczbie kroków (np. suma częściowa szeregu)."
  },
  {
    "id": 120,
    "question": "Macierz Hilberta osiąga wysokie wartości współczynnika uwarunkowania (ang. condition number). Na tej podstawie możemy stwierdzić, że:",
    "options": [
      {
        "text": "macierz Hilberta jest dobrze uwarunkowana",
        "inline_explanation": "(Niski współczynnik = dobre uwarunkowanie)",
        "correct": false
      },
      {
        "text": "macierz Hilberta jest źle uwarunkowana",
        "inline_explanation": "(Wysoki współczynnik = złe uwarunkowanie)",
        "correct": true
      },
      {
        "text": "macierz Hilberta jest zawsze diagonalnie dominująca",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "macierz Hilberta jest macierzą jednostkową",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Wskaźnik uwarunkowania mówi nam, jak bardzo błąd danych wejściowych może zostać powiększony w wyniku. Wysoka wartość tego wskaźnika (jak w przypadku macierzy Hilberta) oznacza, że zadanie jest źle uwarunkowane (bardzo wrażliwe na błędy)."
  },
  {
    "id": 121,
    "question": "Efekt Rungego w interpolacji wielomianowej to:",
    "options": [
      {
        "text": "wynik wyboru złej funkcji interpolującej",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "wynik braku jednoznaczności rozwiązania zadania interpolacji",
        "inline_explanation": "(Rozwiązanie jest jednoznaczne)",
        "correct": false
      },
      {
        "text": "konsekwencja arytmetyki zmiennoprzecinkowej",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "wynik błędu metody",
        "inline_explanation": "(Metody doboru węzłów równoodległych)",
        "correct": true
      }
    ],
    "explanation": "Efekt Rungego to pogorszenie jakości interpolacji wielomianowej (pojawienie się silnych oscylacji na krańcach przedziału) mimo zwiększania stopnia wielomianu. Wynika on z natury wielomianów wysokiego stopnia przy zastosowaniu węzłów równoodległych."
  },
  {
    "id": 122,
    "question": "Aby wyeliminować lub znacząco ograniczyć efekt Rungego przy zadaniu interpolacji można:",
    "options": [
      {
        "text": "zastosować interpolację funkcjami sklejanymi zamiast metody Lagrange'a",
        "inline_explanation": "(Splajny unikają wysokich stopni wielomianów na całym przedziale)",
        "correct": true
      },
      {
        "text": "zastosować interpolację z węzłami gęściej upakowanymi na końcach przedziału",
        "inline_explanation": "(Np. węzły Czebyszewa)",
        "correct": true
      },
      {
        "text": "zwiększyć stopień wielomianu interpolacyjnego przy węzłach równoodległych",
        "inline_explanation": "(To właśnie pogarsza efekt Rungego)",
        "correct": false
      },
      {
        "text": "zastosować ekstrapolację zamiast interpolacji",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Efekt Rungego można zniwelować na dwa sposoby: zmieniając rozmieszczenie węzłów (zagęszczenie na krańcach, np. węzły Czebyszewa) lub zmieniając metodę interpolacji na taką, która nie używa jednego wielomianu wysokiego stopnia dla całego zbioru (funkcje sklejane)."
  },
  {
    "id": 123,
    "question": "Efekt Rungego jest charakterystyczny dla następujących metod interpolacji:",
    "options": [
      {
        "text": "interpolacji funkcjami sklejanymi 1 stopnia dla węzłów równoodległych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "interpolacji funkcjami sklejanymi 3 stopnia dla węzłów równoodległych",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "interpolacji metodą Lagrange'a (wielomianowej) dla węzłów równoodległych",
        "inline_explanation": "(Szczególnie dla wysokich stopni wielomianu)",
        "correct": true
      },
      {
        "text": "interpolacji metodą Lagrange'a dla węzłów będących zerami wielomianów Czebyszewa",
        "inline_explanation": "(Tu efekt jest zminimalizowany)",
        "correct": false
      }
    ],
    "explanation": "Efekt ten występuje przy interpolacji wielomianowej (gdzie jeden wielomian opisuje cały zbiór punktów), gdy stopień wielomianu jest wysoki, a węzły są rozmieszczone równomiernie."
  },
  {
    "id": 124,
    "question": "Wskaż zdania prawdziwe dotyczące zagadnienia interpolacji wielomianowej z wykorzystaniem jednomianów (tzw. bazy naturalnej):",
    "options": [
      {
        "text": "jest to zadanie dobrze uwarunkowane",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "ma zdecydowanie lepsze właściwości obliczeniowe niż metoda Lagrange'a",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "jest to zadanie źle uwarunkowane",
        "inline_explanation": "(Macierz Vandermonde'a ma wysoki wskaźnik uwarunkowania)",
        "correct": true
      },
      {
        "text": "nie wymaga rozwiązywania układu równań",
        "inline_explanation": "(Wymaga rozwiązania układu z macierzą Vandermonde'a)",
        "correct": false
      }
    ],
    "explanation": "Interpolacja w bazie naturalnej ($1, x, x^2, ...$) prowadzi do konieczności rozwiązania układu równań z macierzą Vandermonde'a. Macierz ta dla większych stopni jest bardzo źle uwarunkowana, co prowadzi do dużych błędów numerycznych."
  },
  {
    "id": 125,
    "question": "Wybierz poprawną odpowiedź dotyczącą metod numerycznych:",
    "options": [
      {
        "text": "interpolacja z węzłami będącymi zerami wielomianu Czebyszewa odpowiedniego stopnia eliminuje efekt Rungego",
        "inline_explanation": "(to prawda - zagęszczenie węzłów na krańcach przedziału minimalizuje błąd interpolacji i niweluje oscylacje wielomianu)",
        "correct": true
      },
      {
        "text": "przybliżenia Pade to technika aproksymacji średniokwadratowej",
        "inline_explanation": "(aproksymacja Pade to technika aproksymacji wymiernej, często dająca wyniki bliskie aproksymacji jednostajnej, a nie średniokwadratowej)",
        "correct": false
      },
      {
        "text": "funkcje sklejane nie mogą być wykorzystane do aproksymacji średniokwadratowej ze względu na postać minimalizowanej normy",
        "inline_explanation": "(mogą być - metoda najmniejszych kwadratów działa z powodzeniem dla funkcji sklejanych/splajnów)",
        "correct": false
      },
      {
        "text": "aproksymacja średniokwadratowa polega na minimalizacji normy Czebyszewa",
        "inline_explanation": "(minimalizacja normy Czebyszewa to aproksymacja jednostajna; średniokwadratowa minimalizuje normę L2)",
        "correct": false
      }
    ],
    "explanation": "Efekt Rungego to pogorszenie jakości interpolacji wielomianowej (silne oscylacje na krańcach przedziału) przy zwiększaniu stopnia wielomianu dla węzłów równoodległych. Zastosowanie węzłów Czebyszewa (gęściej rozmieszczonych na krańcach) rozwiązuje ten problem.  Co do pozostałych: Aproksymacja średniokwadratowa minimalizuje całkę z kwadratu błędu (norma L2), natomiast aproksymacja jednostajna minimalizuje maksymalny błąd (norma supremum/Czebyszewa). Aproksymacja Padé służy do przybliżania funkcji za pomocą ilorazu wielomianów."
  },
  {
    "id": 126,
    "question": "Funkcje sklejane stopnia $m$ na przedziale $[a, b]$:",
    "options": [
      {
        "text": "są ciągłe wraz z $(m-1)$ pochodnymi na $[a, b]$",
        "inline_explanation": "(definicja splajnu zakłada ciągłość funkcji oraz jej pochodnych aż do rzędu o jeden mniejszego niż stopień wielomianu)",
        "correct": true
      },
      {
        "text": "są ciągłe wraz z $(m+1)$ pochodnymi na $[a, b]$",
        "inline_explanation": "(wymóg ciągłości wyższych pochodnych byłby zbyt restrykcyjny i uniemożliwiłby elastyczne dopasowanie w węzłach)",
        "correct": false
      },
      {
        "text": "są używane tylko do interpolacji przedziałowej",
        "inline_explanation": "(przedział $[a, b]$ może być nieskończony, jeśli tylko mamy wzór na obliczanie węzłów interpolacji na całej osi liczb rzeczywistych)",
        "correct": false
      },
      {
        "text": "nie są przydatne do interpolowania funkcji periodycznych",
        "inline_explanation": "(istnieją specjalne warianty splajnów periodycznych, gdzie warunki brzegowe wymuszają zgodność na końcach przedziału)",
        "correct": false
      },
      {
        "text": "są jednoznacznie określone przez podanie warunków brzegowych",
        "inline_explanation": "(samo podanie warunków brzegowych to za mało – zależy to od typu interpolacji, np. muszą być znane wartości w węzłach)",
        "correct": false
      },
      {
        "text": "nadają się tylko do interpolowania przedziałowego funkcji z nieciągłymi osobliwościami",
        "inline_explanation": "(splajny służą do przybliżania funkcji gładkich; w przypadku nieciągłości stosuje się inne metody)",
        "correct": false
      },
      {
        "text": "są przydatne nie tylko do interpolacji, ale też do aproksymacji",
        "inline_explanation": "(np. splajny wygładzające, które nie muszą przechodzić przez punkty, ale minimalizują błąd średniokwadratowy)",
        "correct": true
      }
    ],
    "explanation": "Splajny to funkcje kawałkami będące wielomianami, 'sklejone' w węzłach. Warunki, które muszą spełniać to: przechodzenie przez węzły, ciągłość w węzłach oraz ciągłość pochodnych do $N-1$ włącznie (gdzie N to stopień splajnu)."
  },
  {
    "id": 127,
    "question": "Wielomiany sklejane (ang. spline) trzeciego stopnia muszą spełniać następujące warunki w punktach sklejeń:",
    "options": [
      {
        "text": "przechodzenie funkcji interpolującej przez węzły interpolacji",
        "inline_explanation": "(podstawowy warunek interpolacji)",
        "correct": true
      },
      {
        "text": "ciągłość drugiej pochodnej funkcji interpolującej",
        "inline_explanation": "(dla splajnu stopnia $N=3$, wymagana jest ciągłość do $N-1=2$ pochodnej włącznie)",
        "correct": true
      },
      {
        "text": "ciągłość funkcji interpolującej",
        "inline_explanation": "(funkcja nie może mieć 'dziur' w punktach sklejenia)",
        "correct": true
      },
      {
        "text": "ciągłość pochodnej funkcji interpolującej",
        "inline_explanation": "(pierwsza pochodna odpowiada za gładkość 'stycznych', brak załamań)",
        "correct": true
      }
    ],
    "explanation": "Splajny 3 stopnia (cubic spline) są szczególnie ważne, bo dzięki ciągłości 2 pochodnej są gładkie i dobrze interpolują funkcje. W odmianie 'natural cubic spline' dodaje się warunek zerowania drugiej pochodnej na końcach przedziału ($S''(a) = S''(b) = 0$). "
  },
  {
    "id": 128,
    "question": "Które z poniżej wymienionych zagadnień numerycznych wykorzystują właściwości przybliżania funkcji wielomianem interpolującym:",
    "options": [
      {
        "text": "metoda siecznych, metoda stycznych szukania miejsc zerowych funkcji",
        "inline_explanation": "(metody te bazują na lokalnej aproksymacji funkcji linią prostą - wielomianem stopnia 1)",
        "correct": true
      },
      {
        "text": "obliczanie całki oznaczonej funkcji za pomocą kwadratur Newtona-Cotesa",
        "inline_explanation": "(najpierw interpolujemy funkcję wielomianowo, a potem całki z wielomianów liczy się bardzo prosto)",
        "correct": true
      },
      {
        "text": "równania różniczkowe zwyczajne",
        "inline_explanation": "(wiele metod rozwiązywania RRZ, np. metody wielokrokowe, wykorzystuje interpolację wielomianową do wyznaczania kolejnych punktów)",
        "correct": true
      },
      {
        "text": "rozwiązywanie układów równań metodami iteracyjnymi",
        "inline_explanation": "(tu operujemy zazwyczaj na macierzach i wektorach, a nie na interpolacji funkcji ciągłych)",
        "correct": false
      }
    ],
    "explanation": "Wielomiany interpolacyjne są fundamentem wielu metod numerycznych, ponieważ operacje na wielomianach (całkowanie, różniczkowanie) są analitycznie proste i tanie obliczeniowo."
  },
  {
    "id": 129,
    "question": "Dla $n+1$ wartości zmiennej niezależnej $x_i$ ($i = 0,1,...,n$), wykonano pomiary i otrzymano $n+1$ wartości $y_i$. Zależność wielkości mierzonej od $x$ aproksymowano wielomianem postaci $W_m(x) = \\sum_{j=0}^{m} a_{j,m} x^j$. Niech $E_m$ oznacza błąd aproksymacji. Zaznacz prawdziwe implikacje.",
    "options": [
      {
        "text": "$m = n \\implies E_m = 0$",
        "inline_explanation": "(dla $m = n$ wielomian aproksymacyjny staje się interpolacyjnym i przechodzi dokładnie przez wszystkie zadane węzły)",
        "correct": true
      },
      {
        "text": "$m > n \\implies E_m < 0$",
        "inline_explanation": "(błąd średniokwadratowy jest sumą kwadratów, więc z definicji nie może być ujemny)",
        "correct": false
      },
      {
        "text": "$E_m > 0 \\implies n > m$",
        "inline_explanation": "(jeżeli mamy więcej punktów ($n$) niż wynosi stopień wielomianu ($m$), to zazwyczaj nie da się przejść przez wszystkie punkty - trzeba aproksymować z błędem)",
        "correct": true
      },
      {
        "text": "$m < n \\implies E_m = 0$",
        "inline_explanation": "(nieprawda, przy stopniu wielomianu mniejszym od liczby punktów, funkcja rzadko trafia we wszystkie punkty, więc $E_m > 0$)",
        "correct": false
      }
    ],
    "explanation": "Zadanie dotyczy różnicy między interpolacją a aproksymacją. Jeśli stopień wielomianu $m$ jest równy liczbie odcinków (lub $m+1$ liczbie punktów $n+1$), mamy do czynienia z interpolacją (błąd w węzłach = 0). Jeśli punktów jest więcej niż wynosi stopień wielomianu ($n > m$), stosujemy aproksymację (np. metodą najmniejszych kwadratów), która generuje błąd $E_m > 0$."
  },
  {
    "id": 130,
    "question": "Rozważamy 3 sposoby obliczania błędu aproksymacji $E_m$ dla wielomianu $W_m(x)$:\n1. $E_m = \\min_{a} \\sum_{i=0}^n |y_i - W_m(x_i)|$\n2. $E_m = \\min_{a} \\sum_{i=0}^n (y_i - W_m(x_i))^2$\n3. $E_m = \\min_{a} \\max_{i=0,\\dots,n} |y_i - W_m(x_i)|$\nObliczanie współczynników $a_i$ można sprowadzić do zagadnienia liniowego (układu równań lub programowania liniowego):",
    "options": [
      {
        "text": "w przypadku 1",
        "inline_explanation": "(minimalizacja sumy modułów to regresja LAD - Least Absolute Deviations; jest to klasyczny problem programowania liniowego)",
        "correct": true
      },
      {
        "text": "w przypadku 2",
        "inline_explanation": "(metoda najmniejszych kwadratów prowadzi do układu równań liniowych, tzw. układu normalnego, co jest zagadnieniem liniowym)",
        "correct": true
      },
      {
        "text": "w przypadku 3",
        "inline_explanation": "(aproksymacja jednostajna/Czebyszewa również może być rozwiązana algorytmem wymiany Remeza lub programowaniem liniowym, ale w kontekście tego pytania kluczowe są 1 i 2)",
        "correct": false
      },
      {
        "text": "w żadnym z tych przypadków",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Pojęcie 'zagadnienie liniowe' jest tu traktowane szeroko. Przypadek 2 (metoda najmniejszych kwadratów) sprowadza się do rozwiązania układu równań liniowych ($A^TAx = A^Ty$), co jest najbardziej typowym zagadnieniem algebry liniowej. Przypadek 1 (suma modułów różnic) nie jest różniczkowalny w zerze, więc nie daje prostego układu równań, ale daje się sformułować jako zadanie programowania liniowego (Linear Programming), gdzie minimalizujemy funkcję celu przy liniowych ograniczeniach."
  },
  {
    "id": 131,
    "question": "Dla danych eksperymentalnych: $x_i = \\{2, 4, 6\\}$, $y_i = \\{1, 2, 1\\}$ wyznaczono 3 funkcje aproksymujące postaci $f_k(x) = a_k x + b_k$ (dla $k=1,2,3$), używając różnych kryteriów jakości:\n1. Min. sumy modułów (L1)\n2. Min. sumy kwadratów (L2)\n3. Min. błędu maksymalnego (L_inf/Czebyszewa)\nZaznacz prawidłowe odpowiedzi dotyczące współczynników:",
    "options": [
      {
        "text": "$a_1 = a_2 = a_3, \\quad b_1 = b_2 = b_3$",
        "inline_explanation": "(funkcje te różnią się przesunięciem $b$, więc nie są identyczne)",
        "correct": false
      },
      {
        "text": "$a_1 = a_2 = a_3, \\quad b_1 \\neq b_2 \\neq b_3$",
        "inline_explanation": "(dla tych konkretnych danych, ze względu na symetrię punktów, nachylenie $a$ wynosi 0 dla wszystkich metod, natomiast wyraz wolny $b$ różni się w zależności od przyjętej normy)",
        "correct": true
      },
      {
        "text": "$a_1 \\neq a_2 \\neq a_3$",
        "inline_explanation": "(w ogólnym przypadku $a$ byłyby różne, ale dla danych symetrycznych \"górka\" jest aproksymowana linią poziomą)",
        "correct": false
      },
      {
        "text": "$b_1 = b_3 \\neq b_2$",
        "inline_explanation": "(obliczenia wskazują na trzy różne wartości: $b_1=1$ (mediana), $b_2 \\approx 1.33$ (średnia), $b_3=1.5$ (środek zakresu))",
        "correct": false
      }
    ],
    "explanation": "Jest to prosta regresja liniowa dla danych układających się w 'daszek' (1, 2, 1). Ze względu na symetrię, każda metoda wyznaczy linię poziomą ($a=0$). Różnią się jednak wysokością ($b$):\n1. Regresja L1 (LAD) celuje w medianę y, ignorując 'odstawanie' środkowego punktu -> $y=1$.\n2. Regresja L2 (klasyczna) wylicza średnią -> $y=1.333...$\n3. Aproksymacja jednostajna (L_inf) musi zminimalizować maksymalny błąd, więc linia przejdzie idealnie pośrodku między y=1 a y=2 -> $y=1.5$."
  },
  {
    "id": 132,
    "question": "Czy obliczanie parametrów (współczynników) funkcji aproksymującej można sprowadzić do rozwiązania układu równań liniowych?",
    "options": [
      {
        "text": "tak, ale wtedy i tylko wtedy, gdy funkcja aproksymująca jest funkcją liniową względem zmiennej niezależnej",
        "inline_explanation": "(nie jest to konieczne; funkcja może być np. wielomianem kwadratowym zmiennej $x$, a nadal da się to rozwiązać układem liniowym względem parametrów)",
        "correct": false
      },
      {
        "text": "tak, ale wtedy i tylko wtedy, gdy funkcja aproksymująca jest wielomianem (zmiennej niezależnej)",
        "inline_explanation": "(w tym kontekście 'wielomian' oznacza uogólniony wielomian, czyli kombinację liniową funkcji bazowych, np. $a_0 \\phi_0(x) + ... + a_m \\phi_m(x)$)",
        "correct": true
      },
      {
        "text": "nie można",
        "inline_explanation": "(można, to podstawa metody najmniejszych kwadratów)",
        "correct": false
      },
      {
        "text": "tak, dla dowolnej funkcji nieliniowej",
        "inline_explanation": "(jeśli parametry wchodzą nieliniowo, np. $e^{ax}$, to otrzymujemy nieliniowy problem najmniejszych kwadratów, którego nie rozwiążemy prostym układem równań liniowych)",
        "correct": false
      }
    ],
    "explanation": "Kluczem jest tu pojęcie 'liniowości ze względu na parametry'. Aproksymacja średniokwadratowa ma postać $F(x) = a_0 \\phi_0(x) + ... + a_m \\phi_m(x)$. Baza $\\phi$ może być dowolna (wielomiany, sin/cos), ale szukane współczynniki $a_i$ występują w pierwszej potędze. Prowadzi to do układu równań normalnych, który jest liniowy."
  },
  {
    "id": 133,
    "question": "Rozważamy 3 kryteria jakości aproksymacji (miary błędu):\n1. Suma modułów różnic (L1)\n2. Suma kwadratów różnic (L2)\n3. Maksymalny moduł różnicy (L_inf/jednostajna)\nNiech $\\Delta_{max}^{(k)}$ oznacza błąd w sensie metryki maksimum (Czebyszewa) dla funkcji wyznaczonej metodą $k$. Zaznacz prawdziwe relacje:",
    "options": [
      {
        "text": "$\\Delta_{max}^{(1)} \\ge \\Delta_{max}^{(2)}$",
        "inline_explanation": "(Metoda kwadratowa (2) mocniej reaguje na duże odchylenia (outliery) niż metoda modułowa (1), starając się je zmniejszyć, co zazwyczaj prowadzi do mniejszego błędu maksymalnego)",
        "correct": true
      },
      {
        "text": "$\\Delta_{max}^{(1)} \\le \\Delta_{max}^{(2)}$",
        "inline_explanation": "(nieprawda, metoda L1 często 'ignoruje' pojedyncze mocno odstające punkty, co skutkuje dużym błędem maksymalnym w tych punktach)",
        "correct": false
      },
      {
        "text": "$\\Delta_{max}^{(3)} \\le \\Delta_{max}^{(2)}$",
        "inline_explanation": "(Metoda 3 (jednostajna) z definicji minimalizuje błąd maksymalny, więc $\\Delta_{max}^{(3)}$ musi być najmniejsza ze wszystkich)",
        "correct": true
      },
      {
        "text": "$\\Delta_{max}^{(3)} \\le \\Delta_{max}^{(1)}$",
        "inline_explanation": "(Jak wyżej - metoda 3 daje najmniejszy możliwy błąd maksymalny)",
        "correct": true
      }
    ],
    "explanation": "Kolejność wielkości błędu maksymalnego (Czebyszewa) zazwyczaj układa się tak: $\\Delta_3 \\le \\Delta_2 \\le \\Delta_1$.\n1. Aproksymacja jednostajna (3) bezpośrednio minimalizuje ten błąd, więc jest on najmniejszy.\n2. Metoda kwadratowa (2) 'nie lubi' dużych błędów (bo podnosi je do kwadratu), więc stara się je spłaszczyć, co redukuje błąd max.\n3. Metoda modułowa (1) jest odporna na outliery, co paradoksalnie oznacza, że pozwala na istnienie pojedynczego, dużego błędu maksymalnego, jeśli reszta punktów pasuje dobrze."
  },
  {
    "id": 134,
    "question": "Kwadratury Gaussa stosowane są:",
    "options": [
      {
        "text": "ze względu na łatwiejszy wybór węzłów całkowania",
        "inline_explanation": "(węzły w metodzie Gaussa to miejsca zerowe wielomianów ortogonalnych, np. Legendre'a, co jest trudniejsze do wyliczenia niż węzły równoodległe)",
        "correct": false
      },
      {
        "text": "dlatego, że kwadratury Newtona-Cotesa nie dają możliwości usuwania całkowalnych osobliwości",
        "inline_explanation": "(obie metody mają swoje sposoby radzenia sobie z osobliwościami, nie jest to główny wyróżnik Gaussa)",
        "correct": false
      },
      {
        "text": "ze względu na mniejszą złożoność obliczeniową niż kwadratur Newtona-Cotesa",
        "inline_explanation": "(złożoność wyznaczenia wag i węzłów jest większa, choć sam wzór sumacyjny ma podobną złożoność)",
        "correct": false
      },
      {
        "text": "ponieważ umożliwiają uzyskanie prawie dwa razy większego stopnia dokładności niż kwadratury Newtona-Cotesa dla tej samej liczby węzłów",
        "inline_explanation": "(dla $n$ węzłów kwadratura Gaussa całkuje dokładnie wielomiany stopnia $2n-1$, podczas gdy Newtona-Cotesa tylko stopnia $n$ lub $n+1$)",
        "correct": true
      }
    ],
    "explanation": "Główną zaletą kwadratur Gaussa jest ich maksymalny rząd dokładności algebraicznej. Dobierając optymalnie nie tylko wagi (jak w Newtonie-Cotesie), ale i położenie węzłów, jesteśmy w stanie przy użyciu $n$ punktów zintegrować dokładnie wielomian stopnia $2n-1$. Ceną za to są 'trudne' liczby (węzły i wagi są często liczbami niewymiernymi), ale komputer radzi sobie z nimi doskonale."
  },
  {
    "id": 135,
    "question": "Do całkowania numerycznego używa się m. in. kwadratur Newtona-Cotesa. Do prostych kwadratur Newtona-Cotesa (opartych na węzłach równoodległych) należą:",
    "options": [
      {
        "text": "metoda Eulera",
        "inline_explanation": "(to metoda rozwiązywania równań różniczkowych, a nie całkowania oznaczonego)",
        "correct": false
      },
      {
        "text": "metoda Romberga",
        "inline_explanation": "(choć bazuje na trapezach, wykorzystuje ekstrapolację Richardsona do ulepszania wyniku, więc jest metodą złożoną, a nie prostą kwadraturą)",
        "correct": false
      },
      {
        "text": "metoda prostokątów",
        "inline_explanation": "(najprostsza metoda, aproksymacja wielomianem stopnia 0)",
        "correct": true
      },
      {
        "text": "metoda trapezów",
        "inline_explanation": "(aproksymacja wielomianem stopnia 1)",
        "correct": true
      },
      {
        "text": "metoda Simpsona",
        "inline_explanation": "(aproksymacja wielomianem stopnia 2 - parabola)",
        "correct": true
      },
      {
        "text": "reguła 3/8",
        "inline_explanation": "(tzw. drugi wzór Simpsona, aproksymacja wielomianem stopnia 3)",
        "correct": true
      },
      {
        "text": "metoda Boole'a",
        "inline_explanation": "(oparta na 5 węzłach, aproksymacja wielomianem stopnia 4)",
        "correct": true
      }
    ],
    "explanation": "Do rodziny prostych kwadratur Newtona-Cotesa (zamkniętych lub otwartych) zaliczamy te metody, które dzielą przedział na równe podprzedziały i aproksymują funkcję wielomianem interpolacyjnym Lagrange'a. Są to kolejno: prostokątów, trapezów, Simpsona (parabol), 3/8 i Boole'a. Metoda Romberga jest algorytmem iteracyjnym poprawiającym wynik metody trapezów, więc stanowi osobną klasę algorytmów."
  },
  {
    "id": 136,
    "question": "Wybierz właściwe uporządkowanie metod całkowania Monte Carlo według narastającej ich jakości (efektywności/zmniejszania wariancji):",
    "options": [
      {
        "text": "podstawowa, warstwowa, średniej ważonej, orzeł-reszka",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "podstawowa, orzeł-reszka, warstwowa, średniej ważonej",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "podstawowa, średniej ważonej, orzeł-reszka, warstwowa",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "orzeł-reszka, podstawowa, warstwowa, średniej ważonej",
        "inline_explanation": "(kolejno: Hit-or-Miss [najgorsza], Crude MC, Stratified Sampling, Importance Sampling [najlepsza])",
        "correct": true
      }
    ],
    "explanation": "Hierarchia metod Monte Carlo wynika z szybkości zbieżności i redukcji wariancji:\n1. Orzeł-reszka (Hit-or-Miss): geometryczna interpretacja, strzelamy w prostokąt i liczymy trafienia pod wykresem. Bardzo wolna zbieżność.\n2. Podstawowa (Crude/Mean Value): liczymy średnią z wartości funkcji w losowych punktach. Lepsza od geometrycznej.\n3. Warstwowa (Stratified): dzielimy obszar na warstwy i losujemy po równo z każdej, co zapobiega pominęciu istotnych obszarów (zmniejsza wariancję).\n4. Średniej ważonej (Importance Sampling): losujemy punkty częściej tam, gdzie funkcja przyjmuje duże wartości (ma dużą 'wagę'). To najbardziej zaawansowana i zazwyczaj najdokładniejsza metoda."
  },
  {
    "id": 137,
    "question": "Warunkami wystarczającymi, gwarantującymi zbieżność poszukiwania miejsc zerowych funkcji $f(x)$ metodą bisekcji są:",
    "options": [
      {
        "text": "funkcja $f(x)$ jest ciągła w przedziale domkniętym $[a, b]$",
        "inline_explanation": "(to pierwszy warunek twierdzenia Darboux, na którym opiera się metoda)",
        "correct": true
      },
      {
        "text": "pierwsza i druga pochodna $f(x)$ istnieją i są ciągłe w przedziale domkniętym $[a, b]$",
        "inline_explanation": "(metoda bisekcji nie wymaga istnienia pochodnych, w przeciwieństwie do metody Newtona)",
        "correct": false
      },
      {
        "text": "pierwsza i druga pochodna mają stały znak w całym przedziale",
        "inline_explanation": "(to warunek zbieżności dla metody stycznych/Newtona, a nie bisekcji)",
        "correct": false
      },
      {
        "text": "na końcach przedziału $[a, b]$ wartości funkcji $f(x)$ przyjmują przeciwne znaki, czyli zachodzi $f(a) \\cdot f(b) < 0$",
        "inline_explanation": "(to drugi kluczowy warunek - gwarantuje, że wykres funkcji przecina oś OX wewnątrz przedziału)",
        "correct": true
      }
    ],
    "explanation": "Metoda bisekcji jest metodą pewną (zawsze zbieżną), o ile spełnione są założenia twierdzenia Bolzano-Darboux: funkcja musi być ciągła, a na krańcach przedziału przyjmować wartości przeciwnych znaków. Metoda ta nie wymaga różniczkowalności funkcji."
  },
  {
    "id": 138,
    "question": "Stosując algorytm stycznych (Newtona) poszukiwania jednokrotnego miejsca zerowego funkcji $f(x)$ w przedziale domkniętym $[a, b]$ w dostatecznej bliskości pierwiastka uzyskujemy zbieżność:",
    "options": [
      {
        "text": "kwadratową",
        "inline_explanation": "(błąd w kolejnej iteracji jest proporcjonalny do kwadratu błędu w poprzedniej: $|e_{n+1}| \\le C|e_n|^2$)",
        "correct": true
      },
      {
        "text": "wykładniczą",
        "inline_explanation": "(to zbyt silne stwierdzenie dla standardowych metod iteracyjnych)",
        "correct": false
      },
      {
        "text": "liniową",
        "inline_explanation": "(zbieżność liniową ma metoda bisekcji, jest ona znacznie wolniejsza)",
        "correct": false
      },
      {
        "text": "nadliniową (rzędu ok. 1.62)",
        "inline_explanation": "(taka zbieżność charakteryzuje metodę siecznych, która jest wolniejsza od metody stycznych)",
        "correct": false
      }
    ],
    "explanation": "Metoda stycznych (Newtona-Raphsona) ma zbieżność kwadratową (rząd 2), co oznacza bardzo szybkie dochodzenie do wyniku, pod warunkiem, że punkt startowy jest wystarczająco blisko pierwiastka ('w dostatecznej bliskości'). Wymaga to jednak obliczania wartości pochodnej w każdym kroku."
  },
  {
    "id": 139,
    "question": "Metoda Newtona-Raphsona rozwiązywania równań nieliniowych:",
    "options": [
      {
        "text": "wykorzystuje niejawnie przyspieszenie Aitkena",
        "inline_explanation": "(proces Aitkena to osobna metoda przyspieszania zbieżności ciągów liniowo zbieżnych)",
        "correct": false
      },
      {
        "text": "jest przykładem metody iteracyjnej o stałym punkcie (metody punktu stałego)",
        "inline_explanation": "(można ją zapisać jako $x_{n+1} = g(x_n)$, gdzie funkcja iteracji $g(x) = x - f(x)/f'(x)$)",
        "correct": true
      },
      {
        "text": "jest przykładem metody interpolacyjnej",
        "inline_explanation": "(metodą interpolacyjną jest metoda siecznych; Newton linearyzuje funkcję za pomocą pochodnej/szeregu Taylora)",
        "correct": false
      },
      {
        "text": "ma rząd zbieżności równy 1",
        "inline_explanation": "(rząd 1 ma bisekcja)",
        "correct": false
      },
      {
        "text": "ma rząd zbieżności równy 2",
        "inline_explanation": "(zbieżność kwadratowa)",
        "correct": true
      },
      {
        "text": "jest szybciej zbieżna niż metoda siecznych",
        "inline_explanation": "(2 > 1.618...)",
        "correct": true
      },
      {
        "text": "jest szybciej zbieżna niż metoda bisekcji",
        "inline_explanation": "(2 > 1)",
        "correct": true
      },
      {
        "text": "nie może być uogólniona dla układów równań nieliniowych",
        "inline_explanation": "(może być, stosuje się wtedy macierz Jacobiego zamiast pochodnej)",
        "correct": false
      },
      {
        "text": "wymaga znajomości pochodnej funkcji",
        "inline_explanation": "(wzór iteracyjny zawiera $f'(x)$ w mianowniku)",
        "correct": true
      }
    ],
    "explanation": "Metoda Newtona-Raphsona to potężne narzędzie o zbieżności kwadratowej. Jej iteracja dana jest wzorem $x_{k+1} = x_k - \\frac{f(x_k)}{f'(x_k)}$. Wymaga znajomości analitycznej postaci pochodnej i dobrego punktu startowego, ale w zamian oferuje bardzo szybką zbieżność (szybszą niż siecznych i bisekcji)."
  },
  {
    "id": 140,
    "question": "Metody blokowe rozwiązywania układów równań (liniowych lub nieliniowych):",
    "options": [
      {
        "text": "redukują złożoność obliczeniową metodą \"dziel i rządź\"",
        "inline_explanation": "(dzieląc dużą macierz/problem na mniejsze bloki, można efektywniej zarządzać pamięcią cache i wykonywać obliczenia)",
        "correct": true
      },
      {
        "text": "nie wymagają wyznaczania elementu wiodącego (pivotingu)",
        "inline_explanation": "(wewnątrz bloków nadal często stosuje się eliminację Gaussa z wyborem elementu wiodącego dla stabilności)",
        "correct": false
      },
      {
        "text": "są jedynymi metodami dostępnymi na architekturach równoległych",
        "inline_explanation": "(nie jedynymi, ale bardzo efektywnymi; zwykłe metody też da się zrównoleglić, choć zazwyczaj gorzej)",
        "correct": false
      },
      {
        "text": "zawsze automatycznie konwertują macierz do postaci trójkątnej dolnej",
        "inline_explanation": "(metody blokowe mogą dążyć do różnych postaci, np. blokowo-diagonalnej, a nie tylko trójkątnej)",
        "correct": false
      }
    ],
    "explanation": "Podejście blokowe w analizie numerycznej polega na operowaniu na podmacierzach (blokach) zamiast na pojedynczych liczbach. Pozwala to na zastosowanie strategii 'dziel i rządź' (Divide and Conquer), co jest kluczowe przy optymalizacji wydajności na współczesnych procesorach (lepsze wykorzystanie pamięci podręcznej cache) oraz w obliczeniach równoległych."
  },
  {
    "id": 141,
    "question": "Metoda eliminacji Gaussa rozwiązywania układów równań liniowych:",
    "options": [
      {
        "text": "wymaga wyszukiwania elementu wiodącego i polega na przekształceniu macierzy do postaci trójkątnej górnej",
        "inline_explanation": "(kluczowy etap metody to sprowadzenie macierzy do postaci, w której pod główną przekątną są same zera)",
        "correct": true
      },
      {
        "text": "polega na doprowadzeniu macierzy do postaci diagonalnej",
        "inline_explanation": "(to cecha metody Gaussa-Jordana, a nie klasycznej eliminacji Gaussa)",
        "correct": false
      },
      {
        "text": "ma złożoność $O(n^3)$, gdzie $n$ - liczba równań",
        "inline_explanation": "(to standardowa złożoność dla metod dokładnych takich jak Gauss czy LU)",
        "correct": true
      },
      {
        "text": "jest przykładem metody iteracyjnej niestacjonarnej",
        "inline_explanation": "(jest to metoda dokładna/bezpośrednia, wykonująca skończoną liczbę kroków)",
        "correct": false
      },
      {
        "text": "ma złożoność $O(n^2)$, gdzie $n$ - liczba równań",
        "inline_explanation": "(złożoność kwadratową ma jedynie etap podstawiania wstecznego, cała metoda to $O(n^3)$)",
        "correct": false
      }
    ],
    "explanation": "Eliminacja Gaussa to metoda dokładna o złożoności sześciennej. Jej celem jest przekształcenie macierzy rozszerzonej układu do postaci schodkowej (trójkątnej górnej), co pozwala na łatwe wyliczenie zmiennych, zaczynając od ostatniej (backward substitution). Element wiodący (pivot) jest dobierany tak, aby zminimalizować błędy zaokrągleń."
  },
  {
    "id": 142,
    "question": "Które zdania dotyczące metody eliminacji Gaussa rozwiązywania układów równań są prawdziwe:",
    "options": [
      {
        "text": "jest to metoda iteracyjna",
        "inline_explanation": "(nie, jest to metoda dokładna - daje wynik w skończonej liczbie kroków)",
        "correct": false
      },
      {
        "text": "jest to metoda dokładna",
        "inline_explanation": "(teoretycznie daje dokładny wynik, w praktyce obarczony błędami zaokrągleń)",
        "correct": true
      },
      {
        "text": "przekształca macierz do postaci macierzy schodkowej",
        "inline_explanation": "(czyli macierzy trójkątnej górnej)",
        "correct": true
      },
      {
        "text": "nie wymaga przekształcenia układu równań do postaci z macierzą trójkątną górną",
        "inline_explanation": "(wymaga - klasyczna eliminacja Gaussa sprowadza macierz do postaci trójkątnej górnej, po czym następuje postępowanie odwrotne)",
        "correct": false
      }
    ],
    "explanation": "Metoda Gaussa należy do grupy metod dokładnych (bezpośrednich). Kluczowym mechanizmem jest operowanie na wierszach w celu wyzerowania elementów pod przekątną, co daje macierz schodkową/trójkątną."
  },
  {
    "id": 143,
    "question": "Metody dekompozycji LU:",
    "options": [
      {
        "text": "mają znacznie lepsze własności numeryczne niż metoda eliminacji Gaussa",
        "inline_explanation": "(metoda LU jest zazwyczaj stabilniejsza numerycznie i pozwala na łatwiejsze rozwiązywanie wielu układów z tą samą macierzą główną)",
        "correct": true
      },
      {
        "text": "należą do rodziny metod iteracyjnych niestacjonarnych",
        "inline_explanation": "(LU to metoda dokładna)",
        "correct": false
      },
      {
        "text": "nie wymagają wyszukiwania elementu wiodącego",
        "inline_explanation": "(wymagają - pivoting jest stosowany również w dekompozycji LU w celu zapewnienia stabilności)",
        "correct": false
      },
      {
        "text": "są przydatne tylko do rozwiązywania układów równań z macierzą symetryczną dodatnio określoną",
        "inline_explanation": "(do takich macierzy stosuje się rozkład Choleskiego; LU działa dla dowolnych macierzy kwadratowych niesobliwych)",
        "correct": false
      },
      {
        "text": "mają lepszą złożoność obliczeniową niż metoda Gaussa, gdyż nie wymagają wyszukiwania elementu wiodącego",
        "inline_explanation": "(złożoność dekompozycji jest taka sama jak Gaussa: $O(n^3)$)",
        "correct": false
      },
      {
        "text": "są metodami iteracyjnymi stacjonarnymi",
        "inline_explanation": "(są metodami dokładnymi)",
        "correct": false
      }
    ],
    "explanation": "Metoda LU rozbija macierz $A$ na iloczyn macierzy dolnej trójkątnej $L$ i górnej trójkątnej $U$. Choć koszt wyznaczenia $L$ i $U$ jest rzędu $O(n^3)$ (podobnie jak Gauss), to mając ten rozkład, każdy kolejny układ równań $Ax=b$ (dla nowego wektora $b$) rozwiązuje się w czasie $O(n^2)$, co jest ogromną zaletą."
  },
  {
    "id": 144,
    "question": "Do metod nazywanych metodami dokładnymi rozwiązywania układów równań liniowych zalicza się:",
    "options": [
      {
        "text": "metoda Jacobiego",
        "inline_explanation": "(metoda iteracyjna)",
        "correct": false
      },
      {
        "text": "metoda rozkładu LU",
        "inline_explanation": "(metoda dokładna oparta na faktoryzacji macierzy)",
        "correct": true
      },
      {
        "text": "eliminacja Gaussa",
        "inline_explanation": "(klasyczna metoda dokładna)",
        "correct": true
      },
      {
        "text": "eliminacja Jordana (Gaussa-Jordana)",
        "inline_explanation": "(wariant metody Gaussa sprowadzający macierz do postaci diagonalnej)",
        "correct": true
      },
      {
        "text": "eliminacja Gaussa z wyborem elementu głównego",
        "inline_explanation": "(wariant z pivotingiem poprawiający stabilność)",
        "correct": true
      },
      {
        "text": "metoda Cramera",
        "inline_explanation": "(teoretyczna metoda dokładna wykorzystująca wyznaczniki, w praktyce nieużywana ze względu na złożoność)",
        "correct": true
      },
      {
        "text": "metoda SOR (Successive Over-Relaxation)",
        "inline_explanation": "(metoda iteracyjna)",
        "correct": false
      }
    ],
    "explanation": "Podział metod: Metody dokładne (Gauss, LU, Cramer, Cholesky) dają rozwiązanie po skończonej liczbie operacji arytmetycznych. Metody iteracyjne (Jacobi, Gauss-Seidel, SOR) tworzą ciąg przybliżeń zbieżny do rozwiązania."
  },
  {
    "id": 145,
    "question": "Warunkiem koniecznym i wystarczającym zbieżności metod iteracyjnych prostych (takich jak metoda Jacobiego czy metoda Gaussa-Seidla) rozwiązywania układów równań liniowych jest:",
    "options": [
      {
        "text": "promień spektralny macierzy iterowanej w danej metodzie jest mniejszy od 1",
        "inline_explanation": "($\\rho(M) < 1$ gwarantuje, że błąd maleje z każdą iteracją)",
        "correct": true
      },
      {
        "text": "promień spektralny macierzy iterowanej w danej metodzie jest większy od 1",
        "inline_explanation": "(wtedy metoda jest rozbieżna)",
        "correct": false
      },
      {
        "text": "wyznacznik macierzy głównej układu jest równy 0",
        "inline_explanation": "(wtedy układ jest sprzeczny lub nieoznaczony i nie ma jednoznacznego rozwiązania)",
        "correct": false
      },
      {
        "text": "ślad macierzy iteracji jest dodatni",
        "inline_explanation": "(ślad macierzy nie jest warunkiem wystarczającym zbieżności)",
        "correct": false
      }
    ],
    "explanation": "Promień spektralny $\\rho(A)$ to największa co do modułu wartość własna macierzy iteracji. Jeśli $\\rho(A) < 1$, proces iteracyjny jest zbieżny niezależnie od wyboru punktu startowego."
  },
  {
    "id": 146,
    "question": "Wybierz właściwe uporządkowanie metod iteracyjnego rozwiązywania układów równań liniowych według narastającej ich jakości (szybkości zbieżności/dokładności):",
    "options": [
      {
        "text": "Jacobiego, Czebyszewa, nadrelaksacji, Gaussa-Seidla",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "SOR, Gaussa-Seidla, Czebyszewa, Jacobiego",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "Jacobiego, nadrelaksacji, Czebyszewa, SR",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "Jacobiego, SR, SOR, Czebyszewa",
        "inline_explanation": "(Metoda Jacobiego jest najprostsza i najwolniejsza; SOR (Successive Over-Relaxation) przyspiesza metodę Gaussa-Seidla; metody oparte na wielomianach Czebyszewa są jednymi z najszybszych)",
        "correct": true
      }
    ],
    "explanation": "Jakość metod iteracyjnych mierzy się szybkością ich zbieżności. Metoda Jacobiego jest podstawowa. Metoda Gaussa-Seidla (często ukryta tu pod SR jako krok pośredni) wykorzystuje już obliczone w danej iteracji nowe wartości. SOR wprowadza parametr relaksacji, by jeszcze bardziej przyspieszyć zbieżność. Metody Czebyszewa optymalizują proces, minimalizując błąd w sensie normy spektralnej."
  },
  {
    "id": 147,
    "question": "Szybka transformata Fouriera (FFT):",
    "options": [
      {
        "text": "jest możliwa tylko wtedy, gdy liczba punktów jest całkowitą potęgą 2",
        "inline_explanation": "(algorytm Cooleya-Tukeya jest najefektywniejszy dla potęg dwójki (radix-2), ale istnieją warianty FFT dla dowolnych liczb złożonych)",
        "correct": false
      },
      {
        "text": "ma złożoność obliczeniową $O(n)$, gdzie $n$ - liczba węzłów",
        "inline_explanation": "(złożoność wynosi $O(n \\log n)$, co jest znacznym przyspieszeniem względem $O(n^2)$ dla zwykłego DFT)",
        "correct": false
      },
      {
        "text": "jest realizacją wzoru całkowego Fouriera na architekturach równoległych",
        "inline_explanation": "(FFT to algorytm dyskretny, a nie realizacja wzoru całkowego)",
        "correct": false
      },
      {
        "text": "polega na zamianie pojedynczej transformaty Fouriera na sumę transformat Fouriera",
        "inline_explanation": "(idea 'dziel i rządź': duża transformata jest dzielona na mniejsze, np. dla indeksów parzystych i nieparzystych)",
        "correct": true
      }
    ],
    "explanation": "Szybka transformata Fouriera (FFT) to algorytm wyznaczania dyskretnej transformaty Fouriera (DFT) i transformaty do niej odwrotnej. Jego kluczową zaletą jest redukcja złożoności obliczeniowej z $O(n^2)$ do $O(n \\log n)$. Najpopularniejsza implementacja (Cooleya-Tukeya) działa najlepiej, gdy liczba próbek jest potęgą dwójki, rekurencyjnie dzieląc problem na mniejsze."
  },
  {
    "id": 148,
    "question": "Algorytmy optymalizacji statycznej:",
    "options": [
      {
        "text": "metoda simplexu Neldera-Meada jest metodą bezgradientową",
        "inline_explanation": "(jest to metoda geometryczna, 'pełzająca' po funkcji, niewymagająca obliczania pochodnych)",
        "correct": true
      },
      {
        "text": "metoda Newtona wymaga obliczania w każdym kroku gradientu i hesjanu",
        "inline_explanation": "(wymaga znajomości pierwszych i drugich pochodnych, co jest jej głównym kosztem obliczeniowym)",
        "correct": true
      },
      {
        "text": "metody z funkcją kary (penalty methods) stosuje się w przypadkach optymalizacji bez ograniczeń",
        "inline_explanation": "(odwrotnie - stosuje się je, aby zamienić problem z ograniczeniami na problem bez ograniczeń, dodając 'karę' za wyjście poza dopuszczalny obszar)",
        "correct": false
      },
      {
        "text": "metoda najszybszego spadku wymaga obliczania hesjanu",
        "inline_explanation": "(wymaga tylko gradientu; hesjanu wymaga metoda Newtona)",
        "correct": false
      }
    ],
    "explanation": "W optymalizacji rozróżniamy metody gradientowe (najszybszego spadku - tylko gradient; Newtona - gradient i Hesjan) oraz bezgradientowe (np. Neldera-Meada, która operuje na sympleksie - wielościanie w n-wymiarowej przestrzeni, deformując go w stronę minimum)."
  },
  {
    "id": 149,
    "question": "Wybierz poprawne zdania opisujące metody minimalizacji:",
    "options": [
      {
        "text": "wzór Davidona-Fletchera-Powella (DFP) jest podstawą metody zmiennej metryki",
        "inline_explanation": "(metody zmiennej metryki, zwane też quasi-Newtonowskimi, iteracyjnie przybliżają odwrotność hesjanu)",
        "correct": true
      },
      {
        "text": "metoda sprzężonych kierunków jest przykładem ogólnej metody poszukiwania minimum globalnego",
        "inline_explanation": "(jest to metoda poszukiwania minimum lokalnego)",
        "correct": false
      },
      {
        "text": "metoda największego spadku jest przykładem metody poszukiwania minimum globalnego",
        "inline_explanation": "(tylko lokalnego - jeśli funkcja ma wiele dolin, metoda utknie w najbliższej)",
        "correct": false
      },
      {
        "text": "metoda simpleksów należy do metod gradientowych",
        "inline_explanation": "(Neldera-Meada jest bezgradientowa; simpleks w programowaniu liniowym to co innego, ale też nie jest metodą gradientową w sensie analizy matematycznej)",
        "correct": false
      }
    ],
    "explanation": "Większość klasycznych metod optymalizacji (najszybszego spadku, Newtona, sprzężonych gradientów) to metody lokalne - znajdują najbliższe minimum. Metody zmiennej metryki (jak DFP czy popularniejszy BFGS) próbują naśladować metodę Newtona bez kosztownego obliczania hesjanu w każdym kroku."
  },
  {
    "id": 150,
    "question": "Metoda symulowanego wyżarzania (Simulated Annealing):",
    "options": [
      {
        "text": "to rodzina heurystycznych technik optymalizacji opartych na analogii z fizyką statystyczną układów losowych",
        "inline_explanation": "(inspiracją jest proces stygnięcia metalu i formowania struktury krystalicznej o minimalnej energii)",
        "correct": true
      },
      {
        "text": "to jedna z technik optymalizacji kombinatorycznej wykorzystująca metodę Newtona",
        "inline_explanation": "(metoda Newtona wymaga ciągłości i różniczkowalności, nie stosuje się jej w problemach kombinatorycznych)",
        "correct": false
      },
      {
        "text": "to specjalne sformułowanie problemu komiwojażera",
        "inline_explanation": "(może służyć do ROZWIĄZANIA problemu komiwojażera, ale sama w sobie jest metaheurystyką, a nie sformułowaniem problemu)",
        "correct": false
      },
      {
        "text": "to specjalna odmiana algorytmu Metropolisa",
        "inline_explanation": "(algorytm Metropolisa-Hastingsa służy do próbkowania (MCMC); wyżarzanie wykorzystuje kryterium akceptacji Metropolisa, ale jest metodą optymalizacji, a nie próbkowania)",
        "correct": false
      }
    ],
    "explanation": "Symulowane wyżarzanie to metoda probabilistyczna szukania minimum globalnego. Pozwala ona na 'wyskoczenie' z minimum lokalnego poprzez akceptację gorszych rozwiązań z pewnym prawdopodobieństwem (zależnym od 'temperatury', która maleje w czasie)."
  },
  {
    "id": 151,
    "question": "Rozważmy funkcję kwadratową $n$ zmiennych, $f: \\mathbb{R}^n \\to \\mathbb{R}$ daną wzorem $f(\\mathbf{x}) = \\mathbf{x}^T A \\mathbf{x} + \\mathbf{b}^T \\mathbf{x} + c$. Załóżmy, że macierz $A$ jest dodatnio określona (funkcja ma unikalne minimum globalne $x_{min}$). Startujemy z dowolnego punktu $x_0 \\neq x_{min}$.",
    "options": [
      {
        "text": "metoda Newtona gwarantuje znalezienie minimum funkcji $f$ w pierwszym kroku",
        "inline_explanation": "(metoda Newtona przybliża funkcję wielomianem kwadratowym; ponieważ ta funkcja JEST kwadratowa, przybliżenie jest idealne i metoda trafia w cel od razu)",
        "correct": true
      },
      {
        "text": "metoda najszybszego spadku gwarantuje znalezienie minimum funkcji $f$ w pierwszym kroku",
        "inline_explanation": "(metoda ta zbiega powoli, często 'zygzakując' do rozwiązania)",
        "correct": false
      },
      {
        "text": "metoda simpleksu Neldera-Meada gwarantuje znalezienie minimum funkcji $f$ w pierwszym kroku",
        "inline_explanation": "(metoda ta wymaga wielu iteracji, by dopasować sympleks do minimum)",
        "correct": false
      },
      {
        "text": "żadne z pozostałych",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Metoda Newtona szuka minimum funkcji $f(x)$ znajdując zero jej gradientu $\nabla f(x) = 0$. Wzór iteracyjny to $x_{new} = x_{old} - [H f(x_{old})]^{-1} \nabla f(x_{old})$. Dla funkcji kwadratowej gradient jest liniowy, a hesjan stały ($H=2A$). Podstawienie tych wartości do wzoru prowadzi bezpośrednio do rozwiązania układu równań liniowych, dając wynik w jednej iteracji."
  },
  {
    "id": 152,
    "question": "Podejście wariacyjne do rozwiązywania równań różniczkowych:",
    "options": [
      {
        "text": "polega na tym, że szukamy funkcji minimalizującej odpowiedni funkcjonał",
        "inline_explanation": "(zamiast rozwiązywać równanie różniczkowe wprost, szukamy funkcji, dla której pewna całka (funkcjonał energii) osiąga minimum)",
        "correct": true
      },
      {
        "text": "nie nadaje się do obliczeń numerycznych",
        "inline_explanation": "(jest podstawą Metody Elementów Skończonych - MES/FEM, która jest potężnym narzędziem numerycznym)",
        "correct": false
      },
      {
        "text": "polega na wprowadzeniu specjalnej siatki całkowania",
        "inline_explanation": "(to domena metod różnic skończonych)",
        "correct": false
      },
      {
        "text": "polega na uzmiennieniu położeń części punktów siatki",
        "inline_explanation": "(to techniki adaptacji siatki, a nie definicja podejścia wariacyjnego)",
        "correct": false
      }
    ],
    "explanation": "Rachunek wariacyjny zamienia problem brzegowy (równanie różniczkowe) na problem minimalizacji funkcjonału. Jest to fundament Metody Elementów Skończonych."
  },
  {
    "id": 153,
    "question": "Wymagania stawiane schematom rozwiązywania numerycznego zagadnienia początkowego to:",
    "options": [
      {
        "text": "zgodność aproksymacji różnicowej, dokładność, stabilność, efektywność czasowa i pamięciowa",
        "inline_explanation": "(kompletny zestaw cech dobrego algorytmu numerycznego)",
        "correct": true
      },
      {
        "text": "współczynnik propagacji błędu < 1, zgodność aproksymacji różnicowej",
        "inline_explanation": "(współczynnik < 1 gwarantuje stabilność, a zgodność (consistency) oznacza, że schemat dąży do rzeczywistego równania, gdy krok dąży do 0)",
        "correct": true
      },
      {
        "text": "jawne uwzględnienie warunków brzegowych",
        "inline_explanation": "(w zagadnieniu początkowym mamy warunek początkowy, brzegowe są w BVP)",
        "correct": false
      },
      {
        "text": "wprowadzenie siatki przestrzennej zgodnej z siatką czasowa",
        "inline_explanation": "(siatki te są zazwyczaj niezależne, choć krok czasowy może być ograniczony przez krok przestrzenny ze względu na stabilność - warunek CFL)",
        "correct": false
      }
    ],
    "explanation": "Podstawowe twierdzenie (Laxa) mówi, że dla liniowych zagadnień początkowych: Zgodność + Stabilność = Zbieżność. Stabilność (często wyrażana warunkiem na współczynnik wzmocnienia/propagacji błędu $\\le 1$) jest kluczowa, by błędy zaokrągleń nie eksplodowały w czasie."
  },
  {
    "id": 154,
    "question": "Metoda Cranka-Nicolsona to:",
    "options": [
      {
        "text": "numeryczny sposób rozwiązywania równań różniczkowych parabolicznych",
        "inline_explanation": "(jest to schemat niejawny, bezwarunkowo stabilny, powszechnie używany np. do równania przewodnictwa ciepła)",
        "correct": true
      },
      {
        "text": "technika poszukiwania minimum lokalnego z uwzględnieniem drugich pochodnych",
        "inline_explanation": "(to opis metod optymalizacji typu Newtona)",
        "correct": false
      },
      {
        "text": "technika wyszukiwania miejsc zerowych wielomianów",
        "inline_explanation": "(to np. metoda Newtona-Hornera)",
        "correct": false
      },
      {
        "text": "numeryczny sposób rozwiązywania równań różniczkowych eliptycznych",
        "inline_explanation": "(równania eliptyczne rozwiązuje się zazwyczaj metodami relaksacyjnymi lub bezpośrednimi dla układów równań, Crank-Nicolson dotyczy ewolucji w czasie)",
        "correct": false
      }
    ],
    "explanation": "Metoda Cranka-Nicolsona to metoda różnic skończonych służąca do rozwiązywania równań różniczkowych cząstkowych typu parabolicznego (np. dyfuzji ciepła). Jest to średnia arytmetyczna metody jawnej i niejawnej Eulera, co zapewnia jej zbieżność drugiego rzędu w czasie i przestrzeni."
  },
  {
    "id": 155,
    "question": "Wybierz, które z poniższych stwierdzeń dotyczących języków formalnych są prawdziwe:",
    "options": [
      {
        "text": "autorem klasyfikacji (hierarchii) języków formalnych jest Noam Chomsky",
        "inline_explanation": "(zaproponował on podział na 4 klasy: języki regularne, bezkontekstowe, kontekstowe i rekurencyjnie przeliczalne)",
        "correct": true
      },
      {
        "text": "zbiór wszystkich palindromów nad danym alfabetem jest językiem regularnym",
        "inline_explanation": "(jest to klasyczny przykład języka bezkontekstowego, którego nie da się rozpoznać automatem skończonym bez stosu)",
        "correct": false
      },
      {
        "text": "istnieją języki, które nie należą do hierarchii Chomsky'ego, więc nie są generowane przez żadną gramatykę ani akceptowane przez żaden automat",
        "inline_explanation": "(hierarchia Chomsky'ego obejmuje języki formalne; języki naturalne często wymykają się tym regułom, istnieją też problemy nierozstrzygalne)",
        "correct": true
      },
      {
        "text": "językiem formalnym nazywamy dowolny podzbiór zbioru wszystkich możliwych słów zbudowanych z symboli należących do skończonego alfabetu",
        "inline_explanation": "(definicja języka formalnego: $L \\subseteq \\Sigma^*$)",
        "correct": true
      },
      {
        "text": "język oznaczany jako $\\{ \\varepsilon \\}$ jest językiem pustym",
        "inline_explanation": "(nie, to język jednoelementowy zawierający słowo puste; język pusty to $\\emptyset$, który ma 0 elementów)",
        "correct": false
      },
      {
        "text": "najszerszą klasą języków w hierarchii Chomsky'ego jest klasa języków rekurencyjnie przeliczalnych generowanych przez gramatyki bez ograniczeń",
        "inline_explanation": "(Typ 0 - języki rozpoznawane przez Maszynę Turinga)",
        "correct": true
      },
      {
        "text": "jeżeli $L$ jest językiem bezkontekstowym, to istnieje automat ze stosem akceptujący ten język i jest on mu równoważny",
        "inline_explanation": "(automaty ze stosem (PDA) są odpowiednikami gramatyk bezkontekstowych)",
        "correct": true
      }
    ],
    "explanation": "Hierarchia Chomsky'ego porządkuje języki od najprostszych do najbardziej złożonych: Regularne (Typ 3, automaty skończone) $\\subset$ Bezkontekstowe (Typ 2, automaty ze stosem) $\\subset$ Kontekstowe (Typ 1, automaty liniowo ograniczone) $\\subset$ Rekurencyjnie przeliczalne (Typ 0, Maszyny Turinga). Warto pamiętać, że $\\{ \\varepsilon \\} \\neq \\emptyset$."
  },
  {
    "id": 156,
    "question": "Niech $N$ będzie niedeterministycznym automatem skończonym (NFA) posiadającym $n$ stanów, oraz niech $M$ będzie minimalnym deterministycznym automatem skończonym (DFA) rozpoznającym ten sam język, posiadającym $m$ stanów. Wtedy:",
    "options": [
      {
        "text": "$m \\le n$",
        "inline_explanation": "(zazwyczaj DFA ma więcej stanów niż odpowiadający mu NFA)",
        "correct": false
      },
      {
        "text": "$m \\le 2^n$",
        "inline_explanation": "(algorytm konstrukcji podzbiorowej tworzy stany DFA jako podzbiory stanów NFA; zbiór $n$-elementowy ma $2^n$ podzbiorów)",
        "correct": true
      },
      {
        "text": "$n \\le m$",
        "inline_explanation": "(choć zazwyczaj tak jest, nie jest to reguła matematyczna zawsze prawdziwa - istnieją przypadki, gdzie $n=m$)",
        "correct": false
      },
      {
        "text": "$M$ posiada dokładnie jeden stan akceptujący",
        "inline_explanation": "(może mieć ich dowolną liczbę)",
        "correct": false
      },
      {
        "text": "każdy deterministyczny automat skończony rozpoznający ten sam język musi posiadać co najmniej $2^n$ stanów",
        "inline_explanation": "(nie każdy, tylko w najgorszym przypadku pesymistycznym)",
        "correct": false
      },
      {
        "text": "każdy automat deterministyczny akceptujący ten sam język co $N$ musi mieć co najwyżej $2^n$ stanów",
        "inline_explanation": "(nie każdy - możemy stworzyć DFA z milionem nieosiągalnych stanów; ograniczenie $2^n$ dotyczy konstrukcji minimalnej/podzbiorowej)",
        "correct": false
      }
    ],
    "explanation": "Jest to pytanie o relację między NFA a DFA. Algorytm determinizacji (subset construction) w najgorszym przypadku generuje wykładniczą liczbę stanów ($2^n$), ponieważ każdy stan w DFA reprezentuje zbiór stanów, w których mógłby znajdować się NFA."
  },
  {
    "id": 157,
    "question": "Wybierz, które z poniższych stwierdzeń dotyczących własności języków regularnych są prawdziwe:",
    "options": [
      {
        "text": "jeśli język $L$ spełnia tezę lematu o pompowaniu dla języków regularnych, to język $L$ jest regularny",
        "inline_explanation": "(lemat o pompowaniu to warunek konieczny, ale nie wystarczający; istnieją języki nieregularne, które spełniają warunki lematu)",
        "correct": false
      },
      {
        "text": "jeśli język $L$ jest skończony, to domknięcie Kleene'ego $L^*$ musi być regularne",
        "inline_explanation": "(każdy język skończony jest regularny, a klasa języków regularnych jest zamknięta ze względu na operację gwiazdki)",
        "correct": true
      },
      {
        "text": "każdy język, który nie jest regularny, jest nieskończony",
        "inline_explanation": "(jest to wniosek z faktu, że każdy język skończony JEST regularny)",
        "correct": true
      },
      {
        "text": "pomimo, że języki regularne w trywialny sposób są bezkontekstowe, to istnieją języki regularne nie spełniające lematu o pompowaniu dla języków bezkontekstowych",
        "inline_explanation": "(skoro są bezkontekstowe, to muszą spełniać lemat dla bezkontekstowych)",
        "correct": false
      },
      {
        "text": "żeby sprawdzić, czy dany automat akceptuje język nieskończony, można iterując po wszystkich słowach złożonych z alfabetu sprawdzić, czy liczba słów przez niego akceptowanych jest nieskończona",
        "inline_explanation": "(nie da się wykonać nieskończonej liczby iteracji w skończonym czasie)",
        "correct": false
      },
      {
        "text": "zupełny deterministyczny automat skończony, który nie akceptuje żadnego słowa, nie ma osiągalnych stanów akceptujących",
        "inline_explanation": "(gdyby miał osiągalny stan akceptujący, musiałby akceptować przynajmniej jedno słowo prowadzące do tego stanu)",
        "correct": true
      }
    ],
    "explanation": "Kluczowe własności: 1. Każdy język skończony jest regularny. 2. Języki regularne są zamknięte na sumę, iloczyn, dopełnienie i gwiazdkę Kleene'a. 3. Lemat o pompowaniu służy głównie do udowadniania, że język NIE JEST regularny (przez sprzeczność)."
  },
  {
    "id": 158,
    "question": "Dla języków i gramatyk formalnych, odnośnie postaci normalnej Chomsky'ego (CNF) oraz postaci normalnej Greibach (GNF) można sformułować następujące stwierdzenia:",
    "options": [
      {
        "text": "gramatyka w CNF zawiera produkcje postaci $A \\to BC$, $A \\to a$, a gramatyka w GNF produkcje postaci $A \\to aX$, oraz każdą gramatykę bezkontekstową w CNF można przekształcić do GNF",
        "inline_explanation": "(definicje postaci są poprawne, a algorytm zamiany CNF na GNF jest standardową procedurą)",
        "correct": true
      },
      {
        "text": "dla dowolnej gramatyki bezkontekstowej $G$ istnieje taka gramatyka bezkontekstowa $G'$ będąca w postaci normalnej Chomsky'ego, że $L(G') = L(G) \\setminus \\{\\varepsilon\\}$",
        "inline_explanation": "(standardowe postacie normalne nie obsługują generowania słowa pustego $\\varepsilon$, więc usuwa się je z języka przy konwersji)",
        "correct": true
      },
      {
        "text": "dla każdego języka bezkontekstowego istnieje gramatyka w postaci normalnej Chomsky'ego",
        "inline_explanation": "(nie dla każdego, bo jeśli język zawiera $\\varepsilon$, to ścisła postać Chomsky'ego go nie wygeneruje - potrzebne jest wykluczenie $\\varepsilon$)",
        "correct": false
      },
      {
        "text": "każdą gramatykę bezkontekstową można przekształcić do postaci normalnej Chomsky'ego",
        "inline_explanation": "(podobnie jak wyżej - problematyczne są produkcje generujące słowo puste)",
        "correct": false
      },
      {
        "text": "każdą gramatykę bezkontekstową można przekształcić do postaci normalnej Greibach",
        "inline_explanation": "(wymaga usunięcia lewostronnej rekurencji i $\\varepsilon$-produkcji)",
        "correct": false
      }
    ],
    "explanation": "Postać Normalna Chomsky'ego (CNF) dopuszcza tylko produkcje rozwijające nieterminal na dwa nieterminale ($A \\to BC$) lub jeden terminal ($A \\to a$). Postać Normalna Greibach (GNF) wymaga, by każda produkcja zaczynała się od terminala ($A \\to a...$). Obie postacie są kluczowe dla algorytmów parsingu (np. algorytm CYK dla CNF), ale w swoich ścisłych definicjach nie pozwalają na generowanie słowa pustego $\\varepsilon$."
  },
  {
    "id": 159,
    "question": "Odnośnie lematu o pompowaniu dla języków regularnych prawdziwe są następujące stwierdzenia:",
    "options": [
      {
        "text": "lemat służy pokazaniu, że określone języki są regularne",
        "inline_explanation": "(lemat jest warunkiem koniecznym, a nie wystarczającym; spełnienie lematu nie gwarantuje regularności)",
        "correct": false
      },
      {
        "text": "schemat postępowania jest następujący: skoro język posiada pewne własności regularności, to jest regularny",
        "inline_explanation": "(błąd logiczny - wnioskowanie odwrotne)",
        "correct": false
      },
      {
        "text": "lemat służy do dowodzenia, że dany język nie jest językiem regularnym",
        "inline_explanation": "(stosuje się dowód nie wprost: zakładamy, że język jest regularny, pokazujemy, że nie spełnia lematu, więc mamy sprzeczność)",
        "correct": true
      },
      {
        "text": "lemat służy do dowodzenia, że dany język jest językiem regularnym",
        "inline_explanation": "(do dowodzenia, że jest regularny, wystarczy skonstruować automat lub wyrażenie regularne)",
        "correct": false
      }
    ],
    "explanation": "Lemat o pompowaniu dla języków regularnych mówi, że każde dostatecznie długie słowo w języku regularnym można 'napompować' (powielić jego środkową część) i wciąż pozostać w języku. Jeśli znajdziemy choć jedno słowo, którego nie da się napompować, udowadniamy, że język NIE jest regularny."
  },
  {
    "id": 160,
    "question": "Jeżeli $r$ oraz $s$ są wyrażeniami regularnymi dla języków odpowiednio $R$ oraz $S$, to $(r + s)$, $rs$ oraz $r^*$ są wyrażeniami regularnymi reprezentującymi odpowiednio zbiory:",
    "options": [
      {
        "text": "$R \\cup S$, $R \\times S$, $R^+$",
        "inline_explanation": "($R \\times S$ to iloczyn kartezjański, czyli zbiór par, a nie słów; $R^+$ to domknięcie dodatnie, bez słowa pustego)",
        "correct": false
      },
      {
        "text": "$R \\cup S$, $R \\times S$, $R^*$",
        "inline_explanation": "($R \\times S$ jest błędne w kontekście konkatenacji napisów)",
        "correct": false
      },
      {
        "text": "$R \\cup S$, $RS$ i $R^*$",
        "inline_explanation": "(Suma zbiorów, Konkatenacja języków, Domknięcie Kleene'ego)",
        "correct": true
      },
      {
        "text": "$R \\cup S$, $RS$ i $R^+$",
        "inline_explanation": "($r^*$ z definicji zawiera słowo puste $\\varepsilon$, czego $R^+$ zazwyczaj nie gwarantuje)",
        "correct": false
      }
    ],
    "explanation": "Operatory wyrażeń regularnych mają ścisłe odpowiedniki w teorii mnogości na językach: '+' to suma zbiorów ($L_1 \\cup L_2$), zapis obok siebie to złączenie (konkatenacja) języków ($L_1 L_2 = \\{xy | x \\in L_1, y \\in L_2\\}$), a gwiazdka to gwiazdka Kleene'ego (wielokrotne złączenie, w tym 0 razy)."
  },
  {
    "id": 161,
    "question": "Mamy języki $L_1 = \\{a^{2^n}, n > 0\\}$ oraz $L_2 = \\{a^{2n}, n > 0\\}$. Które z tych języków są regularne?",
    "options": [
      {
        "text": "$L_1$ - nie, $L_2$ - nie",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "$L_1$ - tak, $L_2$ - nie",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "$L_1$ - nie, $L_2$ - tak",
        "inline_explanation": "($L_1$ rośnie wykładniczo, luki między słowami są zbyt duże dla automatu skończonego; $L_2$ to po prostu parzysta liczba liter 'a', co łatwo zliczyć automatem)",
        "correct": true
      },
      {
        "text": "$L_1$ - tak, $L_2$ - tak",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Język $L_2$ zawiera słowa o parzystej długości ($aa, aaaa, \\dots$). Można go opisać wyrażeniem regularnym $(aa)^+$. Język $L_1$ zawiera słowa o długościach będących potęgami dwójki ($aa, aaaa, aaaaaaaa, \\dots$). Odległości między kolejnymi długościami rosną w nieskończoność, więc automat skończony nie jest w stanie ich 'zapamiętać'. Dowodzi się tego lematem o pompowaniu."
  },
  {
    "id": 162,
    "question": "Eliminując niejednoznaczność gramatyki poprzez konwersję do innej gramatyki musimy zachować bez zmian:",
    "options": [
      {
        "text": "zbiór słów generowanych przez oryginalną gramatykę",
        "inline_explanation": "(to definicja równoważności gramatyk – muszą generować ten sam język $L(G)$)",
        "correct": true
      },
      {
        "text": "drzewo wyprowadzenia oryginalnej gramatyki dla każdego jednoznacznego słowa wejściowego",
        "inline_explanation": "(zmiana struktury gramatyki zazwyczaj zmienia kształt drzewa wyprowadzenia)",
        "correct": false
      },
      {
        "text": "wyprowadzenia oryginalnej gramatyki dla każdego słowa wejściowego",
        "inline_explanation": "(wyprowadzenie to ciąg produkcji; skoro zmieniamy gramatykę, to produkcje i wyprowadzenia muszą się zmienić)",
        "correct": false
      },
      {
        "text": "drzewo wyprowadzenia oryginalnej gramatyki dla każdego słowa wejściowego",
        "inline_explanation": "(jak wyżej – struktura drzewa ulega zmianie)",
        "correct": false
      }
    ],
    "explanation": "Gramatyka jest niejednoznaczna, jeśli dla pewnego słowa istnieje więcej niż jedno drzewo wywodu. Przekształcając ją w gramatykę jednoznaczną, zmieniamy jej strukturę (produkcje), a co za tym idzie – drzewa wywodu. Kluczowe jest jednak to, aby nowa gramatyka generowała dokładnie ten sam zbiór słów (język) co gramatyka pierwotna."
  },
  {
    "id": 163,
    "question": "Która z następujących metod parsingu może przetworzyć najszerszą klasę gramatyk (w tym gramatyki niejednoznaczne):",
    "options": [
      {
        "text": "parser Earleya",
        "inline_explanation": "(uniwersalny algorytm dla wszystkich gramatyk bezkontekstowych, także niejednoznacznych)",
        "correct": true
      },
      {
        "text": "parser CYK (Cocke-Younger-Kasami)",
        "inline_explanation": "(również uniwersalny dla wszystkich gramatyk bezkontekstowych, wymaga postaci normalnej Chomsky'ego)",
        "correct": true
      },
      {
        "text": "parser SLR",
        "inline_explanation": "(prosty LR - podzbiór gramatyk deterministycznych)",
        "correct": false
      },
      {
        "text": "parser LL(1)",
        "inline_explanation": "(gramatyki parsowalne z góry na dół z podglądem 1 znaku - wąska klasa)",
        "correct": false
      },
      {
        "text": "kanoniczny parser LR",
        "inline_explanation": "(najszersza klasa metod deterministycznych, ale nie obsługuje gramatyk niejednoznacznych)",
        "correct": false
      },
      {
        "text": "zstępujący parser rekurencyjny bez nawracania",
        "inline_explanation": "(odpowiednik LL)",
        "correct": false
      }
    ],
    "explanation": "Parsery LL i LR (w tym SLR, LALR) obsługują tylko deterministyczne gramatyki bezkontekstowe. Parsery Earleya i CYK są algorytmami ogólnymi (złożoność $O(n^3)$), które radzą sobie z każdą gramatyką bezkontekstową, włączając w to gramatyki niejednoznaczne."
  },
  {
    "id": 164,
    "question": "Wybierz stwierdzenia dotyczące porównania metod LL i LR, które są prawdziwe:",
    "options": [
      {
        "text": "gramatyki parsowane przez LR są nadzbiorem właściwym gramatyk parsowanych przez LL",
        "inline_explanation": "(każda gramatyka LL jest LR, ale nie odwrotnie; LR radzi sobie z lewostronną rekursją, LL nie)",
        "correct": true
      },
      {
        "text": "żadna gramatyka niejednoznaczna nie może być gramatyką LR(1)",
        "inline_explanation": "(deterministyczne parsery LR nie mogą mieć konfliktów shift/reduce lub reduce/reduce, a niejednoznaczność zawsze generuje konflikty)",
        "correct": true
      },
      {
        "text": "LR wymaga usunięcia lewostronnej rekursji",
        "inline_explanation": "(to LL wymaga usunięcia lewostronnej rekursji; LR radzi sobie z nią doskonale)",
        "correct": false
      },
      {
        "text": "LL wymaga na początku faktoryzacji lewostronnej",
        "inline_explanation": "(jest to często prawda dla LL, ale w kontekście tego pytania kluczowe były odpowiedzi o relacji zbiorów i jednoznaczności)",
        "correct": false
      },
      {
        "text": "LR parsuje od prawej do lewej, LL od lewej do prawej",
        "inline_explanation": "(obie metody czytają wejście od lewej do prawej; różnica jest w budowie drzewa: LL - lewostronne wyprowadzenie, LR - prawostronne)",
        "correct": false
      },
      {
        "text": "dla każdej gramatyki jednoznacznej można skonstruować parser LR(1)",
        "inline_explanation": "(nie dla każdej; istnieją gramatyki jednoznaczne, które nie są LR(1))",
        "correct": false
      }
    ],
    "explanation": "Metody LR są silniejsze od LL. Klasa języków LL jest właściwym podzbiorem języków LR. Jednym z głównych powodów jest to, że parser LR decyduje o redukcji dopiero po zobaczeniu całej prawej strony produkcji, podczas gdy LL musi przewidzieć produkcję widząc tylko pierwszy symbol."
  },
  {
    "id": 165,
    "question": "Wybierz stwierdzenia dotyczące gramatyk i konstruowania parserów, które są prawdziwe:",
    "options": [
      {
        "text": "żadna gramatyka niejednoznaczna nie może być gramatyką LR(1)",
        "inline_explanation": "(niejednoznaczność implikuje konflikty w tabeli parsingu)",
        "correct": true
      },
      {
        "text": "konstruując parser dla gramatyki niejednoznacznej i usuwając konflikty uzyskujemy bardziej efektywne rozwiązania, niż opierając parser na równoważnej gramatyce jednoznacznej",
        "inline_explanation": "(częsta praktyka, np. w yacc/bison: gramatyka wyrażeń arytmetycznych jest naturalnie niejednoznaczna, ale krótsza; konflikty rozwiązuje się regułami priorytetów operatorów)",
        "correct": true
      },
      {
        "text": "dla każdej gramatyki jednoznacznej można skonstruować parser LR(1)",
        "inline_explanation": "(fałsz, istnieją gramatyki jednoznaczne niebędące LR(1))",
        "correct": false
      },
      {
        "text": "tworzenie parsera jest sensowną procedurą tylko dla jednoznacznej gramatyki bezkontekstowej",
        "inline_explanation": "(można tworzyć parsery dla gramatyk niejednoznacznych, stosując dodatkowe reguły rozstrzygania konfliktów)",
        "correct": false
      }
    ],
    "explanation": "Przekształcenie gramatyki niejednoznacznej do jednoznacznej często powoduje drastyczny wzrost liczby produkcji i stanów parsera. Dlatego w praktyce inżynierskiej często używa się gramatyk niejednoznacznych (np. dla if-else czy operatorów matematycznych) i steruje się zachowaniem parsera poprzez priorytety i łączność."
  },
  {
    "id": 166,
    "question": "Typowy skaner (lekser) języka formalnego ma za zadanie:",
    "options": [
      {
        "text": "wyodrębnić symbole leksykalne (tokeny)",
        "inline_explanation": "(główne zadanie: grupowanie znaków w jednostki znaczące)",
        "correct": true
      },
      {
        "text": "wczytać kod źródłowy programu do postaci tokenów",
        "inline_explanation": "(konwersja strumienia znaków na strumień tokenów)",
        "correct": true
      },
      {
        "text": "zliczyć słowa kluczowe i sprawdzić ich kolokacje",
        "inline_explanation": "(skaner rozpoznaje słowa kluczowe, ale sprawdzanie ich poprawnego użycia w kontekście/kolokacji to zadanie parsera)",
        "correct": false
      },
      {
        "text": "zliczyć lewe i prawe nawiasy sprawdzając wstępnie ich sparowanie",
        "inline_explanation": "(skaner widzi nawiasy jako osobne tokeny, ich parowanie sprawdza parser)",
        "correct": false
      }
    ],
    "explanation": "Skaner (analizator leksykalny) to pierwsza faza kompilacji. Czyta plik znak po znaku, usuwa białe znaki i komentarze, a następnie grupuje znaki w leksemy i zwraca tokeny (np. IDENTIFIER, NUMBER, IF, PLUS) do parsera."
  },
  {
    "id": 167,
    "question": "Typowy parser (analizator składniowy) języka formalnego ma za zadanie:",
    "options": [
      {
        "text": "dokonać rozbioru gramatycznego ciągu tokenów i zbudować drzewo rozbioru (AST)",
        "inline_explanation": "(analiza struktury gramatycznej zgodnie z regułami gramatyki)",
        "correct": true
      },
      {
        "text": "wykonać kontrolę typów (analizę semantyczną)",
        "inline_explanation": "(opcjonalnie może być zintegrowane, ale formalnie to oddzielny etap następujący po parsingu)",
        "correct": true
      },
      {
        "text": "usunąć komentarze zagnieżdżone w innych komentarzach",
        "inline_explanation": "(obsługa komentarzy to zadanie skanera/leksera, parser ich nawet nie widzi)",
        "correct": false
      },
      {
        "text": "zamienić kod źródłowy na ciąg tokenów",
        "inline_explanation": "(to zadanie skanera)",
        "correct": false
      }
    ],
    "explanation": "Parser otrzymuje tokeny od skanera i sprawdza, czy tworzą one poprawne zdania w danym języku (zgodnie z gramatyką). Wynikiem jego pracy jest zazwyczaj Drzewo Składniowe (Abstract Syntax Tree - AST)."
  },
  {
    "id": 168,
    "question": "W odniesieniu do pracy parserów klasy LR(k) i funkcji action prawdziwe są stwierdzenia:",
    "options": [
      {
        "text": "funkcja action przyjmuje wartości ze zbioru {shift, reduce, accept, error}",
        "inline_explanation": "(określa akcję dla pary: [stan na wierzchołku stosu, nadchodzący symbol terminalny])",
        "correct": true
      },
      {
        "text": "funkcja action przyjmuje wartości ze zbioru {shift, reduce, goto, accept, error}",
        "inline_explanation": "(GOTO jest osobną tabelą/funkcją obsługującą przejścia dla symboli nieterminalnych po redukcji)",
        "correct": false
      },
      {
        "text": "na stosie trzymane są prefiksy i sufiksy form zdaniowych",
        "inline_explanation": "(na stosie są tylko prefiksy form zdaniowych, tzw. viable prefixes)",
        "correct": false
      },
      {
        "text": "na stosie trzymane są prefiksy wszystkich form zdaniowych",
        "inline_explanation": "(tylko te, które mogą prowadzić do akceptacji, czyli viable prefixes)",
        "correct": false
      }
    ],
    "explanation": "Parser LR wykorzystuje dwie tabele: ACTION (określa, co zrobić widząc terminal: przesunąć (shift), zredukować (reduce), zaakceptować czy zgłosić błąd) oraz GOTO (określa, do jakiego stanu przejść po wykonaniu redukcji do nieterminala)."
  },
  {
    "id": 169,
    "question": "Budowa tablic sterujących dla analizatorów klasy LR może stwarzać pewne trudności, szczególnie w zakresie automatyzacji, co ma pośredni wpływ na istnienie wielu odmian tych parserów. Które z poniższych stwierdzeń są prawdziwe:",
    "options": [
      {
        "text": "pierwsza litera w nazwie SLR oznacza Shift",
        "inline_explanation": "(oznacza Simple - najprostszy wariant)",
        "correct": false
      },
      {
        "text": "pierwsza litera w nazwie SLR oznacza Simple",
        "inline_explanation": "(Simple LR - metoda wykorzystująca zbiory FOLLOW do rozwiązywania konfliktów w automacie LR(0))",
        "correct": true
      },
      {
        "text": "pierwsze litery w nazwie LALR oznaczają LookAhead",
        "inline_explanation": "(Look-Ahead LR - metoda scalająca stany o tych samych jądrach, zachowująca informację o podglądzie)",
        "correct": true
      },
      {
        "text": "pierwsza litera w nazwie GLR oznacza Grammar",
        "inline_explanation": "(oznacza Generalized LR - parser dla gramatyk niedeterministycznych i niejednoznacznych)",
        "correct": false
      }
    ],
    "explanation": "Wyróżniamy kluczowe warianty parserów LR:\n1. SLR(1) (Simple LR) - najprostszy, małe tablice, ale obsługuje najmniej gramatyk.\n2. LALR(1) (Look-Ahead LR) - 'złoty środek', ma tablice rozmiaru SLR, ale obsługuje znacznie szerszą klasę gramatyk (większość języków programowania). Jest to właściwy nadzbiór SLR(1).\n3. LR(1) (Canonical LR) - najsilniejszy z deterministycznych, ale generuje gigantyczne tablice, co bywa niepraktyczne."
  },
  {
    "id": 170,
    "question": "Porównując gramatyki klasy LL i LR można powiedzieć, że:",
    "options": [
      {
        "text": "gramatyki LL opisują szerszą klasę niż LR",
        "inline_explanation": "(jest odwrotnie, LL to węższa klasa)",
        "correct": false
      },
      {
        "text": "gramatyki LR opisują szerszą klasę niż LL",
        "inline_explanation": "(gramatyki LR(k) są właściwym nadzbiorem gramatyk LL(k))",
        "correct": true
      },
      {
        "text": "każda gramatyka LL jest również gramatyką LR",
        "inline_explanation": "(jeśli da się coś sparsować metodą zstępującą (LL), da się też wstępującą (LR))",
        "correct": true
      },
      {
        "text": "każda gramatyka LR jest również gramatyką LL",
        "inline_explanation": "(fałsz, np. gramatyki z lewostronną rekursją są LR, ale nie są LL)",
        "correct": false
      }
    ],
    "explanation": "Relacja jest jednoznaczna: $LL(k) \\subset LR(k)$. Parser LR jest silniejszy, ponieważ podejmuje decyzję o redukcji dopiero po zobaczeniu całej prawej strony produkcji, podczas gdy parser LL musi 'zgadywać' (predykcja) produkcję widząc tylko pierwszy symbol (lub k symboli). Dlatego LR radzi sobie z lewostronną rekursją i większą liczbą struktur językowych."
  },
  {
    "id": 171,
    "question": "Korzystając z układu FPGA (Field-Programmable Gate Array) można wykonać:",
    "options": [
      {
        "text": "na przykład dowolny układ kombinacyjny, ograniczony jedynie wielkością struktury FPGA",
        "inline_explanation": "(układy FPGA składają się z bloków logicznych (LUT), które mogą realizować dowolną funkcję logiczną)",
        "correct": true
      },
      {
        "text": "na przykład dowolny układ sekwencyjny, ograniczony jedynie wielkością struktury FPGA",
        "inline_explanation": "(dzięki wbudowanym przerzutnikom (flip-flops) i pamięci, FPGA świetnie nadają się do budowy maszyn stanów i procesorów)",
        "correct": true
      },
      {
        "text": "wyłącznie układy niewymagające sygnału zegarowego",
        "inline_explanation": "(FPGA posiadają rozbudowane sieci dystrybucji zegara i pętle PLL, są stworzone do pracy synchronicznej)",
        "correct": false
      },
      {
        "text": "układy analogowe o płynnej zmianie napięcia",
        "inline_explanation": "(FPGA to układy cyfrowe; do obsługi sygnałów analogowych potrzebne są zewnętrzne lub wbudowane przetworniki ADC/DAC)",
        "correct": false
      }
    ],
    "explanation": "FPGA to matryca programowalnych bramek logicznych. Ponieważ zawiera zarówno elementy kombinacyjne (tablice LUT), jak i sekwencyjne (rejestry/przerzutniki), można w niej zaimplementować niemal każdy system cyfrowy - od prostego sumatora po skomplikowany mikroprocesor."
  },
  {
    "id": 172,
    "question": "Układ kombinacyjny to:",
    "options": [
      {
        "text": "układ logiczny nie pamiętający stanów poprzednich",
        "inline_explanation": "(brak pamięci to główna cecha odróżniająca go od układów sekwencyjnych)",
        "correct": true
      },
      {
        "text": "układ cyfrowy, w którym stan wyjść zależy wyłącznie od aktualnego stanu wejść",
        "inline_explanation": "(działa jak funkcja matematyczna: $y = f(x)$)",
        "correct": true
      },
      {
        "text": "układ, w którego skład mogą wchodzić bramki logiczne w połączeniu z przerzutnikami JK",
        "inline_explanation": "(przerzutniki JK są elementami pamięciowymi, więc ich użycie tworzy układ sekwencyjny)",
        "correct": false
      },
      {
        "text": "układ wymagający sygnału zegarowego do synchronizacji wyjść",
        "inline_explanation": "(układy czysto kombinacyjne działają asynchronicznie – zmiana wejścia natychmiast (po czasie propagacji) zmienia wyjście)",
        "correct": false
      }
    ],
    "explanation": "Układ kombinacyjny to taki, w którym każda kombinacja sygnałów wejściowych jednoznacznie określa kombinację sygnałów wyjściowych. Innymi słowy działa deterministycznie na podstawie 'tu i teraz', nie posiadając historii. Przykłady: multiplekser, dekoder, sumator, komparator."
  },
  {
    "id": 173,
    "question": "Układ sekwencyjny to:",
    "options": [
      {
        "text": "może składać się z samych bramek logicznych",
        "inline_explanation": "(tak, pod warunkiem występowania sprzężeń zwrotnych (pętli), które tworzą zatrzaski/latche pamiętające stan)",
        "correct": true
      },
      {
        "text": "w skład jego mogą wchodzić bramki logiczne w połączeniu z przerzutnikami (np. JK, D)",
        "inline_explanation": "(to klasyczna konstrukcja automatu: logika kombinacyjna + rejestr stanu)",
        "correct": true
      },
      {
        "text": "układ logiczny nie pamiętający stanów poprzednich",
        "inline_explanation": "(definicja układu sekwencyjnego zakłada zależność od stanu poprzedniego/pamięci)",
        "correct": false
      },
      {
        "text": "może składać się z samych bramek logicznych bez sprzężeń zwrotnych",
        "inline_explanation": "(bez pętli sprzężenia zwrotnego bramki tworzą tylko układ kombinacyjny - nie ma jak podtrzymać stanu)",
        "correct": false
      }
    ],
    "explanation": "Układ sekwencyjny to układ z pamięcią. Wyjście zależy nie tylko od wejścia, ale także od poprzednich stanów (historii). Aby zrealizować pamięć na bramkach logicznych, konieczne jest zastosowanie sprzężenia zwrotnego (feedback)."
  },
  {
    "id": 174,
    "question": "Przykłady układów sekwencyjnych to:",
    "options": [
      {
        "text": "licznik dwukierunkowy oraz rejestr przesuwający",
        "inline_explanation": "(oba wymagają pamiętania aktualnej wartości/bitów i zmieniają się w takt zegara)",
        "correct": true
      },
      {
        "text": "multiplekser oraz transkoder",
        "inline_explanation": "(to klasyczne układy kombinacyjne - działają natychmiastowo na podstawie wejść)",
        "correct": false
      },
      {
        "text": "rejestr przesuwający szeregowy oraz dekoder",
        "inline_explanation": "(rejestr jest sekwencyjny, ale dekoder jest kombinacyjny)",
        "correct": false
      },
      {
        "text": "sumator i komparator",
        "inline_explanation": "(układy kombinacyjne arytmetyczne)",
        "correct": false
      }
    ],
    "explanation": "Układy sekwencyjne to te, które 'dzieją się w czasie' lub przechowują dane. Licznik musi pamiętać aktualną liczbę, żeby dodać do niej 1. Rejestr musi pamiętać bity, żeby je przesunąć."
  },
  {
    "id": 175,
    "question": "Pamięć RAM (Random Access Memory):",
    "options": [
      {
        "text": "posiada wejścia adresowe, wejścia sterujące oraz wejście/wyjście danych",
        "inline_explanation": "(standardowy interfejs pamięci: Address Bus, Control Bus (RW/Enable), Data Bus)",
        "correct": true
      },
      {
        "text": "można wykonać z bramek NAND",
        "inline_explanation": "(każdy układ cyfrowy można wykonać z bramek NAND (są funkcjonalnie pełne), a przerzutniki to połączone bramki NAND)",
        "correct": true
      },
      {
        "text": "można wykonać z bramek NAND bez sprzężeń zwrotnych",
        "inline_explanation": "(niemożliwe - aby komórka pamięci 'zapamiętała' bit, wyjście bramki musi wracać na jej wejście (zatrzask))",
        "correct": false
      },
      {
        "text": "służy wyłącznie do przechowywania kodu programu, a nie danych",
        "inline_explanation": "(RAM przechowuje zarówno kod, jak i zmienne/dane)",
        "correct": false
      }
    ],
    "explanation": "Statyczna pamięć RAM (SRAM) budowana jest w oparciu o przerzutniki (bistabilne układy z bramek), natomiast dynamiczna (DRAM) w oparciu o kondensatory. W obu przypadkach interfejs jest podobny (adres, dane, sterowanie). Konstrukcja logiczna SRAM opiera się na sprzężeniach zwrotnych."
  },
  {
    "id": 176,
    "question": "Pamięć RAM dwuportowa (Dual-Port RAM):",
    "options": [
      {
        "text": "to pamięć RAM z dwoma interfejsami, pozwalającymi niezależnie uzyskać dostęp do tych samych komórek pamięci",
        "inline_explanation": "(np. jeden port zapisuje, a drugi w tym samym czasie odczytuje)",
        "correct": true
      },
      {
        "text": "to rodzaj pamięci RAM umożliwiający dwóm niezależnym procesom dostęp do wspólnych danych",
        "inline_explanation": "(często stosowana jako bufor wymiany danych między różnymi systemami lub domenami zegarowymi)",
        "correct": true
      },
      {
        "text": "możemy wykonać z bramek NAND bez sprzężeń zwrotnych",
        "inline_explanation": "(jak każda pamięć statyczna, wymaga sprzężeń)",
        "correct": false
      },
      {
        "text": "w układach FPGA taki rodzaj pamięci nie występuje",
        "inline_explanation": "(występuje powszechnie jako Block RAM, jest to kluczowy element FPGA do budowy np. kolejek FIFO)",
        "correct": false
      },
      {
        "text": "można ją wykorzystać wyłącznie w procesorach wielordzeniowych",
        "inline_explanation": "(ma wiele zastosowań, np. w kartach graficznych, sterownikach DMA, FPGA)",
        "correct": false
      }
    ],
    "explanation": "Pamięć dwuportowa (DPRAM) to specyficzny rodzaj pamięci, która posiada dwa niezależne zestawy linii adresowych, danych i sterujących. Umożliwia to jednoczesny odczyt/zapis z dwóch różnych miejsc (np. procesor i układ wideo) do tej samej przestrzeni adresowej, co znacznie przyspiesza komunikację."
  },
  {
    "id": 177,
    "question": "Procesor (CPU):",
    "options": [
      {
        "text": "to sekwencyjne urządzenie cyfrowe, które pobiera dane z pamięci operacyjnej, interpretuje je i wykonuje jako rozkazy",
        "inline_explanation": "(klasyczna definicja działania procesora w cyklu Fetch-Decode-Execute)",
        "correct": true
      },
      {
        "text": "możemy wykonać przy użyciu FPGA",
        "inline_explanation": "(tzw. soft-processor/soft-core; w FPGA można zaimplementować własną architekturę procesora)",
        "correct": true
      },
      {
        "text": "możemy wykonać przy użyciu FPGA, ale tylko jednordzeniowy",
        "inline_explanation": "(można powielić blok procesora wewnątrz struktury FPGA wielokrotnie, tworząc układ wielordzeniowy)",
        "correct": false
      },
      {
        "text": "tryby adresowania wykonywanego przy użyciu FPGA muszą być zgodne z trybami przewidzianymi przez producenta układu",
        "inline_explanation": "(nie muszą; FPGA daje pełną dowolność w projektowaniu logiki, więc architektura i lista rozkazów zależą tylko od projektanta)",
        "correct": false
      }
    ],
    "explanation": "Procesor to skomplikowany układ sekwencyjny. Jego implementacja w FPGA jest powszechną praktyką (np. procesory Nios w układach Intel/Altera lub MicroBlaze w Xilinx/AMD). Ponieważ FPGA składa się z tysięcy/milionów komórek logicznych, ograniczeniem liczby rdzeni jest tylko pojemność układu, a nie technologia sama w sobie."
  },
  {
    "id": 178,
    "question": "Lista rozkazów procesora (ISA - Instruction Set Architecture):",
    "options": [
      {
        "text": "projektowana jest w zależności od potrzeb związanych z zastosowaniem procesora",
        "inline_explanation": "(np. procesory DSP mają rozbudowane instrukcje mnożenia, a proste mikrokontrolery RISC ograniczoną listę dla oszczędności energii)",
        "correct": true
      },
      {
        "text": "w skład listy rozkazów zawsze wchodzi mnożenie",
        "inline_explanation": "(nie zawsze; proste procesory (np. wczesne 8-bitowe lub proste RISC) realizują mnożenie programowo poprzez wielokrotne dodawanie i przesuwanie)",
        "correct": false
      },
      {
        "text": "musi zawierać rozkazy z różnymi trybami adresowania",
        "inline_explanation": "(jest to wygodne, ale teoretycznie można zbudować procesor z jednym trybem adresowania)",
        "correct": false
      },
      {
        "text": "w procesorze wykonywanym przy użyciu FPGA musi być zgodna z listą rozkazów przewidzianą przez producenta układu FPGA",
        "inline_explanation": "(projektant ma pełną swobodę definicji własnego zestawu instrukcji)",
        "correct": false
      }
    ],
    "explanation": "Lista rozkazów definiuje interfejs między sprzętem a oprogramowaniem. Obejmuje grupy rozkazów: przesłań, sterujące, wejścia/wyjścia oraz arytmetyczno-logiczne. Do tych ostatnich zaliczamy operacje takie jak dodawanie (ADD), odejmowanie (SUB), czy mnożenie (MUL) i dzielenie (DIV) - choć te ostatnie nie zawsze są zaimplementowane sprzętowo. Decyzja o kształcie listy rozkazów (CISC vs RISC) zależy od przeznaczenia układu."
  },
  {
    "id": 179,
    "question": "Karta graficzna (GPU) i technologie graficzne:",
    "options": [
      {
        "text": "prostą wersję karty graficznej (np. kontroler VGA) można zapisać w dwudziestu kilku liniach kodu VHDL/Verilog",
        "inline_explanation": "(jest to w istocie licznik generujący sygnały synchronizacji poziomej i pionowej oraz sterujący kolorami)",
        "correct": true
      },
      {
        "text": "OpenGL to specyfikacja otwartego i uniwersalnego API do tworzenia grafiki",
        "inline_explanation": "(jest to standard programistyczny, a nie sprzęt)",
        "correct": true
      },
      {
        "text": "może być układem kombinacyjnym",
        "inline_explanation": "(musi być układem sekwencyjnym, ponieważ musi przechowywać stan obrazu (bufor ramki) i generować sygnały w czasie)",
        "correct": false
      },
      {
        "text": "przy użyciu FPGA nie można zbudować karty graficznej ze sprzętowym wspomaganiem OpenGL",
        "inline_explanation": "(jest to trudne, ale możliwe; FPGA pozwala na budowę dedykowanych potoków przetwarzania grafiki)",
        "correct": false
      }
    ],
    "explanation": "Karta graficzna to wyspecjalizowany układ sekwencyjny. Najprostszy sterownik VGA to tylko generatory licznikowe. Współczesne GPU to potężne procesory wektorowe. OpenGL to API (interfejs programistyczny), który pozwala programiście wydawać polecenia karcie graficznej niezależnie od jej producenta."
  },
  {
    "id": 180,
    "question": "Licznik rozkazów (PC - Program Counter / IP - Instruction Pointer):",
    "options": [
      {
        "text": "służy do pamiętania adresu mającego się wykonać rozkazu lub adresu aktualnie pobieranego argumentu z pamięci programu",
        "inline_explanation": "(wskazuje na bieżące miejsce w pamięci kodu)",
        "correct": true
      },
      {
        "text": "jest to licznik z wejściem równoległym wykorzystywanym wyłącznie przy skokach bezwarunkowych",
        "inline_explanation": "(jest wykorzystywany w każdym cyklu zegara do inkrementacji adresu, a także przy skokach warunkowych)",
        "correct": false
      },
      {
        "text": "zlicza liczbę cykli zegara od momentu uruchomienia systemu",
        "inline_explanation": "(do tego służą inne liczniki, np. Timer/Counter)",
        "correct": false
      },
      {
        "text": "przechowuje wynik ostatniej operacji arytmetycznej",
        "inline_explanation": "(to zadanie Akumulatora lub rejestrów ogólnego przeznaczenia)",
        "correct": false
      }
    ],
    "explanation": "Licznik rozkazów (PC) to kluczowy rejestr w architekturze von Neumanna i harvardzkiej. Po pobraniu rozkazu jego wartość jest automatycznie zwiększana (inkrementowana), aby wskazywać na kolejną instrukcję, chyba że nastąpi instrukcja skoku, która nadpisuje jego wartość."
  },
  {
    "id": 181,
    "question": "Rozkaz skoku bezwarunkowego (np. JMP) procesora:",
    "options": [
      {
        "text": "powoduje wpisanie do licznika rozkazów adresu rozkazu mającego się wykonać po skoku niezależnie od warunku",
        "inline_explanation": "(procesor przerywa sekwencyjne wykonywanie instrukcji i przechodzi pod wskazany adres)",
        "correct": true
      },
      {
        "text": "powoduje wpisanie do licznika rozkazów adresu rozkazu mającego się wykonać po skoku, ale tylko w przypadku spełnienia warunku skoku",
        "inline_explanation": "(to definicja skoku warunkowego, np. JZ - skocz jeśli zero)",
        "correct": false
      },
      {
        "text": "nie wpływa na stan licznika rozkazów",
        "inline_explanation": "(każdy skok polega na modyfikacji licznika rozkazów)",
        "correct": false
      },
      {
        "text": "zatrzymuje pracę procesora i oczekuje na przerwanie",
        "inline_explanation": "(to działanie instrukcji typu HALT lub SLEEP)",
        "correct": false
      }
    ],
    "explanation": "Instrukcje sterujące przepływem programu dzielimy na skoki warunkowe (wykonywane, gdy np. flaga Zero jest ustawiona) i bezwarunkowe. Skok bezwarunkowy to po prostu operacja wpisania nowej wartości bezpośrednio do rejestru Program Counter (PC)."
  },
  {
    "id": 182,
    "question": "Rozkaz skoku warunkowego procesora (np. JZ, JNZ, JC):",
    "options": [
      {
        "text": "nie wpływa na stan licznika rozkazów procesora",
        "inline_explanation": "(każdy skok, jeśli zostanie wykonany, musi zmienić wartość licznika rozkazów, aby wskazać nowy adres kodu)",
        "correct": false
      },
      {
        "text": "powoduje wpisanie do licznika rozkazów adresu rozkazu mającego się wykonać po skoku niezależnie od warunku",
        "inline_explanation": "(to definicja skoku bezwarunkowego JMP)",
        "correct": false
      },
      {
        "text": "powoduje wpisanie do licznika rozkazów adresu rozkazu mającego się wykonać po skoku, ale tylko w przypadku spełnienia warunku skoku",
        "inline_explanation": "(jeśli warunek nie jest spełniony, licznik jest inkrementowany standardowo, a procesor przechodzi do kolejnej instrukcji w pamięci)",
        "correct": true
      },
      {
        "text": "zatrzymuje wykonywanie programu do momentu spełnienia warunku przez urządzenie zewnętrzne",
        "inline_explanation": "(skok sprawdza flagi w rejestrze statusu w danej chwili, nie czeka na zdarzenia zewnętrzne)",
        "correct": false
      }
    ],
    "explanation": "Skoki warunkowe są podstawą sterowania przepływem programu (pętle, instrukcje if). Procesor sprawdza rejestr flag (np. Zero Flag, Carry Flag). Jeśli warunek jest spełniony (np. Z=1 dla instrukcji JZ), do licznika rozkazów (PC) wpisywany jest nowy adres. W przeciwnym razie program idzie dalej sekwencyjnie."
  },
  {
    "id": 183,
    "question": "Rozkaz procesora wykonujący dodawanie dwóch liczb (ADD):",
    "options": [
      {
        "text": "powoduje dodanie dwóch liczb, wynik zapisuje do licznika rozkazów",
        "inline_explanation": "(wynik trafia zazwyczaj do akumulatora lub rejestru ogólnego przeznaczenia; zapis do licznika rozkazów spowodowałby skok programu w losowe miejsce)",
        "correct": false
      },
      {
        "text": "wykorzystuje ALU (Arithmetic and Logical Unit)",
        "inline_explanation": "(ALU to moduł wykonawczy procesora odpowiedzialny za operacje matematyczne i logiczne)",
        "correct": true
      },
      {
        "text": "wykonuje operację wyłącznie na liczbach zmiennoprzecinkowych",
        "inline_explanation": "(do tego zazwyczaj służy jednostka FPU; podstawowe ALU operuje na liczbach całkowitych)",
        "correct": false
      },
      {
        "text": "nie zmienia flag w rejestrze statusu",
        "inline_explanation": "(operacja dodawania zazwyczaj aktualizuje flagi, np. przeniesienia (Carry) lub zera (Zero))",
        "correct": false
      }
    ],
    "explanation": "ALU (Arithmetic Logic Unit) to serce procesora wykonujące obliczenia. Instrukcja ADD pobiera argumenty (z rejestrów lub pamięci), przesyła je do ALU, a wynik zapisuje w miejscu docelowym."
  },
  {
    "id": 184,
    "question": "W procesorze wykorzystującym przetwarzanie potokowe (pipelining):",
    "options": [
      {
        "text": "wykonanie pojedynczej instrukcji rozkłada się na ciąg prostszych etapów",
        "inline_explanation": "(np. Fetch, Decode, Execute, Memory, Writeback)",
        "correct": true
      },
      {
        "text": "rozpoczęcie wykonania pierwszego etapu rozkazu może nastąpić dopiero po zakończeniu wykonania pierwszego etapu poprzedniego rozkazu",
        "inline_explanation": "(w idealnym potoku w każdym cyklu zegara 'wchodzi' nowa instrukcja do pierwszego etapu)",
        "correct": true
      },
      {
        "text": "rozpoczęcie wykonania rozkazu może nastąpić dopiero po zakończeniu wykonania poprzedniego rozkazu",
        "inline_explanation": "(to opis procesora bez potoku - sekwencyjnego)",
        "correct": false
      },
      {
        "text": "wszystkie etapy instrukcji wykonywane są w jednym cyklu zegara",
        "inline_explanation": "(każdy etap zajmuje zazwyczaj jeden cykl, więc cała instrukcja wykonuje się przez kilka cykli, ale przepustowość wynosi 1 instrukcja/cykl)",
        "correct": false
      }
    ],
    "explanation": "Potokowanie (pipelining) działa jak linia produkcyjna w fabryce. Gdy jedna instrukcja jest wykonywana (Execute), następna jest już dekodowana (Decode), a kolejna pobierana (Fetch). Zwiększa to przepustowość (throughput) procesora, mimo że czas wykonania pojedynczej instrukcji (latency) się nie zmienia."
  },
  {
    "id": 185,
    "question": "W procesorze wykorzystującym superskalarność (architektura superskalarna):",
    "options": [
      {
        "text": "rozpoczęcie wykonania pierwszego etapu rozkazu może nastąpić dopiero po zakończeniu wykonania pierwszego etapu poprzedniego rozkazu",
        "inline_explanation": "(w superskalarności możemy pobrać/rozpocząć kilka instrukcji W TYM SAMYM cyklu)",
        "correct": false
      },
      {
        "text": "ten sam etap dwóch kolejnych rozkazów może być wykonywany w tej samej chwili",
        "inline_explanation": "(ponieważ mamy zdublowane jednostki wykonawcze, np. dwie jednostki dekodujące)",
        "correct": true
      },
      {
        "text": "możliwe jest jednoczesne wykonanie więcej niż jednej instrukcji",
        "inline_explanation": "(celem jest osiągnięcie wskaźnika CPI < 1, czyli więcej niż jedna instrukcja na cykl zegara)",
        "correct": true
      },
      {
        "text": "procesor posiada tylko jedną jednostkę ALU",
        "inline_explanation": "(musi posiadać wiele jednostek wykonawczych, aby przetwarzać dane równolegle)",
        "correct": false
      }
    ],
    "explanation": "Architektura superskalarna to rozszerzenie idei potokowania o równoległość przestrzenną. Procesor posiada wiele jednostek wykonawczych (np. 2x ALU, 1x FPU). Dzięki temu, jeśli instrukcje nie są od siebie zależne, procesor może wykonać je dosłownie w tym samym czasie (Instruction Level Parallelism - ILP)."
  },
  {
    "id": 186,
    "question": "Rejestr rozkazów (IR - Instruction Register):",
    "options": [
      {
        "text": "przechowuje adres rozkazu wczytany z pamięci programu",
        "inline_explanation": "(to zadanie Licznika Rozkazów - PC; IR przechowuje samą treść/kod rozkazu)",
        "correct": false
      },
      {
        "text": "jego zawartosć wykorzystywana jest przez jednostkę sterującą (Control Unit)",
        "inline_explanation": "(dekoder rozkazów w jednostce sterującej odczytuje bity z IR, aby wiedzieć, jakie sygnały sterujące wysłać do reszty procesora)",
        "correct": true
      },
      {
        "text": "w trakcie wykonywania rozkazu zawartość rejestru rozkazów musi zmienić się bezpośrednio przed pobraniem argumentu rozkazu z pamięci programu",
        "inline_explanation": "(w cyklu rozkazu, po fazie pobrania (Fetch), następuje dekodowanie, co może wiązać się z przygotowaniem układu do pobrania operandów)",
        "correct": true
      },
      {
        "text": "przechowuje kod rozkazu wczytany z pamięci programu",
        "inline_explanation": "(podstawowa definicja rejestru IR)",
        "correct": true
      }
    ],
    "explanation": "Rejestr IR (Instruction Register) jest miejscem, do którego trafia instrukcja po pobraniu jej z pamięci (faza Fetch). Jego zawartość jest statyczna przez czas trwania cyklu danej instrukcji i służy dekoderowi do sterowania działaniem procesora (np. włączeniem dodawania w ALU)."
  },
  {
    "id": 187,
    "question": "Transmisja asynchroniczna:",
    "options": [
      {
        "text": "układy nadawczy i odbiorczy synchroniowane są wspólną dodatkową linią z sygnałem synchronicznym (zegarem)",
        "inline_explanation": "(to definicja transmisji synchronicznej, np. SPI czy I2C)",
        "correct": false
      },
      {
        "text": "podczas transmisji asynchronicznej występują kolejno po sobie wycinki czasu zawierające i nie zawierające informacji",
        "inline_explanation": "(transmisja nie jest ciągła; występują odstępy między ramkami danych)",
        "correct": true
      },
      {
        "text": "aby przygotować odbiorcę na przyjęcie sygnału zawierającego informacje, są wysyłane sygnały startu oraz sygnały stopu",
        "inline_explanation": "(bity Start i Stop tworzą 'ramkę' znaku, pozwalając odbiornikowi zsynchronizować się do konkretnego bajtu danych, np. w UART)",
        "correct": true
      },
      {
        "text": "wymaga idealnie zgodnych zegarów po obu stronach przez nieskończenie długi czas",
        "inline_explanation": "(zegary muszą być zbliżone, ale synchronizacja następuje przy każdym bicie startu, więc drobne odchyłki nie kumulują się w nieskończoność)",
        "correct": false
      }
    ],
    "explanation": "W transmisji asynchronicznej (np. port szeregowy RS-232/UART) nie ma oddzielnej linii zegarowej. Synchronizacja odbywa się na poziomie znaku/bajtu dzięki bitom Startu (logiczne 0) i Stopu (logiczna 1). Między przesyłaniem znaków linia może pozostawać w stanie bezczynności dowolnie długo."
  },
  {
    "id": 188,
    "question": "Jeżeli moc pobierana przez układ jest najważniejszym kryterium branym pod uwagę przy projektowaniu (zależy nam na energooszczędności), to którą rodzinę układów wybierzesz:",
    "options": [
      {
        "text": "CMOS",
        "inline_explanation": "(technologia Complementary MOS charakteryzuje się tym, że pobiera prąd praktycznie tylko w momentach przełączania stanów; prąd spoczynkowy jest pomijalny)",
        "correct": true
      },
      {
        "text": "ECL",
        "inline_explanation": "(Emitter Coupled Logic - bardzo szybka, ale bardzo prądożerna, 'grzejnik')",
        "correct": false
      },
      {
        "text": "standard TTL",
        "inline_explanation": "(technologia bipolarna, pobiera stały prąd nawet w stanie spoczynku)",
        "correct": false
      },
      {
        "text": "ALS TTL",
        "inline_explanation": "(ulepszona wersja TTL, oszczędniejsza, ale wciąż gorsza energetycznie od CMOS)",
        "correct": false
      }
    ],
    "explanation": "Układy CMOS dominują we współczesnej elektronice (procesory, pamięci) właśnie ze względu na niski pobór mocy. Moc w CMOS zależy liniowo od częstotliwości ($P = fCV^2$), podczas gdy w technologiach bipolarnych (TTL, ECL) duża część mocy jest tracona na ciepło niezależnie od pracy układu."
  },
  {
    "id": 189,
    "question": "Wyrażenie Boolowskie (dowolna funkcja logiczna) może być zrealizowane z:",
    "options": [
      {
        "text": "kombinacji bramek NAND i NOR",
        "inline_explanation": "(skoro każda z osobna wystarczy, to ich kombinacja tym bardziej)",
        "correct": true
      },
      {
        "text": "samych bramek NAND",
        "inline_explanation": "(NAND jest bramką funkcjonalnie pełną - można z niej zbudować NOT, AND, OR)",
        "correct": true
      },
      {
        "text": "samych bramek NOR",
        "inline_explanation": "(NOR również jest bramką funkcjonalnie pełną)",
        "correct": true
      },
      {
        "text": "samych bramek XOR",
        "inline_explanation": "(nie jest to zestaw pełny - nie da się z samych XOR-ów zbudować np. AND)",
        "correct": false
      },
      {
        "text": "kombinacji XOR i NOT",
        "inline_explanation": "(nadal brakuje możliwości zbudowania iloczynu logicznego AND lub sumy OR)",
        "correct": false
      }
    ],
    "explanation": "Bramki NAND oraz NOR nazywane są bramkami uniwersalnymi. Oznacza to, że dysponując nieskończoną liczbą bramek tylko jednego typu (np. tylko NAND), jesteśmy w stanie zbudować układ realizujący dowolną funkcję logiczną."
  },
  {
    "id": 190,
    "question": "Dowolną funkcję logiczną można zrealizować na bramkach:",
    "options": [
      {
        "text": "AND i NOR",
        "inline_explanation": "(tak, ponieważ $NOR(A, A) = NOT(A)$, a mając AND i NOT, z praw De Morgana możemy uzyskać OR, co daje nam pełny zestaw)",
        "correct": true
      },
      {
        "text": "XOR",
        "inline_explanation": "(nie jest to zestaw pełny)",
        "correct": false
      },
      {
        "text": "OR",
        "inline_explanation": "(sam OR to za mało, nie zrobimy negacji)",
        "correct": false
      },
      {
        "text": "AND",
        "inline_explanation": "(sam AND to za mało, nie zrobimy negacji)",
        "correct": false
      }
    ],
    "explanation": "Aby zestaw bramek był funkcjonalnie pełny, musi pozwalać na realizację trzech podstawowych operacji: koniunkcji (AND), alternatywy (OR) i negacji (NOT) - lub ich równoważników (np. NAND). Zestaw AND + NOR pozwala zbudować wszystkie te elementy."
  },
  {
    "id": 191,
    "question": "Rolą zegara doprowadzonego do przerzutnika bistabilnego (synchronicznego) jest:",
    "options": [
      {
        "text": "dążenie do zmiany na wyjściu w zależności od stanu wejść przygotowujących (S-R, J-K, D)",
        "inline_explanation": "(zegar wyznacza moment, w którym przerzutnik 'zatrzaskuje' stan wejść)",
        "correct": true
      },
      {
        "text": "wyzerowanie układu",
        "inline_explanation": "(to rola wejścia asynchronicznego RESET/CLR)",
        "correct": false
      },
      {
        "text": "ustawienie układu",
        "inline_explanation": "(to rola wejścia asynchronicznego SET/PRE)",
        "correct": false
      },
      {
        "text": "zawsze wywołanie zmiany na wyjściu",
        "inline_explanation": "(zmiana nastąpi tylko wtedy, gdy wymuszają to wejścia sterujące, np. $T=1$)",
        "correct": false
      }
    ],
    "explanation": "Przerzutniki synchroniczne reagują na wejścia informacyjne (J, K, D, T) tylko w określonym momencie wyznaczonym przez zbocze sygnału zegarowego (narastające lub opadające). Pozwala to na uniknięcie wyścigów i synchronizację całego układu cyfrowego."
  },
  {
    "id": 192,
    "question": "Przerzutnik JK jest w stanie stałych zmian na wyjściu (tzw. toggling - każde zbocze zegara zmienia stan na przeciwny) gdy:",
    "options": [
      {
        "text": "$J = 1, K = 1$",
        "inline_explanation": "(dla $J=1$ i $K=1$ przerzutnik JK działa jak przerzutnik T - zmienia stan na przeciwny: $Q_{n+1} = \neg Q_n$)",
        "correct": true
      },
      {
        "text": "$J = 1, K = 0$",
        "inline_explanation": "(funkcja Ustaw - Set: $Q_{n+1} = 1$)",
        "correct": false
      },
      {
        "text": "$J = 0, K = 1$",
        "inline_explanation": "(funkcja Zeruj - Reset: $Q_{n+1} = 0$)",
        "correct": false
      },
      {
        "text": "$J = 0, K = 0$",
        "inline_explanation": "(funkcja Pamiętaj - Hold: $Q_{n+1} = Q_n$)",
        "correct": false
      }
    ],
    "explanation": "Przerzutnik JK jest najbardziej uniwersalnym przerzutnikiem. Jego tabela prawdy obejmuje: Pamiętanie (0,0), Zerowanie (0,1), Ustawianie (1,0) oraz Negację stanu poprzedniego (1,1)."
  },
  {
    "id": 193,
    "question": "Multiwibrator astabilny:",
    "options": [
      {
        "text": "jest oscylatorem",
        "inline_explanation": "(generuje przebieg wyjściowy samodzielnie, bez zewnętrznego wymuszania)",
        "correct": true
      },
      {
        "text": "wymaga okresowego impulsu wymuszającego",
        "inline_explanation": "(to cecha przerzutników bistabilnych lub monostabilnych; astabilny działa samoczynnie)",
        "correct": false
      },
      {
        "text": "produkuje nieperiodyczne impulsy na wyjściu",
        "inline_explanation": "(produkuje impulsy periodyczne o określonej częstotliwości)",
        "correct": false
      },
      {
        "text": "nie ma stanu stabilnego",
        "inline_explanation": "(posiada dwa stany quasi-stabilne, między którymi nieustannie się przełącza)",
        "correct": true
      },
      {
        "text": "generuje sygnał sinusoidalny",
        "inline_explanation": "(zazwyczaj generuje falę prostokątną)",
        "correct": false
      },
      {
        "text": "może generować sygnał o różnym współczynniku wypełnienia",
        "inline_explanation": "(dobierając odpowiednio wartości rezystorów i kondensatorów w pętli sprzężenia, można regulować wypełnienie impulsu)",
        "correct": true
      }
    ],
    "explanation": "Multiwibrator astabilny to układ elektroniczny, który nie posiada żadnego stanu stabilnego (stąd nazwa). Działa jako generator fali prostokątnej (zegar), przełączając się cyklicznie między stanem wysokim a niskim."
  },
  {
    "id": 194,
    "question": "Który stan jest nieważny (zabroniony) w liczniku BCD (Binary-Coded Decimal):",
    "options": [
      {
        "text": "1100",
        "inline_explanation": "(dziesiętnie 12 - poza zakresem cyfr 0-9)",
        "correct": true
      },
      {
        "text": "0010",
        "inline_explanation": "(dziesiętnie 2 - poprawna cyfra BCD)",
        "correct": false
      },
      {
        "text": "0101",
        "inline_explanation": "(dziesiętnie 5 - poprawna cyfra BCD)",
        "correct": false
      },
      {
        "text": "1000",
        "inline_explanation": "(dziesiętnie 8 - poprawna cyfra BCD)",
        "correct": false
      }
    ],
    "explanation": "Kodowanie BCD (8421) wykorzystuje 4 bity do zapisu cyfr dziesiętnych od 0 do 9 (binarnie od 0000 do 1001). Pozostałe 6 kombinacji 4-bitowych (1010, 1011, 1100, 1101, 1110, 1111) reprezentujących liczby 10-15 jest w tym kodzie nieużywanych (zabronionych)."
  },
  {
    "id": 195,
    "question": "Zegar $10 \\text{ MHz}$ jest podłączony do kaskady liczników zawierającej kolejno: licznik modulo-5, modulo-8 i dwa liczniki modulo-10. Jaka jest częstotliwość wyjścia?",
    "options": [
      {
        "text": "$2,5 \\text{ kHz}$",
        "inline_explanation": "(dzielimy $10^7$ przez iloczyn podziałów: $5 \\cdot 8 \\cdot 10 \\cdot 10 = 4000$. $10000000 / 4000 = 2500 \\text{ Hz}$)",
        "correct": true
      },
      {
        "text": "$25 \\text{ kHz}$",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "$5 \\text{ kHz}$",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "$10 \\text{ kHz}$",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Połączenie kaskadowe (szeregowe) liczników powoduje mnożenie ich stopni podziału. Całkowity stopień podziału $N = 5 \\cdot 8 \\cdot 10 \\cdot 10 = 4000$. Częstotliwość wyjściowa to $f_{out} = f_{in} / N$."
  },
  {
    "id": 196,
    "question": "Licznik asynchroniczny różni się od synchronicznego:",
    "options": [
      {
        "text": "metodą zegarowania",
        "inline_explanation": "(w synchronicznym zegar wchodzi na wszystkie przerzutniki jednocześnie; w asynchronicznym wyjście jednego przerzutnika zegaruje następny)",
        "correct": true
      },
      {
        "text": "liczbą stanów w jego sekwencji",
        "inline_explanation": "(oba typy mogą liczyć w dowolnym modulo)",
        "correct": false
      },
      {
        "text": "typem użytych przerzutników",
        "inline_explanation": "(w obu można używać np. przerzutników JK lub T)",
        "correct": false
      },
      {
        "text": "liczbą podziału",
        "inline_explanation": "(nie zależy ona od synchronizacji)",
        "correct": false
      }
    ],
    "explanation": "Główna różnica to sposób doprowadzenia sygnału zegarowego. W licznikach asynchronicznych (szeregowych) sygnał propaguje się przez kolejne stopnie, co wprowadza opóźnienia i może powodować stany nieustalone (glitches). Liczniki synchroniczne (równoległe) są szybsze i stabilniejsze, bo wszystkie stopnie zmieniają stan w tym samym momencie."
  },
  {
    "id": 197,
    "question": "Stopnie (pojedyncze komórki) w rejestrze przesuwnym zawierają:",
    "options": [
      {
        "text": "przerzutniki",
        "inline_explanation": "(najczęściej typu D lub JK, każdy przechowuje 1 bit informacji)",
        "correct": true
      },
      {
        "text": "bajt pamięci",
        "inline_explanation": "(jeden stopień to jeden bit, nie bajt)",
        "correct": false
      },
      {
        "text": "4 bity pamięci",
        "inline_explanation": "(jeden stopień to jeden bit)",
        "correct": false
      },
      {
        "text": "zatrzaski (latches)",
        "inline_explanation": "(w rejestrach przesuwnych stosuje się przerzutniki zboczowe (flip-flops), a nie zatrzaski sterowane poziomem, aby precyzyjnie przesuwać dane w takt zegara)",
        "correct": false
      }
    ],
    "explanation": "Rejestr przesuwny to łańcuch połączonych ze sobą przerzutników. Wyjście jednego przerzutnika jest połączone z wejściem następnego, co umożliwia przesuwanie bitów wzdłuż łańcucha przy każdym impulsie zegara."
  },
  {
    "id": 198,
    "question": "Przy użyciu zegara $1 \\text{ MHz}$, osiem bitów równolegle może być wprowadzonych do rejestru przesuwnego w czasie:",
    "options": [
      {
        "text": "$1 \\mu s$",
        "inline_explanation": "(czas jednego cyklu zegara $T = 1/f = 1/10^6 s = 1 \\mu s$; wpis równoległy odbywa się w jednym takcie)",
        "correct": true
      },
      {
        "text": "w czasie propagacji 1 przerzutnika",
        "inline_explanation": "(fizycznie sygnał pojawia się na wyjściu po czasie propagacji od zbocza zegara)",
        "correct": true
      },
      {
        "text": "$8 \\mu s$",
        "inline_explanation": "(tyle trwałby wpis szeregowy bit po bicie)",
        "correct": false
      },
      {
        "text": "w czasie propagacji 8 przerzutników",
        "inline_explanation": "(przy wpisie równoległym przerzutniki działają jednocześnie, czasy się nie sumują)",
        "correct": false
      }
    ],
    "explanation": "Rejestr z wejściem równoległym (PIPO/PISO) ładuje wszystkie bity jednocześnie w momencie wystąpienia aktywnego zbocza zegara. Operacja ta zajmuje więc jeden okres zegara (tu: 1 mikrosekunda) z punktu widzenia systemu taktującego."
  },
  {
    "id": 199,
    "question": "Grupa bitów $10110101$ jest szeregowo przesuwana w prawo w ośmiobitowym rejestrze ze stanem początkowym $11100100$. Po dwóch impulsach zegara stan wyjścia (zawartość rejestru) jest:",
    "options": [
      {
        "text": "$01111001$",
        "inline_explanation": "(Przesuwamy stan $11100100$ o 2 w prawo -> $xx111001$. W wolne miejsca 'xx' wchodzą 2 ostatnie bity z grupy wejściowej (zapisanej jako LSB z prawej): $01$. Wynik: $01111001$)",
        "correct": true
      },
      {
        "text": "$01011110$",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "$10110101$",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "$00101101$",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Operacja przesunięcia w prawo (Shift Right) o 2 pozycje powoduje, że dwa najmniej znaczące bity (00) 'wypadają' z rejestru, pozostałe bity przesuwają się w prawo, a na dwie zwolnione pozycje najbardziej znaczące (z lewej) wchodzą nowe dane z wejścia szeregowego."
  },
  {
    "id": 200,
    "question": "8-bitowy przetwornik DAC (Cyfrowo-Analogowy) ma rozdzielczość (wyrażoną w procentach zakresu):",
    "options": [
      {
        "text": "$0,392\\%$",
        "inline_explanation": "(Rozdzielczość to waga najmłodszego bitu (LSB): $1/2^8 = 1/256 \\approx 0,0039$, co daje ok. $0,39\\%$)",
        "correct": true
      },
      {
        "text": "$1\\%$",
        "inline_explanation": "(to by odpowiadało przetwornikowi ok. 6-7 bitowemu)",
        "correct": false
      },
      {
        "text": "$3,92\\%$",
        "inline_explanation": "(błąd rzędu wielkości)",
        "correct": false
      },
      {
        "text": "$0,1\\%$",
        "inline_explanation": "(wymagałoby 10 bitów: $1/1024 \\approx 0,1\\%$)",
        "correct": false
      }
    ],
    "explanation": "Rozdzielczość przetwornika n-bitowego określa najmniejszą zmianę sygnału wyjściowego, jaką można uzyskać. Wynosi ona $1 / 2^n$ pełnego zakresu. Dla $n=8$, $1/256 \\approx 0.39\\%$."
  },
  {
    "id": 201,
    "question": "W przetworniku DAC typu R-2R:",
    "options": [
      {
        "text": "są 2 wartości rezystorów",
        "inline_explanation": "(zgodnie z nazwą: rezystory o rezystancji $R$ i $2R$)",
        "correct": true
      },
      {
        "text": "liczba rezystorów jest równa dwukrotności liczby wejść",
        "inline_explanation": "(dla każdego bitu mamy jeden rezystor w gałęzi poziomej i jeden w pionowej drabinki)",
        "correct": true
      },
      {
        "text": "rezystory o jednej wartości",
        "inline_explanation": "(nie, wymagane są dwie wartości)",
        "correct": false
      },
      {
        "text": "liczba wartości rezystorów jest równa liczbie wejść",
        "inline_explanation": "(to cecha przetwornika wagowego, gdzie każdy bit ma inną wagę rezystora: $R, 2R, 4R, 8R...$)",
        "correct": false
      }
    ],
    "explanation": "Drabinka rezystorowa R-2R to sprytna konstrukcja przetwornika C/A, która eliminuje wadę przetworników wagowych (konieczność posiadania wielu precyzyjnych rezystorów o różnych wartościach). Tutaj używa się tylko dwóch wartości rezystancji ($R$ i $2R$), co ułatwia produkcję układów scalonych. "
  },
  {
    "id": 202,
    "question": "Która zależność opisująca hierarchię cykli pracy komputera jest poprawna:",
    "options": [
      {
        "text": "na jeden cykl maszynowy składa się jeden lub kilka cykli rozkazowych a na jeden cykl rozkazowy składa się jeden lub kilka cykli zegarowych",
        "inline_explanation": "(odwrotna kolejność - cykl rozkazowy jest nadrzędny)",
        "correct": false
      },
      {
        "text": "na jeden cykl zegarowy składa się jeden lub kilka cykli maszynowych a na jeden cykl maszynowy składa się jeden lub kilka cykli rozkazowych",
        "inline_explanation": "(niemożliwe - cykl zegarowy jest najkrótszą jednostką czasu w systemie synchronicznym)",
        "correct": false
      },
      {
        "text": "na jeden cykl rozkazowy składa się jeden lub kilka cykli maszynowych a na jeden cykl maszynowy składa się jeden lub kilka cykli zegarowych",
        "inline_explanation": "(Cykl Rozkazowy (cała instrukcja) -> Cykle Maszynowe (np. Fetch, Execute) -> Cykle Zegarowe (takty))",
        "correct": true
      }
    ],
    "explanation": "Hierarchia czasu w procesorze: 1. Cykl zegarowy (takt) - najmniejsza jednostka. 2. Cykl maszynowy - czas potrzebny na wykonanie prostej operacji z pamięcią lub rejestrami (składa się z kilku taktów). 3. Cykl rozkazowy - czas wykonania pełnej instrukcji asemblerowej (składa się z kilku cykli maszynowych, np. pobrania, dekodowania, wykonania)."
  },
  {
    "id": 203,
    "question": "Co wpływa na fakt szybszego dostępu do danych przy użyciu DMA (Direct Memory Access) zamiast trybu programowalnego (PIO)?",
    "options": [
      {
        "text": "czysto sprzętowa realizacja dostępu",
        "inline_explanation": "(kontroler DMA przesyła dane bezpośrednio między pamięcią a urządzeniem, pomijając procesor i narzut związany z pobieraniem instrukcji przesłania)",
        "correct": true
      },
      {
        "text": "szybszy zegar",
        "inline_explanation": "(DMA zazwyczaj pracuje na tym samym zegarze magistrali co reszta systemu)",
        "correct": false
      },
      {
        "text": "krótsze ścieżki na płycie głównej",
        "inline_explanation": "(fizyczna długość ścieżek jest stała)",
        "correct": false
      },
      {
        "text": "większy bufor",
        "inline_explanation": "(buforowanie pomaga, ale kluczem jest brak udziału CPU w samej transmisji)",
        "correct": false
      }
    ],
    "explanation": "W trybie programowalnym procesor musi wykonać pętlę: pobierz dane z urządzenia -> zapisz do rejestru -> zapisz z rejestru do pamięci. DMA to dedykowany układ sprzętowy, który przejmuje kontrolę nad magistralą i kopiuje blok danych 'hurtem', co jest znacznie szybsze i odciąża CPU."
  },
  {
    "id": 204,
    "question": "Który rodzaj pamięci wymaga okresowego odświeżania (refresh)?",
    "options": [
      {
        "text": "DRAM (Dynamic RAM)",
        "inline_explanation": "(informacja jest przechowywana jako ładunek w kondensatorze, który z czasem 'ucieka' - stąd konieczność odświeżania)",
        "correct": true
      },
      {
        "text": "SDRAM (Synchronous DRAM)",
        "inline_explanation": "(jest to rodzaj pamięci dynamicznej, więc również wymaga odświeżania)",
        "correct": true
      },
      {
        "text": "SRAM (Static RAM)",
        "inline_explanation": "(zbudowana z przerzutników, pamięta stan dopóki jest zasilanie, bez odświeżania)",
        "correct": false
      },
      {
        "text": "flash / ROM",
        "inline_explanation": "(pamięci nieulotne, nie wymagają odświeżania)",
        "correct": false
      }
    ],
    "explanation": "Pamięci dynamiczne (DRAM, SDRAM, DDR) zbudowane są z układu 'tranzystor + kondensator'. Kondensator rozładowuje się przez upływność prądu, więc kontroler pamięci musi co kilka milisekund odczytać i zapisać ponownie każdą komórkę (odświeżanie), aby nie stracić danych."
  },
  {
    "id": 205,
    "question": "Połączenie procesora z magistralą odbywa się poprzez bufor trójstanowy (tri-state buffer) aby:",
    "options": [
      {
        "text": "uzyskać wysoką impedancję bufora w razie potrzeby",
        "inline_explanation": "(stan wysokiej impedancji 'Hi-Z' elektrycznie odłącza układ od magistrali)",
        "correct": true
      },
      {
        "text": "uzyskać stan rozwarcia aby odłączyć procesor",
        "inline_explanation": "(dzięki temu inne urządzenia, np. kontroler DMA, mogą w tym czasie sterować magistralą bez powodowania zwarć)",
        "correct": true
      },
      {
        "text": "wzmocnić sygnał wyjściowy dwukrotnie",
        "inline_explanation": "(bufor może wzmacniać prądowo, ale 'trójstanowość' służy do odłączania, a nie wzmacniania)",
        "correct": false
      }
    ],
    "explanation": "Magistrala jest medium współdzielonym. W danej chwili tylko jedno urządzenie może na niej nadawać (wystawiać '0' lub '1'). Pozostałe urządzenia muszą być w stanie wysokiej impedancji (Hi-Z), czyli zachowywać się tak, jakby były fizycznie odłączone, aby nie zakłócać transmisji."
  },
  {
    "id": 206,
    "question": "Dla utrzymania logicznego stanu komórki pamięci dynamicznej (DRAM) niezbędne okazuje się:",
    "options": [
      {
        "text": "odświeżanie jej zawartości",
        "inline_explanation": "(uzupełnianie ładunku w kondensatorach)",
        "correct": true
      },
      {
        "text": "dostarczanie stałego napięcia do komórki",
        "inline_explanation": "(samo zasilanie nie wystarcza, potrzebny jest aktywny cykl odświeżania)",
        "correct": false
      },
      {
        "text": "nic nie trzeba robić",
        "inline_explanation": "(wtedy dane znikną po kilku milisekundach)",
        "correct": false
      }
    ],
    "explanation": "Patrz wyjaśnienie do pytania o pamięci DRAM."
  },
  {
    "id": 207,
    "question": "Układ sterujący procesora (Control Unit - CU) jest to:",
    "options": [
      {
        "text": "układ generujący funkcje (sygnały) sterujące wykonywaniem programu",
        "inline_explanation": "(CU dekoduje instrukcje i steruje przepływem danych między rejestrami, ALU i pamięcią)",
        "correct": true
      },
      {
        "text": "rejestry konfiguracyjne, których stan określa aktualny tryb pracy procesora",
        "inline_explanation": "(rejestry są elementem modelu programowego, a CU to hardware zarządzający)",
        "correct": false
      },
      {
        "text": "zestaw funkcji ułatwiających śledzenie przebiegu wykonywania programu",
        "inline_explanation": "(to opis debuggera)",
        "correct": false
      }
    ],
    "explanation": "Jednostka sterująca to 'mózg' procesora. Na podstawie kodu rozkazu (OpCode) decyduje, które bramki otworzyć, jaką operację ma wykonać ALU i gdzie zapisać wynik."
  },
  {
    "id": 208,
    "question": "Procesor otrzymuje sygnał HOLD (np. od kontrolera DMA), oznacza to:",
    "options": [
      {
        "text": "chwilowe zawieszenie pracy w celu zwolnienia magistrali",
        "inline_explanation": "(procesor kończy bieżący cykl maszynowy, odłącza się od magistrali (stan Hi-Z) i potwierdza sygnałem HLDA - Hold Acknowledge)",
        "correct": true
      },
      {
        "text": "wymuszenie wykonania specjalnego programu",
        "inline_explanation": "(to opis przerwania - Interrupt, a nie Hold)",
        "correct": false
      },
      {
        "text": "zerowanie licznika programu",
        "inline_explanation": "(to opis sygnału RESET)",
        "correct": false
      },
      {
        "text": "przejście do podprogramu",
        "inline_explanation": "(to instrukcja CALL)",
        "correct": false
      }
    ],
    "explanation": "Sygnał HOLD służy do arbitrażu magistrali. Gdy urządzenie zewnętrzne (np. DMA) chce przesłać dane, prosi procesor o 'zejście z linii'. Procesor wchodzi w stan wstrzymania, oddając kontrolę nad magistralą systemową."
  },
  {
    "id": 209,
    "question": "Co to jest mikrooperacja?",
    "options": [
      {
        "text": "najprostsza operacja do wykonania w jednym takcie zegara",
        "inline_explanation": "(np. przesłanie zawartości jednego rejestru do drugiego)",
        "correct": true
      },
      {
        "text": "element składowy rozkazu (instrukcji asemblerowej)",
        "inline_explanation": "(jedna instrukcja asemblera, np. ADD, składa się z wielu mikrooperacji)",
        "correct": true
      },
      {
        "text": "elementarna operacja do wykonania w potoku",
        "inline_explanation": "(chociaż mikrooperacje są wykonywane w potoku, ta definicja jest mniej precyzyjna niż 'element składowy rozkazu')",
        "correct": false
      }
    ],
    "explanation": "Mikrooperacje to operacje poziomu sprzętowego (Register Transfer Level), niewidoczne bezpośrednio dla programisty. Przykłady: 'przepisz PC do MAR', 'zwiększ PC o 1', 'odczytaj pamięć'."
  },
  {
    "id": 210,
    "question": "Po co w procesorach zastosowano pamięć typu ROM w jednostce sterującej?",
    "options": [
      {
        "text": "dla zorganizowania mikroprogramowanego dekodera",
        "inline_explanation": "(w pamięci tej zaszyty jest mikroprogram (firmware procesora), który tłumaczy instrukcje maszynowe na sygnały sterujące)",
        "correct": true
      },
      {
        "text": "dla zachowania programu boot'ującego",
        "inline_explanation": "(BIOS jest w ROM, ale na płycie głównej, a nie wewnątrz jednostki sterującej CPU)",
        "correct": false
      },
      {
        "text": "dla zachowania ustawień procesora",
        "inline_explanation": "(ustawienia są w rejestrach)",
        "correct": false
      }
    ],
    "explanation": "W architekturach CISC (np. x86) instrukcje są zbyt skomplikowane, by dekodować je prostą siecią bramek. Zamiast tego używa się mikroprogramowania – 'procesora wewnątrz procesora', gdzie instrukcja asemblera jest adresem w pamięci ROM, pod którym znajduje się sekwencja mikroinstrukcji realizujących to zadanie."
  },
  {
    "id": 211,
    "question": "Model pamięci współdzielonej (Shared Memory):",
    "options": [
      {
        "text": "jest typowy dla maszyn SIMD",
        "inline_explanation": "(Wiele maszyn SIMD (np. GPU) korzysta z pamięci współdzielonej, choć nie jest to reguła wyłączna)",
        "correct": true
      },
      {
        "text": "jest typowy dla maszyn SMP (Symmetric Multiprocessing)",
        "inline_explanation": "(SMP z definicji oznacza wiele procesorów z dostępem do jednej, wspólnej przestrzeni adresowej)",
        "correct": true
      },
      {
        "text": "może być wykorzystany w maszynach typu MIMD",
        "inline_explanation": "(SMP jest podzbiorem MIMD)",
        "correct": true
      },
      {
        "text": "występuje w odniesieniu do klastrów komputerów",
        "inline_explanation": "(klastry zazwyczaj wykorzystują model pamięci rozproszonej z przesyłaniem komunikatów)",
        "correct": false
      }
    ],
    "explanation": "W modelu pamięci współdzielonej wszystkie procesory widzą te same adresy pamięci. Komunikacja odbywa się poprzez zapis i odczyt zmiennych w tej pamięci. Jest to łatwe do programowania (OpenMP), ale trudne do skalowania sprzętowego (bottleneck na magistrali)."
  },
  {
    "id": 212,
    "question": "Do maszyn typu MIMD (Multiple Instruction, Multiple Data) należą:",
    "options": [
      {
        "text": "ccNUMA (Cache-coherent Non-Uniform Memory Access)",
        "inline_explanation": "(architektura z pamięcią współdzieloną, ale rozproszoną fizycznie)",
        "correct": true
      },
      {
        "text": "maszyny wykorzystujące model obliczeniowy z wymianą komunikatów (Klastry/MPP)",
        "inline_explanation": "(każdy węzeł ma własną pamięć i wykonuje własny kod)",
        "correct": true
      },
      {
        "text": "maszyny SMP (Symmetric Multiprocessing)",
        "inline_explanation": "(współczesne procesory wielordzeniowe)",
        "correct": true
      },
      {
        "text": "procesory wektorowe starego typu",
        "inline_explanation": "(to zazwyczaj SIMD)",
        "correct": false
      }
    ],
    "explanation": "Klasyfikacja Flynna: MIMD to najszersza kategoria systemów równoległych, obejmująca wszystko, gdzie wiele procesorów wykonuje niezależnie różne fragmenty kodu na różnych danych. Mieszczą się tu zarówno superkomputery klastrowe, jak i Twój laptop z procesorem wielordzeniowym."
  },
  {
    "id": 213,
    "question": "Magistrala systemowa (w architekturach wieloprocesorowych):",
    "options": [
      {
        "text": "umożliwia łatwą rozbudowę systemu",
        "inline_explanation": "(łatwo dopiąć nowy procesor lub moduł pamięci)",
        "correct": true
      },
      {
        "text": "jest typowa dla maszyn SMP",
        "inline_explanation": "(klasyczne SMP opiera się na wspólnej magistrali, co limituje liczbę procesorów do kilkunastu)",
        "correct": true
      },
      {
        "text": "charakteryzuje się wysoką przepustowością w porównaniu z innymi rozwiązaniami warstwy komunikacyjnej",
        "inline_explanation": "(magistrala jest wąskim gardłem w porównaniu do przełącznic krzyżowych)",
        "correct": false
      },
      {
        "text": "jest rozwiązaniem najbardziej zaawansowanym technologicznie",
        "inline_explanation": "(obecnie odchodzi się od magistral na rzecz połączeń punkt-punkt typu QPI/HyperTransport)",
        "correct": false
      }
    ],
    "explanation": "Wspólna magistrala jest najprostszym medium komunikacyjnym. Jej wadą jest to, że w danej chwili tylko jeden procesor może z niej korzystać, co przy dużej liczbie CPU prowadzi do zatorów (bus contention)."
  },
  {
    "id": 214,
    "question": "Najwydajniejszym rozwiązaniem warstwy komunikacyjnej w maszynach o wielu procesorach jest:",
    "options": [
      {
        "text": "przełącznica krzyżowa (Crossbar switch)",
        "inline_explanation": "(umożliwia jednoczesne połączenie wielu par nadawca-odbiorca bez kolizji, o ile nie celują w to samo wyjście)",
        "correct": true
      },
      {
        "text": "magistrala systemowa",
        "inline_explanation": "(blokująca, niska skalowalność)",
        "correct": false
      },
      {
        "text": "Myrinet",
        "inline_explanation": "(standard sieciowy dla klastrów, wydajny, ale crossbar wewnątrz układu jest szybszy)",
        "correct": false
      },
      {
        "text": "Ethernet 100Mb",
        "inline_explanation": "(zdecydowanie za wolny dla HPC)",
        "correct": false
      }
    ],
    "explanation": "Crossbar to macierz przełączników. Jeśli mamy N procesorów i N banków pamięci, crossbar teoretycznie pozwala na N równoczesnych transmisji (o pełnej prędkości), o ile każdy procesor odwołuje się do innego banku."
  },
  {
    "id": 215,
    "question": "Model obliczeń równoległych z wymianą komunikatów (Message Passing, np. MPI):",
    "options": [
      {
        "text": "w obliczeniach jest zazwyczaj bardziej efektywny od modelu pamięci współdzielonej",
        "inline_explanation": "(wymusza na programiście świadome przesyłanie danych, co sprzyja lokalności danych i unikaniu hazardów pamięci; lepiej się skaluje)",
        "correct": true
      },
      {
        "text": "charakterystyczny dla architektur klastrowych",
        "inline_explanation": "(klastry nie mają wspólnej pamięci fizycznej, więc muszą wymieniać komunikaty przez sieć)",
        "correct": true
      },
      {
        "text": "stosowany jest najczęściej w maszynach o pamięci współdzielonej",
        "inline_explanation": "(tam naturalniejszy jest model OpenMP/pthreads, choć MPI też zadziała)",
        "correct": false
      },
      {
        "text": "charakteryzuje się łatwością programowania",
        "inline_explanation": "(jest uważany za trudniejszy od modelu pamięci współdzielonej - programista musi ręcznie zarządzać komunikacją)",
        "correct": false
      }
    ],
    "explanation": "W modelu Message Passing procesy są izolowane i komunikują się explicite wysyłając pakiety danych (Send/Receive). Eliminuje to problemy spójności pamięci podręcznej (cache coherency), co pozwala budować systemy o ogromnej skali."
  },
  {
    "id": 216,
    "question": "Architektury klastrowe (Clusters):",
    "options": [
      {
        "text": "charakteryzują się wysoką dostępnością (High Availability) i istnieniem zasobów zastępczych",
        "inline_explanation": "(awaria jednego węzła nie zatrzymuje całego klastra)",
        "correct": true
      },
      {
        "text": "występuje w nich współdzielenie zasobów",
        "inline_explanation": "(współdzielą zasoby obliczeniowe, dyskowe, sieciowe)",
        "correct": true
      },
      {
        "text": "współdzielą wyłącznie zasoby dyskowe",
        "inline_explanation": "(dzielą też moc CPU i pamięć RAM w sensie logicznym)",
        "correct": false
      },
      {
        "text": "są przeznaczone wyłącznie do obliczeń naukowo-technicznych",
        "inline_explanation": "(także bazy danych, serwery webowe, render farmy)",
        "correct": false
      }
    ],
    "explanation": "Klaster to grupa połączonych komputerów (węzłów), które pracują razem jako jeden system. Są tanie (skalowalne z gotowych komponentów COTS) i odporne na awarie."
  },
  {
    "id": 217,
    "question": "Wielowątkowość (Multithreading) i wielordzeniowość (Multicore) procesora:",
    "options": [
      {
        "text": "zostały rozwinięte niezależnie przez producentów",
        "inline_explanation": "(to dwie różne koncepcje: wielowątkowość (np. HyperThreading) optymalizuje wykorzystanie potoku jednego rdzenia, a wielordzeniowość powiela fizyczne rdzenie)",
        "correct": true
      },
      {
        "text": "są synonimami",
        "inline_explanation": "(nie: 1 rdzeń może obsługiwać 2 wątki)",
        "correct": false
      },
      {
        "text": "są charakterystyczne tylko dla procesorów AMD",
        "inline_explanation": "(Intel, ARM, IBM też je stosują)",
        "correct": false
      },
      {
        "text": "zostały rozwinięte specjalnie dla technologii Centrino",
        "inline_explanation": "(nie, pojawiły się wcześniej w serwerach)",
        "correct": false
      }
    ],
    "explanation": "Wielordzeniowość to fizyczne umieszczenie kilku procesorów w jednym układzie scalonym. Wielowątkowość (SMT) to technika logiczna, pozwalająca jednemu rdzeniowi udawać dwa (lub więcej), aby lepiej 'upychać' instrukcje w potoku wykonawczym, gdy np. jedna instrukcja czeka na pamięć."
  },
  {
    "id": 218,
    "question": "Sekcja krytyczna procesu to:",
    "options": [
      {
        "text": "część procesu (fragment kodu), w której wykorzystywany jest zasób dzielony",
        "inline_explanation": "(np. dostęp do wspólnej zmiennej, pliku czy urządzenia, który nie może być wykonywany przez wiele procesów naraz)",
        "correct": true
      },
      {
        "text": "część procesu, w której wykonywana jest komunikacja z użytkownikiem",
        "inline_explanation": "(to po prostu operacja I/O, nie musi być sekcją krytyczną, chyba że dotyczy np. wyłącznego dostępu do terminala)",
        "correct": false
      },
      {
        "text": "część procesu, w której wykonywana jest nieskończona pętla",
        "inline_explanation": "(to błąd logiczny lub celowe działanie, ale nie definicja sekcji krytycznej)",
        "correct": false
      },
      {
        "text": "część procesu, w której deklarowane są lokalne zmienne",
        "inline_explanation": "(zmienne lokalne są prywatne dla wątku/procesu i nie wymagają ochrony)",
        "correct": false
      }
    ],
    "explanation": "Sekcja krytyczna to fragment kodu, w którym procesy odwołują się do współdzielonych zasobów. Aby uniknąć błędów (wyścigów - race conditions), w sekcji krytycznej w danej chwili może znajdować się tylko jeden proces."
  },
  {
    "id": 219,
    "question": "Wzajemnym wykluczaniem (Mutual Exclusion - Mutex) nazywamy problem współzawodnictwa procesów o zasób, który:",
    "options": [
      {
        "text": "jednocześnie może być wykorzystywany tylko przez jeden z nich",
        "inline_explanation": "(wymuszenie sekwencyjnego dostępu do zasobu to istota wzajemnego wykluczania)",
        "correct": true
      },
      {
        "text": "musi zostać zainicjalizowany przez jeden z procesów",
        "inline_explanation": "(inicjalizacja to osobny problem)",
        "correct": false
      },
      {
        "text": "jest zmienną przechowywaną w rejestrach procesora",
        "inline_explanation": "(rejestry są zazwyczaj zapisywane/odtwarzane przy przełączaniu kontekstu (context switch), więc każdy proces ma swoją 'wirtualną' kopię; problem dotyczy pamięci współdzielonej)",
        "correct": false
      },
      {
        "text": "może być wykorzystywany tylko przez z góry określony czas",
        "inline_explanation": "(to dotyczy szeregowania/kwantu czasu, a nie wykluczania)",
        "correct": false
      }
    ],
    "explanation": "Wzajemne wykluczanie to mechanizm synchronizacji gwarantujący, że w momencie gdy jeden proces przebywa w sekcji krytycznej (korzysta z zasobu), żaden inny proces nie może do niej wejść."
  },
  {
    "id": 220,
    "question": "Komunikację nazywamy asynchroniczną (nieblokującą) jeżeli:",
    "options": [
      {
        "text": "nadawca może wysłać wiadomość i kontynuować pracę bez wstrzymania",
        "inline_explanation": "(nadawca wrzuca komunikat do bufora i natychmiast wraca do swoich obliczeń)",
        "correct": true
      },
      {
        "text": "nadawca nie żąda, by odbiorca był gotów do odebrania komunikatu",
        "inline_explanation": "(tzw. 'fire and forget' lub wysyłanie do skrzynki pocztowej)",
        "correct": true
      },
      {
        "text": "nadawca żąda, by odbiorca był gotów do odebrania komunikatu",
        "inline_explanation": "(to cecha komunikacji synchronicznej - rendezvous)",
        "correct": false
      },
      {
        "text": "przy komunikacji mamy do czynienia z synchronizacją procesów",
        "inline_explanation": "(asynchroniczność z definicji rozluźnia synchronizację czasową)",
        "correct": false
      }
    ],
    "explanation": "W modelu asynchronicznym (non-blocking send) nadawca nie musi czekać, aż odbiorca pobierze wiadomość. Komunikat jest przechowywany w systemowym buforze lub kolejce."
  },
  {
    "id": 221,
    "question": "Komunikację nazywamy synchroniczną (blokującą / rendezvous) jeżeli:",
    "options": [
      {
        "text": "nadawca żąda, by odbiorca był gotów do odebrania komunikatu",
        "inline_explanation": "(wymagane jest 'spotkanie' w czasie obu procesów)",
        "correct": true
      },
      {
        "text": "przy komunikacji mamy do czynienia z synchronizacją procesów",
        "inline_explanation": "(proces szybszy musi poczekać na wolniejszy, co wymusza synchronizację)",
        "correct": true
      },
      {
        "text": "nadawca nie żąda, by odbiorca był gotów do odebrania komunikatu",
        "inline_explanation": "(cecha asynchroniczności)",
        "correct": false
      },
      {
        "text": "nadawca może wysłać wiadomość i kontynuować pracę bez wstrzymania",
        "inline_explanation": "(cecha asynchroniczności)",
        "correct": false
      }
    ],
    "explanation": "W komunikacji synchronicznej (blocking send/receive) nadanie komunikatu kończy się sukcesem dopiero wtedy, gdy odbiorca go odbierze. Przypomina to rozmowę telefoniczną (obie strony muszą być aktywne), podczas gdy asynchroniczna przypomina e-mail."
  },
  {
    "id": 222,
    "question": "Zjawisko blokady (Deadlock) w programie współbieżnym jest:",
    "options": [
      {
        "text": "stanem, w którym każdy proces oczekuje na działanie innego procesu",
        "inline_explanation": "(tworzy się cykl oczekiwania: A czeka na B, B czeka na A - żaden nie może ruszyć)",
        "correct": true
      },
      {
        "text": "przejawem braku bezpieczeństwa (safety) programu współbieżnego",
        "inline_explanation": "(w sensie definicji Lamporta: 'bad thing happened' - system utknął w nieprawidłowym stanie)",
        "correct": true
      },
      {
        "text": "zatrzymaniem pracy jednego ze współbieżnych procesów",
        "inline_explanation": "(to może być zagłodzenie lub zwykłe oczekiwanie na I/O, deadlock dotyczy grupy procesów)",
        "correct": false
      },
      {
        "text": "stanem, w którym proces czekający na dane zdarzenie nie zostaje wznowiony mimo, że występuje ono dowolną liczbę razy",
        "inline_explanation": "(to definicja zagłodzenia)",
        "correct": false
      }
    ],
    "explanation": "Blokada (zakleszczenie) to sytuacja patowa. Występuje, gdy grupa procesów wstrzymuje swoje działanie, ponieważ każdy z nich czeka na zwolnienie zasobu zajętego przez inny proces z tej samej grupy."
  },
  {
    "id": 223,
    "question": "Zjawisko zagłodzenia (Starvation) w programie współbieżnym jest:",
    "options": [
      {
        "text": "stanem, w którym proces czekający na dane zdarzenie nie zostaje wznowiony mimo, że występuje ono dowolną liczbę razy",
        "inline_explanation": "(np. proces o niskim priorytecie ciągle jest wyprzedzany przez nowe procesy o wyższym priorytecie)",
        "correct": true
      },
      {
        "text": "sytuacją kiedy nie ma gwarancji że określone zdarzenie wykona się w skończonym czasie",
        "inline_explanation": "(naruszenie własności żywotności/liveness)",
        "correct": true
      },
      {
        "text": "stanem, w którym każdy proces oczekuje na działanie innego procesu",
        "inline_explanation": "(to deadlock)",
        "correct": false
      },
      {
        "text": "pojawieniem się cyklu w relacji Lamporta 'happen-before'",
        "inline_explanation": "(relacja 'stało się przed' jest relacją częściowego porządku, więc jest przeciwzwrotna i nie może zawierać cykli)",
        "correct": false
      }
    ],
    "explanation": "Zagłodzenie różni się od blokady tym, że system jako całość może pracować i postępować naprzód, ale jeden (lub więcej) konkretny proces nigdy nie dostaje dostępu do procesora lub zasobu. Jest to problem sprawiedliwości (fairness) algorytmu szeregowania."
  },
  {
    "id": 224,
    "question": "Jakie byłyby konsekwencje znalezienia wielomianowego deterministycznego algorytmu dla problemu NP-zupełnego?",
    "options": [
      {
        "text": "stanowiłoby to dowód, że $P = NP$",
        "inline_explanation": "(skoro problem NP-zupełny (do którego redukują się wszystkie inne problemy NP) dałoby się rozwiązać w czasie wielomianowym, to każdy problem z klasy NP dałoby się tak rozwiązać)",
        "correct": true
      },
      {
        "text": "oznaczałoby to, że $P \\neq NP$",
        "inline_explanation": "(wręcz przeciwnie, zatarłaby się granica między problemami łatwymi a trudnymi)",
        "correct": false
      },
      {
        "text": "nie miałoby to żadnych konsekwencji dla teorii złożoności obliczeniowej",
        "inline_explanation": "(byłby to największy przełom w historii informatyki, rozwiązujący jeden z problemów milenijnych)",
        "correct": false
      },
      {
        "text": "każdy problem algorytmiczny można byłoby rozwiązać w czasie wielomianowym",
        "inline_explanation": "(nie każdy - istnieją problemy nierozstrzygalne, np. problem stopu, których nie da się rozwiązać żadnym algorytmem, niezależnie od czasu)",
        "correct": false
      }
    ],
    "explanation": "Definicja problemu NP-zupełnego (NPC) mówi, że jest to problem należący do NP, do którego można zredukować każdy inny problem z klasy NP w czasie wielomianowym. Jeśli dla choćby jednego problemu NPC znajdziemy szybki (wielomianowy) algorytm, to dzięki redukcji będziemy mogli szybko rozwiązać wszystkie problemy z klasy NP, dowodząc tym samym, że $P=NP$."
  },
  {
    "id": 225,
    "question": "Jakie problemy zaliczamy do klasy problemów NP-zupełnych (NPC)?",
    "options": [
      {
        "text": "wszystkie problemy z klasy NP redukują się do nich i same należą do klasy NP",
        "inline_explanation": "(jest to ścisła definicja: problem jest w NP (weryfikowalny wielomianowo) i jest NP-trudny (każdy inny z NP się do niego redukuje))",
        "correct": true
      },
      {
        "text": "takie, które są w NP i redukuje się do nich problem SAT",
        "inline_explanation": "(Twierdzenie Cooka udowodniło, że SAT jest NP-zupełny; skoro SAT (reprezentant trudności całej klasy) redukuje się do naszego problemu, to nasz problem też musi być NP-trudny)",
        "correct": true
      },
      {
        "text": "takie, które są w NP i redukują się do problemu SAT",
        "inline_explanation": "(to świadczy tylko o tym, że problem należy do NP, a nie że jest 'najtrudniejszy' (zupełny))",
        "correct": false
      },
      {
        "text": "z definicji należą jednocześnie do NP i co-NP",
        "inline_explanation": "(to inna klasa problemów; powszechnie uważa się, że $NPC \\neq co-NP$)",
        "correct": false
      },
      {
        "text": "należą do klasy NP, ale nie należą do P",
        "inline_explanation": "(zakładamy, że tak jest ($P \\neq NP$), ale formalnie nie zostało to udowodnione)",
        "correct": false
      }
    ],
    "explanation": "Problemy NP-zupełne to 'najtrudniejsze' problemy w klasie NP. Aby wykazać, że problem $X$ jest NP-zupełny, trzeba udowodnić dwie rzeczy: 1. $X \\in NP$ (łatwo sprawdzić rozwiązanie). 2. $X$ jest NP-trudny (każdy problem z NP można sprowadzić do $X$). W praktyce punkt 2 dowodzi się pokazując, że jakiś znany problem NP-zupełny (np. SAT) redukuje się do $X$."
  },
  {
    "id": 226,
    "question": "Co można powiedzieć o podproblemach problemu $\\pi$, wiedząc, że $\\pi$ nie należy do klasy P (jest trudny obliczeniowo)?",
    "options": [
      {
        "text": "istnieje taki jego podproblem, który należy do P",
        "inline_explanation": "(nawet najtrudniejsze problemy mają trywialne instancje (podproblemy), np. dla małych danych wejściowych, które da się rozwiązać szybko)",
        "correct": true
      },
      {
        "text": "żaden jego podproblem nie należy do P",
        "inline_explanation": "(nieprawda, zawsze znajdą się proste przypadki szczególne)",
        "correct": false
      },
      {
        "text": "każdy jego podproblem należy do klasy P",
        "inline_explanation": "(wtedy cały problem należałby do P)",
        "correct": false
      },
      {
        "text": "pojęcie podproblemu nie jest zdefiniowane",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Fakt, że ogólny problem jest trudny (np. NP-zupełny), nie oznacza, że każda jego instancja jest trudna. Często wydziela się podklasy problemów (np. SAT dla klauzul o długości 2 - 2-SAT), które są rozwiązywalne w czasie wielomianowym ($P$)."
  },
  {
    "id": 227,
    "question": "Która z poniższych złożoności czasowych jest wykładnicza?",
    "options": [
      {
        "text": "$O(\\log(10)n)$",
        "inline_explanation": "(Zapis w źródle prawdopodobnie błędny/literówka. Intencją autora była funkcja typu $10^n$. W obecnej formie to funkcja liniowa/logarytmiczna, która NIE jest wykładnicza, ale oznaczam zgodnie z kluczem)",
        "correct": true
      },
      {
        "text": "$O(n^{100})$",
        "inline_explanation": "(to złożoność wielomianowa - bardzo wysoka, ale wciąż wielomianowa)",
        "correct": false
      },
      {
        "text": "$O(n!)$",
        "inline_explanation": "(to złożoność silniowa, która rośnie jeszcze szybciej niż wykładnicza, ale w ścisłym sensie matematycznym stanowi osobną klasę)",
        "correct": false
      },
      {
        "text": "$O(n^{1/n!})$",
        "inline_explanation": "(funkcja malejąca do 1)",
        "correct": false
      }
    ],
    "explanation": "Złożoność wykładnicza ma postać $O(c^n)$, gdzie $c > 1$. Przykłady to $2^n$, $10^n$. Oznacza to, że zwiększenie danych wejściowych o 1 powoduje przemnożenie czasu obliczeń przez stałą. UWAGA: Zapis w pytaniu `log(10)n` jest mylący i prawdopodobnie wynika z błędu OCR w źródle (zamiast $10^n$)."
  },
  {
    "id": 228,
    "question": "Co nazywamy mostem grafu?",
    "options": [
      {
        "text": "krawędź grafu spójnego, której usunięcie z grafu rozspójnia go",
        "inline_explanation": "(definicja mostu - krawędź krytyczna dla spójności)",
        "correct": true
      },
      {
        "text": "krawędź, której usunięcie zwiększa liczbę spójnych składowych grafu",
        "inline_explanation": "(to równoważna definicja - jeśli graf był spójny (1 składowa) i stał się niespójny (2 składowe), liczba składowych wzrosła)",
        "correct": true
      },
      {
        "text": "minimalną liczbę krawędzi grafu, których usunięcie zmienia graf w niespójny",
        "inline_explanation": "(to definicja spójności krawędziowej grafu)",
        "correct": false
      },
      {
        "text": "maksymalną liczbę krawędzi grafu, których usunięcie zmienia graf w niespójny",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Most (bridge) w teorii grafów to krawędź, której usunięcie powoduje zwiększenie liczby spójnych składowych grafu. W grafie spójnym usunięcie mostu sprawia, że graf rozpada się na dwa odrębne kawałki."
  },
  {
    "id": 229,
    "question": "W teorii złożoności obliczeniowej wszystkie problemy decyzyjne, które w wielomianowym czasie rozwiązuje niedeterministyczna maszyna Turinga, tworzą klasę:",
    "options": [
      {
        "text": "klasa NP",
        "inline_explanation": "(skrót od Nondeterministic Polynomial time)",
        "correct": true
      },
      {
        "text": "klasa P",
        "inline_explanation": "(to problemy rozwiązywalne w czasie wielomianowym przez DETERMINISTYCZNĄ maszynę Turinga)",
        "correct": false
      },
      {
        "text": "klasa coNP",
        "inline_explanation": "(dopełnienie klasy NP - problemy, dla których 'nie' można zweryfikować w czasie wielomianowym)",
        "correct": false
      },
      {
        "text": "klasa RE",
        "inline_explanation": "(Recursively Enumerable - problemy częściowo rozstrzygalne, klasa znacznie szersza niż NP)",
        "correct": false
      }
    ],
    "explanation": "Klasa NP to zbiór problemów decyzyjnych, dla których odpowiedź TAK można zweryfikować w czasie wielomianowym (mając świadka/certyfikat). Równoważna definicja mówi, że są to problemy rozwiązywalne w czasie wielomianowym przez maszynę niedeterministyczną (która potrafi 'zgadnąć' rozwiązanie)."
  },
  {
    "id": 230,
    "question": "Generalizacja w modelu obiektowym/UML:",
    "options": [
      {
        "text": "organizuje klasy w hierarchię uogólniania/uszczegóławiania",
        "inline_explanation": "(jest to relacja między klasami - typami, a nie konkretnymi instancjami)",
        "correct": true
      },
      {
        "text": "znajduje swoje odzwierciedlenie w mechanizmie dziedziczenia interfejsów",
        "inline_explanation": "(zgodnie z kluczem egzaminacyjnym; choć w UML dziedziczenie interfejsów to często 'Realizacja', to koncepcyjnie jest to uogólnienie zachowań)",
        "correct": true
      },
      {
        "text": "organizuje obiekty w hierarchię uogólniania/uszczegóławiania",
        "inline_explanation": "(generalizacja dotyczy klas (szablonów), a nie obiektów (instancji))",
        "correct": false
      },
      {
        "text": "organizuje klasy w hierarchię całości/części",
        "inline_explanation": "(to definicja agregacji lub kompozycji)",
        "correct": false
      },
      {
        "text": "znajduje swoje odzwierciedlenie w mechanizmie dziedziczenia implementacji",
        "inline_explanation": "(jest to najbardziej typowy przykład generalizacji, choć w tym konkretnym kluczu nacisk położono na interfejsy i hierarchię klas)",
        "correct": false
      }
    ],
    "explanation": "Generalizacja to relacja 'jest rodzajem' (is-a). Łączy ona klasę bardziej ogólną (nadklasę) z klasą bardziej szczegółową (podklasą). Kluczowe jest rozróżnienie, że relacja ta zachodzi na poziomie definicji typów (klas), a nie na poziomie struktury obiektów w pamięci."
  },
  {
    "id": 231,
    "question": "Kompozycja (silna agregacja):",
    "options": [
      {
        "text": "ogranicza powiązanie obiektu części do jednego obiektu całości",
        "inline_explanation": "(część nie może należeć do dwóch całości jednocześnie, np. jeden Silnik fizycznie nie może być w dwóch Samochodach)",
        "correct": true
      },
      {
        "text": "jest silnym powiązaniem z czasem życia części ograniczonym do czasu życia całości",
        "inline_explanation": "(gdy niszczona jest Całość, niszczone są też Części)",
        "correct": true
      },
      {
        "text": "całość jest odpowiedzialna za zarządzanie tworzeniem i usuwaniem części",
        "inline_explanation": "(wynika to z cyklu życia; obiekt nadrzędny zarządza pamięcią swoich składowych)",
        "correct": true
      },
      {
        "text": "ściśle związana z delegacją",
        "inline_explanation": "(kompozycja + delegacja to alternatywa dla dziedziczenia; obiekt 'zewnętrzny' zleca zadania swojemu obiektowi składowemu)",
        "correct": true
      },
      {
        "text": "ogranicza powiązanie klasy części do jednej klasy całości",
        "inline_explanation": "(nieprawda: klasa 'Koło' może być częścią klasy 'Samochód' i klasy 'Rower'; ograniczenie dotyczy konkretnych obiektów, a nie typów)",
        "correct": false
      }
    ],
    "explanation": "Kompozycja to relacja 'posiada' (has-a) o silnym charakterze. Na diagramach UML oznaczana jest wypełnionym rombem. Kluczowe cechy to: wyłączna własność (część ma jednego właściciela) i wspólny cykl życia."
  },
  {
    "id": 232,
    "question": "Relacja zależności (Dependency) wskazuje, że:",
    "options": [
      {
        "text": "obiekt klasy może być argumentem wywołania usługi innej klasy",
        "inline_explanation": "(relacja 'uses-a', np. gdy metoda klasy A przyjmuje obiekt klasy B jako parametr, ale nie przechowuje go na stałe jako pola)",
        "correct": true
      },
      {
        "text": "implementacja klasy może się zmienić, gdy zmieni się implementacja innej klasy",
        "inline_explanation": "(skoro A korzysta z B, to zmiana w B może wymusić zmiany w A)",
        "correct": true
      },
      {
        "text": "klasa dostarcza implementacji usług interfejsu",
        "inline_explanation": "(to definicja Realizacji)",
        "correct": false
      },
      {
        "text": "istnieje szczególne powiązanie między klasami",
        "inline_explanation": "(zbyt ogólne; 'szczególne powiązanie' zazwyczaj sugeruje Asocjację, która jest trwalsza niż Zależność)",
        "correct": false
      }
    ],
    "explanation": "Zależność (przerywana strzałka w UML) to najsłabsza forma powiązania. Mówi o tym, że jeden element 'używa' drugiego tymczasowo. Jeśli zmienimy element niezależny (dostawcę), może to wpłynąć na element zależny (klienta)."
  },
  {
    "id": 233,
    "question": "Relacja realizacji (Realization) wskazuje, że:",
    "options": [
      {
        "text": "klasa dostarcza implementacji usług interfejsu",
        "inline_explanation": "(klasa zobowiązuje się spełnić kontrakt zdefiniowany przez interfejs)",
        "correct": true
      },
      {
        "text": "obiekt klasy może być argumentem wywołania usługi innej klasy",
        "inline_explanation": "(to Zależność)",
        "correct": false
      },
      {
        "text": "klasa realizuje usługi delegowane z innej klasy",
        "inline_explanation": "(to mechanizm delegacji, a nie relacja realizacji w sensie UML)",
        "correct": false
      },
      {
        "text": "klasa wykorzystuje usługi interfejsu",
        "inline_explanation": "(to Zależność od interfejsu, a nie jego realizacja)",
        "correct": false
      }
    ],
    "explanation": "Realizacja (przerywana linia z pustym trójkątem) występuje między klasą a interfejsem. Oznacza, że klasa definiuje zachowania (metody), które zostały zadeklarowane w interfejsie."
  },
  {
    "id": 234,
    "question": "Wielokrotne użycie (Reuse) wspierane jest w modelu obiektowym przez:",
    "options": [
      {
        "text": "kompozycje z delegacją roli",
        "inline_explanation": "(tzw. 'Black-box reuse' - budowanie nowych funkcjonalności poprzez składanie gotowych komponentów)",
        "correct": true
      },
      {
        "text": "istnienie klas obiektów",
        "inline_explanation": "(klasa jest szablonem wielokrotnego użytku do tworzenia obiektów)",
        "correct": true
      },
      {
        "text": "dziedziczenie implementacji",
        "inline_explanation": "(tzw. 'White-box reuse' - przejmowanie kodu z klasy bazowej)",
        "correct": true
      },
      {
        "text": "kwalifikowane powiązania",
        "inline_explanation": "(to technika ułatwiająca nawigację po asocjacjach (np. słowniki), a nie mechanizm reuse'u)",
        "correct": false
      }
    ],
    "explanation": "Wielokrotne użycie to fundament OOP. Osiąga się je głównie na dwa sposoby: przez dziedziczenie (łatwe, ale tworzy silne sprzężenia) oraz kompozycję (elastyczniejsza, ale wymaga więcej kodu - delegacji)."
  },
  {
    "id": 235,
    "question": "Celem testowania oprogramowania jest:",
    "options": [
      {
        "text": "zbadanie zgodności z wymaganiami",
        "inline_explanation": "(weryfikacja - czy produkt spełnia specyfikację)",
        "correct": true
      },
      {
        "text": "wykrycie błędów w oprogramowaniu",
        "inline_explanation": "(podstawowy cel operacyjny testowania)",
        "correct": true
      },
      {
        "text": "zbadanie zgodności z oczekiwaniami użytkownika",
        "inline_explanation": "(walidacja/testy akceptacyjne - czy zbudowaliśmy właściwy produkt)",
        "correct": true
      },
      {
        "text": "sprawdzenie poprawności komentarzy w kodzie",
        "inline_explanation": "(to element przeglądu kodu/audytu, a nie testowania dynamicznego)",
        "correct": false
      },
      {
        "text": "ocena jakości oprogramowania",
        "inline_explanation": "(testowanie dostarcza metryk do oceny jakości, np. niezawodności)",
        "correct": true
      },
      {
        "text": "zdefiniowanie jakości kodu",
        "inline_explanation": "(definicja jakości następuje na etapie wymagań niefunkcjonalnych, testowanie jedynie weryfikuje ten stan)",
        "correct": false
      }
    ],
    "explanation": "Testowanie ma wiele celów w zależności od etapu. Wczesne testy szukają błędów (defektów), testy systemowe weryfikują wymagania, a testy akceptacyjne walidują przydatność biznesową. Wszystkie te działania składają się na ocenę jakości produktu."
  },
  {
    "id": 236,
    "question": "Jakie są główne aktywności w modelu spiralnym (Boehma)?",
    "options": [
      {
        "text": "Planowanie, Analiza Ryzyka, Konstrukcja, Walidacja (Ocena)",
        "inline_explanation": "(model spiralny kładzie największy nacisk na cykliczną analizę ryzyka przed rozpoczęciem każdej kolejnej fazy konstrukcji)",
        "correct": true
      },
      {
        "text": "Szybki Projekt, Budowa Prototypu, Ocena Prototypu, Redefinicja Prototypu",
        "inline_explanation": "(to opis modelu prototypowania)",
        "correct": false
      },
      {
        "text": "Analiza Wymagań, Projektowanie, Kodowanie, Testowanie",
        "inline_explanation": "(to klasyczny model kaskadowy/waterfall lub etapy w modelu iteracyjnym)",
        "correct": false
      },
      {
        "text": "Definiowanie, Prototypowanie, Testowanie, Dostarczenie produktu",
        "inline_explanation": "(uproszczony schemat wytwarzania, nie oddaje istoty spirali)",
        "correct": false
      }
    ],
    "explanation": "Model spiralny dzieli proces na cztery ćwiartki (sektory): 1. Ustalanie celów (Planowanie), 2. Rozpoznanie i redukcja zagrożeń (Analiza Ryzyka), 3. Tworzenie i testowanie (Konstrukcja), 4. Ocena i planowanie kolejnej fazy (Walidacja/Ewaluacja)."
  },
  {
    "id": 237,
    "question": "Jakiego widoku nie znajdziesz w modelu architektonicznym Kruchtena (model 4+1)?",
    "options": [
      {
        "text": "przepływu danych",
        "inline_explanation": "(diagramy DFD to domena analizy strukturalnej, nie są częścią modelu 4+1)",
        "correct": true
      },
      {
        "text": "przypadków użycia",
        "inline_explanation": "(widok +1, spajający wszystkie pozostałe)",
        "correct": false
      },
      {
        "text": "konstrukcji (implementacji)",
        "inline_explanation": "(widok opisujący organizację modułów w środowisku programistycznym)",
        "correct": false
      },
      {
        "text": "logicznego",
        "inline_explanation": "(widok opisujący funkcjonalność, np. diagramy klas)",
        "correct": false
      }
    ],
    "explanation": "Model '4+1' Philippe'a Kruchtena opisuje architekturę systemu za pomocą 5 perspektyw: 1. Widok Logiczny (Logical), 2. Widok Procesów (Process), 3. Widok Implementacji/Konstrukcji (Development), 4. Widok Fizyczny/Wdrożenia (Physical). Piątym elementem ('+1') są Scenariusze/Przypadki Użycia, które integrują i ilustrują działanie pozostałych widoków."
  },
  {
    "id": 238,
    "question": "Jaką rolę na diagramach klas UML pełni kompozycja?",
    "options": [
      {
        "text": "jest związkiem typu część-całość między obiektami",
        "inline_explanation": "(jest to tzw. silna agregacja, gdzie część nie może istnieć bez całości)",
        "correct": true
      },
      {
        "text": "jest związkiem typu gen-spec (generalizacja-specjalizacja) między instancjami klasy",
        "inline_explanation": "(relacja gen-spec to dziedziczenie, dotyczy klas, a nie instancji)",
        "correct": false
      },
      {
        "text": "wspomaga graficzne rozlokowanie symboli klas na diagramie",
        "inline_explanation": "(kompozycja ma znaczenie semantyczne, a nie wizualne/layoutowe)",
        "correct": false
      },
      {
        "text": "oznacza ukrywanie złożoności obiektów przed użytkownikiem",
        "inline_explanation": "(to definicja hermetyzacji/enkapsulacji)",
        "correct": false
      }
    ],
    "explanation": "Kompozycja (wypełniony romb) to szczególny przypadek asocjacji. Oznacza, że obiekt podrzędny (część) należy wyłącznie do jednego obiektu nadrzędnego (całość) i jego cykl życia jest ściśle powiązany z cyklem życia całości (gdy usuwamy samochód, usuwamy też jego silnik)."
  },
  {
    "id": 239,
    "question": "Jednym z celów inżynierii oprogramowania jest tworzenie oprogramowania, które jest:",
    "options": [
      {
        "text": "wolne od błędów",
        "inline_explanation": "(jest to cel idealny, do którego się dąży poprzez testowanie i QA)",
        "correct": true
      },
      {
        "text": "dostarczane zgodnie z harmonogramem",
        "inline_explanation": "(terminowość to kluczowy parametr zarządczy projektu)",
        "correct": true
      },
      {
        "text": "niezawodne i efektywne",
        "inline_explanation": "(cechy jakościowe oprogramowania)",
        "correct": true
      },
      {
        "text": "niezgodne z wymaganiami",
        "inline_explanation": "(oczywisty fałsz)",
        "correct": false
      }
    ],
    "explanation": "Inżynieria oprogramowania dąży do produkcji wysokiej jakości oprogramowania w ramach ustalonego budżetu i czasu. Trójkąt projektowy (Zakres/Jakość, Czas, Koszt) definiuje te cele."
  },
  {
    "id": 240,
    "question": "Przykładem ryzyka występującego podczas wytwarzania oprogramowania jest:",
    "options": [
      {
        "text": "odejście kluczowych osób z zespołu projektowego, zanim produkt zostanie wdrożony",
        "inline_explanation": "(ryzyko personalne - utrata wiedzy i spowolnienie prac)",
        "correct": true
      },
      {
        "text": "problemy ze zdefiniowaniem specyfikacji produktu",
        "inline_explanation": "(ryzyko wymagań - niestabilne lub niejasne wymagania to najczęstsza przyczyna porażek)",
        "correct": true
      },
      {
        "text": "konkurenci mogą sprzedawać taniej system o podobnej funkcjonalności",
        "inline_explanation": "(jest to ryzyko biznesowe/rynkowe, a nie bezpośrednio związane z procesem wytwarzania kodu, choć wpływa na projekt)",
        "correct": false
      },
      {
        "text": "wykonywanie kolejnych faz zgodnie z ustalonym harmonogramem",
        "inline_explanation": "(to jest sukces, a nie ryzyko)",
        "correct": false
      }
    ],
    "explanation": "Zarządzanie ryzykiem to kluczowy element inżynierii oprogramowania. Ryzyka dzielimy m.in. na projektowe (np. odejście pracownika, opóźnienia dostaw), techniczne (np. nowa, nieznana technologia) i biznesowe (np. zmiana prawa, działania konkurencji)."
  },
  {
    "id": 241,
    "question": "Tworzenie modelu obiektowego z istniejącej relacyjnej bazy danych (lub kodu) jest określane jako:",
    "options": [
      {
        "text": "reverse engineering (inżynieria wsteczna)",
        "inline_explanation": "(proces odtwarzania modelu/projektu na podstawie gotowego produktu)",
        "correct": true
      },
      {
        "text": "forward engineering (inżynieria w przód)",
        "inline_explanation": "(proces klasyczny: model -> kod/baza danych)",
        "correct": false
      },
      {
        "text": "backward engineering",
        "inline_explanation": "(niepoprawna nazwa)",
        "correct": false
      },
      {
        "text": "inverse engineering",
        "inline_explanation": "(niepoprawna nazwa)",
        "correct": false
      }
    ],
    "explanation": "Inżynieria wsteczna (Reverse Engineering) w kontekście baz danych polega na analizie schematu bazy (tabel, kluczy obcych) i automatycznym wygenerowaniu na tej podstawie diagramu klas lub encji (ERD)."
  },
  {
    "id": 242,
    "question": "Stosowanie techniki prototypowania jest zalecane:",
    "options": [
      {
        "text": "dla zespołów programistów, którym brakuje znajomości dziedziny",
        "inline_explanation": "(prototyp pozwala zweryfikować zrozumienie problemu bez budowania pełnego systemu)",
        "correct": true
      },
      {
        "text": "gdy istnieje trudność uzyskania pełnej informacji o wymaganiach systemu",
        "inline_explanation": "(użytkownik często 'nie wie czego chce, dopóki tego nie zobaczy' - prototyp pomaga wydobyć wymagania)",
        "correct": true
      },
      {
        "text": "gdy liczy się czas dostarczenia",
        "inline_explanation": "(prototypowanie może wydłużyć fazę początkową; w pośpiechu częściej stosuje się MVP, ale sam prototyp 'do kosza' to dodatkowy koszt czasu)",
        "correct": false
      },
      {
        "text": "aplikacji budowanej w oparciu o frameworki",
        "inline_explanation": "(użycie frameworków nie determinuje modelu cyklu życia)",
        "correct": false
      }
    ],
    "explanation": "Prototypowanie jest najlepszą metodą redukcji ryzyka związanego z wymaganiami. Stosuje się je, gdy wymagania są niejasne, złożone lub gdy interfejs użytkownika jest krytycznym elementem systemu."
  },
  {
    "id": 243,
    "question": "Które z poniższych stwierdzeń NIE jest celem budowy modeli analitycznych:",
    "options": [
      {
        "text": "opracowanie rozwiązań problemów (projektowanie)",
        "inline_explanation": "(analiza odpowiada na pytanie 'co system ma robić?', a projektowanie 'jak ma to robić?'; opracowanie rozwiązań to domena projektowania)",
        "correct": true
      },
      {
        "text": "ustalenie wszystkich czynników / warunków w dziedzinie przedmiotowej, które mogą wpłynąć na decyzje projektowe",
        "inline_explanation": "(analiza otoczenia i dziedziny problemu jest kluczowym celem)",
        "correct": false
      },
      {
        "text": "stworzenie logicznego modelu systemu, opisującego sposób realizacji wymagań, ale bez szczegółów implementacyjnych",
        "inline_explanation": "(model logiczny to główny produkt fazy analizy)",
        "correct": false
      }
    ],
    "explanation": "Modele analityczne mają na celu zrozumienie problemu, otoczenia i wymagań. Wynikiem analizy jest logiczny model systemu (np. diagramy przypadków użycia, model dziedziny), który opisuje CO system ma robić. Szczegóły techniczne i konkretne rozwiązania algorytmiczne/implementacyjne to zadanie fazy projektowania."
  },
  {
    "id": 244,
    "question": "Wstępna próba zdefiniowania elementów systemu oraz ich wzajemnych relacji, organizowanie tych elementów w dobrze określone warstwy z wyraźnie nakreślonymi zależnościami nazywa się analizą:",
    "options": [
      {
        "text": "architektoniczną",
        "inline_explanation": "(definicja architektury to właśnie podział na główne komponenty/warstwy i relacje między nimi)",
        "correct": true
      },
      {
        "text": "przypadków użycia",
        "inline_explanation": "(koncentruje się na funkcjonalności z punktu widzenia użytkownika)",
        "correct": false
      },
      {
        "text": "strukturalną",
        "inline_explanation": "(metodologia oparta na funkcjach i przepływie danych)",
        "correct": false
      },
      {
        "text": "systemową",
        "inline_explanation": "(pojęcie ogólne, obejmujące całość procesu analizy)",
        "correct": false
      }
    ],
    "explanation": "Analiza architektoniczna to proces wysokopoziomowego projektowania struktury systemu. Decyduje o podziale na warstwy (np. prezentacji, logiki biznesowej, danych), moduły i interfejsy między nimi."
  },
  {
    "id": 245,
    "question": "Którego z poniższych narzędzi/metodyk zazwyczaj nie wymienia się jako głównego narzędzia 'analizy systemowej' (w rozumieniu metodyki modelowania całego systemu)?",
    "options": [
      {
        "text": "Decision Tree (Drzewo decyzyjne)",
        "inline_explanation": "(jest to technika opisu logiki decyzyjnej, a nie kompletna metodyka modelowania systemu jak pozostałe)",
        "correct": true
      },
      {
        "text": "Data Flow Diagram (DFD)",
        "inline_explanation": "(podstawowe narzędzie analizy strukturalnej)",
        "correct": false
      },
      {
        "text": "Object Modelling Technique (OMT)",
        "inline_explanation": "(prekursor UML, metodyka obiektowa)",
        "correct": false
      },
      {
        "text": "HOOD (Hierarchical Object-Oriented Design)",
        "inline_explanation": "(metodyka projektowania systemów, często używana w systemach wbudowanych/real-time)",
        "correct": false
      }
    ],
    "explanation": "DFD, OMT i HOOD to kompletne języki lub metodyki modelowania systemów. Drzewa decyzyjne są użytecznym, ale tylko pomocniczym narzędziem do wizualizacji algorytmów lub reguł biznesowych."
  },
  {
    "id": 246,
    "question": "Które z podanych rodzajów wymagań nie są określane podczas przygotowywania definicji wymagań systemowych (poziom ogólny)?",
    "options": [
      {
        "text": "szczegółowe wymagania funkcjonalne",
        "inline_explanation": "(na etapie definicji systemowej operujemy na poziomie abstrakcyjnym; szczegóły są doprecyzowywane w specyfikacji wymagań)",
        "correct": true
      },
      {
        "text": "abstrakcyjne wymagania funkcjonalne",
        "inline_explanation": "(określane - mówią ogólnie, co system ma robić)",
        "correct": false
      },
      {
        "text": "cechy lub zachowania, których system nie powinien przejawiać",
        "inline_explanation": "(określane - wymagania negatywne/ograniczenia)",
        "correct": false
      },
      {
        "text": "właściwości systemu",
        "inline_explanation": "(określane - np. wydajność, niezawodność)",
        "correct": false
      }
    ],
    "explanation": "W inżynierii wymagań rozróżnia się 'Definicję Wymagań' (język naturalny, zrozumiały dla klienta, poziom ogólny) od 'Specyfikacji Wymagań' (język techniczny, detale dla programistów). Szczegółowe funkcje należą do tego drugiego etapu."
  },
  {
    "id": 247,
    "question": "Które z wymienionych czynności występują dla wszystkich (podstawowych) procesów wytwarzania oprogramowania?",
    "options": [
      {
        "text": "pozyskiwanie wymagań (Inżynieria wymagań)",
        "inline_explanation": "(bez wymagań nie wiemy co budować)",
        "correct": true
      },
      {
        "text": "specyfikowanie oprogramowania",
        "inline_explanation": "(zapisanie ustaleń)",
        "correct": true
      },
      {
        "text": "walidacja oprogramowania",
        "inline_explanation": "(sprawdzenie czy to co zbudowaliśmy działa i spełnia cel)",
        "correct": true
      },
      {
        "text": "budowa i ulepszanie prototypów",
        "inline_explanation": "(specyficzne dla modelu prototypowania)",
        "correct": false
      },
      {
        "text": "retrospektywa celem polepszenia procesu",
        "inline_explanation": "(specyficzne dla metodyk zwinnych/Scrum)",
        "correct": false
      },
      {
        "text": "ciągła integracja (CI)",
        "inline_explanation": "(praktyka DevOps, nie występuje w klasycznym Waterfallu)",
        "correct": false
      }
    ],
    "explanation": "Niezależnie od modelu (Waterfall, Agile, Spiral), cztery fundamentalne działania inżynierii oprogramowania to: 1. Specyfikacja (Wymagania), 2. Projektowanie i Implementacja (Konstrukcja), 3. Walidacja (Testowanie), 4. Ewolucja (Utrzymanie)."
  },
  {
    "id": 248,
    "question": "Dobry zapis wymagania powinien zawierać (cecha śladowalności/traceability):",
    "options": [
      {
        "text": "informację o uzależnieniu danego wymagania od innych wymagań lub powiązaniu z nimi",
        "inline_explanation": "(niezbędne do analizy wpływu zmian)",
        "correct": true
      },
      {
        "text": "informację o pochodzeniu danego wymagania i jego uzasadnienie",
        "inline_explanation": "(kto zgłosił wymaganie i po co - 'source & rationale')",
        "correct": true
      },
      {
        "text": "informację o uzależnieniu projektu od wymagania, tj. powiązaniu danego wymagania ze składnikami systemu, które je implementują",
        "inline_explanation": "(pozwala sprawdzić pokrycie wymagań w kodzie)",
        "correct": true
      },
      {
        "text": "informację o kolejności wprowadzenia danego wymagania w stosunku do innych",
        "inline_explanation": "(harmonogram jest wtórny wobec samej treści wymagania; priorytety są ważne, ale ścisła sekwencja wynika z planu projektu)",
        "correct": false
      }
    ],
    "explanation": "Śladowalność (Traceability) to kluczowa cecha profesjonalnego zarządzania wymaganiami. Musimy wiedzieć skąd wymaganie przyszło (żeby wiedzieć kogo pytać o szczegóły), z czym się wiąże (żeby nie zepsuć czegoś przy zmianie) i gdzie jest zaimplementowane (żeby to przetestować)."
  },
  {
    "id": 249,
    "question": "Prototypowanie z porzuceniem (throw-away prototyping) jest wariantem ewolucyjnego tworzenia oprogramowania, w którym:",
    "options": [
      {
        "text": "tworzony jest fragment systemu zwany prototypem, odpowiadający ograniczonej części wymagań, celem eksperymentalnego rozeznania wymagań klienta",
        "inline_explanation": "(główny cel: zrozumienie wymagań)",
        "correct": true
      },
      {
        "text": "nie przywiązuje wagi do jakości oprogramowania wytworzonego prototypu ani nawet jego zdolności do funkcjonowania, o ile nie przeszkadza to w wykorzystaniu go do realizacji jego głównego celu",
        "inline_explanation": "(kod idzie 'do kosza', więc jakość, wydajność czy bezpieczeństwo są drugorzędne; ma działać tylko 'na pokaz')",
        "correct": true
      },
      {
        "text": "ze względu na dwukrotną realizację systemu wydłużony jest znacznie czas realizacji",
        "inline_explanation": "(to wada/konsekwencja, a nie definicja wariantu)",
        "correct": false
      },
      {
        "text": "nie powstaje prawie żadna dokumentacja projektowa",
        "inline_explanation": "(dokumentacja może powstawać, szczególnie wnioski z analizy prototypu)",
        "correct": false
      }
    ],
    "explanation": "Prototypowanie z porzuceniem stosuje się, gdy wymagania są niejasne ('klient nie wie, czego chce'). Buduje się szybką atrapę (mockup), pokazuje klientowi, zbiera uwagi, a sam kod wyrzuca, budując system docelowy 'na czysto' w oparciu o zdobytą wiedzę."
  },
  {
    "id": 250,
    "question": "Do modeli iteracyjnych tworzenia oprogramowania zaliczamy:",
    "options": [
      {
        "text": "metodę przyrostową",
        "inline_explanation": "(iteracyjne przyrastanie funkcjonalności w kolejnych wersjach)",
        "correct": true
      },
      {
        "text": "model kaskadowy (Waterfall)",
        "inline_explanation": "(to model sekwencyjny, nie iteracyjny)",
        "correct": false
      },
      {
        "text": "model spiralny tworzenia oprogramowania",
        "inline_explanation": "(każdy obrót spirali to kolejna iteracja procesu)",
        "correct": true
      },
      {
        "text": "programowanie ekstremalne (XP)",
        "inline_explanation": "(metodyka zwinna oparta na bardzo krótkich iteracjach)",
        "correct": true
      },
      {
        "text": "metodykę Kanban",
        "inline_explanation": "(Kanban opiera się na ciągłym przepływie (Flow) i limitowaniu prac w toku (WIP), a nie na sztywnych iteracjach czasowych jak Scrum czy XP)",
        "correct": false
      },
      {
        "text": "ewolucyjne tworzenie oprogramowania",
        "inline_explanation": "(choć jest bliskie iteracyjnemu, często klasyfikuje się je osobno jako proces ciągłego odkrywania, ale w tym kluczu nie zostało zaznaczone)",
        "correct": false
      }
    ],
    "explanation": "Modele iteracyjne polegają na cyklicznym powtarzaniu sekwencji zadań (analiza-projekt-kodowanie-testy) w celu stopniowego ulepszania produktu. Należą do nich: model przyrostowy, spiralny, RUP oraz większość metodyk zwinnych (Scrum, XP)."
  },
  {
    "id": 251,
    "question": "Inspekcja (przegląd) wymagań jest:",
    "options": [
      {
        "text": "metodą walidacji wymagań",
        "inline_explanation": "(służy potwierdzeniu, czy wymagania są poprawne, kompletne i zrozumiałe)",
        "correct": true
      },
      {
        "text": "nazywana formalną bądź nieformalną",
        "inline_explanation": "(zależnie od tego, czy postępuje według ścisłej procedury (np. Fagan inspection), czy jest luźną rozmową)",
        "correct": true
      },
      {
        "text": "procesem 'ręcznym' polegającym na grupowym czytaniu dokumentacji wymagań",
        "inline_explanation": "(nie wymaga uruchamiania kodu, jest to weryfikacja statyczna)",
        "correct": true
      },
      {
        "text": "niepodobna do inspekcji programów (kodu)",
        "inline_explanation": "(jest bardzo podobna – zmienia się tylko przedmiot przeglądu)",
        "correct": false
      }
    ],
    "explanation": "Inspekcje to technika weryfikacji statycznej. W przypadku wymagań, zespół (często z udziałem klienta) analizuje dokument pod kątem niespójności, niejednoznaczności i błędów, zanim powstanie jakikolwiek kod."
  },
  {
    "id": 252,
    "question": "Systemy odziedziczone (Legacy Systems):",
    "options": [
      {
        "text": "to systemy starsze niż kilka-kilkanaście lat, których działanie pozostaje krytycznym czynnikiem z punktu widzenia funkcjonowania instytucji, ale technologia nie odpowiada aktualnym potrzebom",
        "inline_explanation": "(są przestarzałe technologicznie, ale kluczowe biznesowo)",
        "correct": true
      },
      {
        "text": "obejmują oprogramowanie, sprzęt na którym może ono działać, dane użytkowe, procedury biznesowe",
        "inline_explanation": "(to cały ekosystem, 'bagaż historyczny', a nie tylko plik .exe)",
        "correct": true
      },
      {
        "text": "mają oprogramowanie i sprzęt niezmieniony od czasów ich zainstalowania",
        "inline_explanation": "(często były wielokrotnie łatane i modyfikowane, co tylko utrudnia ich utrzymanie)",
        "correct": false
      },
      {
        "text": "można tylko całkowicie wycofać i/lub zastąpić nowymi systemami",
        "inline_explanation": "(często jest to zbyt ryzykowne lub kosztowne; stosuje się strategie: opakowania (wrapping), refaktoryzacji lub migracji stopniowej)",
        "correct": false
      }
    ],
    "explanation": "Systemy legacy to 'święte krowy' w wielu firmach (banki, ubezpieczenia). Są trudne w utrzymaniu (brak dokumentacji, stary język np. COBOL), ale nie można ich wyłączyć, bo przetwarzają kluczowe dane."
  },
  {
    "id": 253,
    "question": "Jakie aspekty powinien uwzględniać pełny model systemu w podejściu strukturalnym do analizy i projektowania?",
    "options": [
      {
        "text": "aspekt funkcjonalny, aspekt danych i ich powiązań, oraz dynamiki systemu",
        "inline_explanation": "(trzy filary analizy strukturalnej)",
        "correct": true
      },
      {
        "text": "aspekt funkcjonalny, aspekt danych i ich powiązań",
        "inline_explanation": "(brak dynamiki - niepełny obraz)",
        "correct": false
      },
      {
        "text": "aspekt funkcjonalny i aspekt dynamiki systemu",
        "inline_explanation": "(brak danych - niepełny obraz)",
        "correct": false
      },
      {
        "text": "aspekt danych i ich powiązań, aspekt dynamiki systemu",
        "inline_explanation": "(brak funkcji - niepełny obraz)",
        "correct": false
      }
    ],
    "explanation": "Podejście strukturalne (np. Yourdona) modeluje system z trzech perspektyw: Co system robi? (Funkcje - DFD), Na czym operuje? (Dane - ERD), Jak reaguje na czas/zdarzenia? (Dynamika - STD)."
  },
  {
    "id": 254,
    "question": "Aspekt funkcjonalny systemu informatycznego modelowany jest w podejściu strukturalnym przy pomocy:",
    "options": [
      {
        "text": "Data Flow Diagrams (DFD)",
        "inline_explanation": "(diagramy przepływu danych pokazują procesy przetwarzające dane wejściowe na wyjściowe)",
        "correct": true
      },
      {
        "text": "Entity Relationship Diagrams (ERD)",
        "inline_explanation": "(modelują dane)",
        "correct": false
      },
      {
        "text": "State Transition Diagrams (STD)",
        "inline_explanation": "(modelują dynamikę/stany)",
        "correct": false
      },
      {
        "text": "Structure Charts",
        "inline_explanation": "(używane w fazie projektowania do pokazania hierarchii modułów)",
        "correct": false
      }
    ],
    "explanation": "DFD to podstawowe narzędzie analityka strukturalnego. Pozwala zdekomponować skomplikowany system na mniejsze funkcje (procesy) i prześledzić drogę informacji."
  },
  {
    "id": 255,
    "question": "Które z wymienionych podziałów wymagań niefunkcjonalnych są wyczerpujące i rozłączne (wg klasyfikacji Sommerville'a)?",
    "options": [
      {
        "text": "produktowe, organizacyjne, zewnętrzne",
        "inline_explanation": "(wymagania dotyczące samego produktu (np. wydajność), procesu tworzenia w organizacji (np. standardy) oraz czynników zewnętrznych (np. prawo, interoperacyjność))",
        "correct": true
      },
      {
        "text": "produktowe, organizacyjne, prawne",
        "inline_explanation": "(prawne zawierają się w zewnętrznych)",
        "correct": false
      },
      {
        "text": "produktowe, prawne, parametryczne",
        "inline_explanation": "(niepełna klasyfikacja)",
        "correct": false
      },
      {
        "text": "produktowe, zewnętrzne, strategiczne",
        "inline_explanation": "(niepełna klasyfikacja)",
        "correct": false
      }
    ],
    "explanation": "Ian Sommerville w swojej książce 'Software Engineering' proponuje podział wymagań niefunkcjonalnych na trzy główne grupy: Produktowe (Product), Organizacyjne (Organizational) i Zewnętrzne (External)."
  },
  {
    "id": 256,
    "question": "Wymień elementy modelu środowiskowego w strukturalnym podejściu do analizy i projektowania systemów informatycznych:",
    "options": [
      {
        "text": "opis celu systemu, lista zdarzeń, diagram kontekstowy",
        "inline_explanation": "(model środowiskowy definiuje granicę systemu i jego interakcję z otoczeniem)",
        "correct": true
      },
      {
        "text": "ERD, DFD, STD",
        "inline_explanation": "(to model wnętrza systemu/behawioralny)",
        "correct": false
      },
      {
        "text": "diagram kontekstowy, słownik danych, specyfikacja funkcji",
        "inline_explanation": "(specyfikacja funkcji dotyczy wnętrza systemu)",
        "correct": false
      },
      {
        "text": "opis celu systemu, wymagania funkcjonalne, wymagania niefunkcjonalne",
        "inline_explanation": "(zbyt ogólne pojęcia inżynierii wymagań, nie specyficzne dla modelu strukturalnego)",
        "correct": false
      }
    ],
    "explanation": "W metodyce strukturalnej analizę zaczyna się od zdefiniowania 'Modelu Środowiskowego' (co jest na zewnątrz?), a dopiero potem tworzy się 'Model Behawioralny' (co jest w środku?). Model środowiskowy składa się z Diagramu Kontekstowego (granice), Listy Zdarzeń (bodźce z zewnątrz) i Deklaracji Celu."
  },
  {
    "id": 257,
    "question": "Jaki zestaw diagramów jest używany w metodyce strukturalnej analizy i projektowania systemów informatycznych do pokazania wszystkich aspektów modelowanego systemu?",
    "options": [
      {
        "text": "DFD, ERD i STD (lub ELH - Entity Life History)",
        "inline_explanation": "(Funkcje + Dane + Czas/Stany)",
        "correct": true
      },
      {
        "text": "DFD i ERD",
        "inline_explanation": "(brak dynamiki)",
        "correct": false
      },
      {
        "text": "DFD i STD",
        "inline_explanation": "(brak danych)",
        "correct": false
      },
      {
        "text": "DFD, ERD i STC",
        "inline_explanation": "(STC to Structure Chart, diagram projektowy, a nie analityczny model dynamiki)",
        "correct": false
      }
    ],
    "explanation": " Pełny model systemu musi odpowiadać na trzy pytania: Jakie dane przechowujemy? (ERD), Jak je przetwarzamy? (DFD), Kiedy te procesy zachodzą? (STD)."
  },
  {
    "id": 258,
    "question": "Które obiekty graficzne są używane do tworzenia diagramu kontekstowego (Context Diagram) w metodyce strukturalnej analizy?",
    "options": [
      {
        "text": "proces, przepływ danych (data flow), obiekt zewnętrzny (external entity)",
        "inline_explanation": "(diagram kontekstowy to DFD poziomu 0: jeden proces reprezentujący cały system, terminatory zewnętrzne i strzałki przepływu)",
        "correct": true
      },
      {
        "text": "proces, przepływ danych, magazyn danych",
        "inline_explanation": "(magazyn danych jest elementem wewnętrznym systemu, nie rysuje się go na diagramie kontekstowym)",
        "correct": false
      },
      {
        "text": "proces, obiekt zewnętrzny, magazyn danych",
        "inline_explanation": "(magazyn danych jest błędny w tym kontekście)",
        "correct": false
      },
      {
        "text": "przepływ danych, obiekt zewnętrzny, magazyn danych",
        "inline_explanation": "(brak procesu - diagram musi mieć co najmniej jeden proces)",
        "correct": false
      }
    ],
    "explanation": "Diagram kontekstowy traktuje cały system jako jedną 'czarną skrzynkę' (pojedynczy proces, zazwyczaj o numerze 0). Jego celem jest pokazanie interakcji systemu ze światem zewnętrznym (użytkownikami, innymi systemami), dlatego nie pokazuje się na nim wewnętrznych magazynów danych."
  },
  {
    "id": 259,
    "question": "Wybierz nazwy wszystkich obiektów graficznych używanych do konstruowania DFD (Data Flow Diagram) - diagramów przepływu danych w metodyce strukturalnej:",
    "options": [
      {
        "text": "proces (process)",
        "inline_explanation": "(symbolizuje przekształcanie danych wejściowych w wyjściowe)",
        "correct": true
      },
      {
        "text": "obiekt zewnętrzny (external entity / terminator)",
        "inline_explanation": "(źródło lub cel danych spoza systemu, np. użytkownik, inny system)",
        "correct": true
      },
      {
        "text": "magazyn danych (data store)",
        "inline_explanation": "(dane w spoczynku, np. plik, baza danych)",
        "correct": true
      },
      {
        "text": "przepływ danych (data flow)",
        "inline_explanation": "(strzałka pokazująca drogę przemieszczania się informacji)",
        "correct": true
      }
    ],
    "explanation": "Diagramy DFD (w notacji Yourdona/DeMarco lub Gane'a/Sarsona) składają się z zaledwie czterech elementów: Procesów (kółka/zaokrąglone prostokąty), Magazynów (linie równoległe/otwarte prostokąty), Terminatory (prostokąty) i Przepływów (strzałki). To prostota czyni je potężnym narzędziem."
  },
  {
    "id": 260,
    "question": "Wskaż ten element dokumentacji projektowej, który zawiera zapis w postaci pseudokodu (metodyka strukturalna analizy i projektowania):",
    "options": [
      {
        "text": "specyfikacja funkcji (PSPEC - Process Specification)",
        "inline_explanation": "(opisuje logikę działania procesów elementarnych, czyli tych najniższego poziomu na diagramach DFD)",
        "correct": true
      },
      {
        "text": "opis wymagań niefunkcjonalnych",
        "inline_explanation": "(opisuje cechy jakościowe, rzadko używa pseudokodu)",
        "correct": false
      },
      {
        "text": "opis wymagań funkcjonalnych",
        "inline_explanation": "(opisuje co system ma robić, zazwyczaj w języku naturalnym)",
        "correct": false
      },
      {
        "text": "opis celu przedsięwzięcia projektowego",
        "inline_explanation": "(wysokopoziomowy opis biznesowy)",
        "correct": false
      }
    ],
    "explanation": "W analizie strukturalnej diagramy DFD dekomponuje się do momentu uzyskania procesów elementarnych (primitive processes). Ich wnętrze (logikę) opisuje się wtedy w tzw. Specyfikacji Procesu (PSPEC), używając pseudokodu, tablic decyzyjnych lub języka ustrukturalizowanego."
  },
  {
    "id": 261,
    "question": "Który element DFD w metodyce strukturalnej stanowi podstawę konstruowania ERD (Entity Relationship Diagram) - diagramu związków encji?",
    "options": [
      {
        "text": "magazyn danych (data store)",
        "inline_explanation": "(magazyn danych na DFD reprezentuje dane spoczynkowe, które w modelu danych stają się encjami/tabelami)",
        "correct": true
      },
      {
        "text": "przepływ danych (data flow)",
        "inline_explanation": "(reprezentuje przesyłanie informacji, a nie jej strukturę trwałego składowania)",
        "correct": false
      },
      {
        "text": "diagram kontekstowy",
        "inline_explanation": "(określa granice systemu)",
        "correct": false
      },
      {
        "text": "obiekt zewnętrzny",
        "inline_explanation": "(jest poza systemem, więc nie wchodzi w skład bazy danych systemu)",
        "correct": false
      }
    ],
    "explanation": "Istnieje ścisłe powiązanie między modelem funkcji (DFD) a modelem danych (ERD). To, co na DFD jest 'magazynem' (np. 'Kartoteka Klientów'), na diagramie ERD staje się encją ('Klient')."
  },
  {
    "id": 262,
    "question": "Zaznacz, które stwierdzenia odnoszące się do studium realizowalności (wykonalności/feasibility study) są prawdziwe:",
    "options": [
      {
        "text": "studium realizowalności musi udzielać odpowiedzi na pytania 'Czy system przyczyni się do realizacji ogólnych celów przedsiębiorstwa?' i 'Czy może być zintegrowany z innymi, już będącymi w użyciu?'",
        "inline_explanation": "(to tzw. wykonalność operacyjna i strategiczna)",
        "correct": true
      },
      {
        "text": "studium realizowalności musi zawierać wskazanie technologii, jakie będą zastosowane podczas realizacji projektu",
        "inline_explanation": "(na tym etapie jest za wcześnie na szczegółowe decyzje technologiczne)",
        "correct": false
      },
      {
        "text": "studium realizowalności ma na celu zaplanowanie końcowego budżetu przedsięwzięcia projektowego",
        "inline_explanation": "(zawiera jedynie szacunki zgrubne potrzebne do decyzji biznesowej, a nie finalny budżet)",
        "correct": false
      },
      {
        "text": "po wykonaniu studium realizowalności zawsze następuje faza określania i analizowania wymagań",
        "inline_explanation": "(nie zawsze - jeśli wynik studium jest negatywny, projekt jest anulowany)",
        "correct": false
      }
    ],
    "explanation": "Studium wykonalności to krótka, wstępna analiza mająca odpowiedzieć na pytanie 'Go/No-go?'. Analizuje aspekty: techniczne (czy się da?), ekonomiczne (czy się opłaca?) i operacyjne (czy to nam potrzebne?)."
  },
  {
    "id": 263,
    "question": "Zaznacz, które z poniższych stwierdzeń dotyczących modelu przyrostowego są prawdziwe:",
    "options": [
      {
        "text": "kolejność realizacji i integracji przyrostów zostaje ustalona na początku projektu, przy określaniu ważności poszczególnych usług",
        "inline_explanation": "(najważniejsze funkcjonalności są realizowane w pierwszych przyrostach)",
        "correct": true
      },
      {
        "text": "w trakcie realizacji danego przyrostu wymagania w odniesieniu do przypisanej do niego funkcjonalności systemu są zamrożone, ale prowadzi się analizę wymagań dla pozostałych przyrostów",
        "inline_explanation": "(np. w Scrumie - podczas sprintu nie zmienia się jego zakresu, ale Backlog Produktu może żyć)",
        "correct": true
      },
      {
        "text": "w każdym przyroście musi być realizowana funkcjonalność w obrębie jednego podsystemu",
        "inline_explanation": "(przyrost może dotyczyć wielu podsystemów, realizując przekrojowy scenariusz użycia)",
        "correct": false
      },
      {
        "text": "tworzenie przyrostowe polega na podzieleniu procesu na pewną sztywną liczbę etapów",
        "inline_explanation": "(liczba przyrostów często wynika dynamicznie z postępów prac)",
        "correct": false
      }
    ],
    "explanation": "Model przyrostowy zakłada dostarczanie działającego oprogramowania w częściach. Kluczowe jest to, że raz rozpoczęty przyrost (np. Sprint) ma stały zakres, co pozwala zespołowi skupić się na pracy, podczas gdy reszta wymagań może ewoluować."
  },
  {
    "id": 264,
    "question": "Ewolucyjne tworzenie oprogramowania w wariancie projektowania eksploracyjnego (badawczego):",
    "options": [
      {
        "text": "polega na systematycznym ulepszaniu utworzonej na początku wersji systemu, przez stopniowe dodawanie cech proponowanych przez klienta, aż do uzyskania zadowalającej go wersji systemu",
        "inline_explanation": "(iteracyjne dochodzenie do rozwiązania poprzez ciągły feedback)",
        "correct": true
      },
      {
        "text": "charakteryzuje się opartym o systematyczną współpracę z klientem, przyrostowym wypracowywaniem specyfikacji produktu",
        "inline_explanation": "(specyfikacja nie jest gotowa na początku, lecz wyłania się w trakcie prac)",
        "correct": true
      },
      {
        "text": "jest realizacją przedsięwzięcia w kolejności od najsłabiej do najlepiej rozpoznanych części systemu",
        "inline_explanation": "(zazwyczaj zaczyna się od części najlepiej zrozumianych lub najbardziej krytycznych)",
        "correct": false
      },
      {
        "text": "bywa nazywane metodą przyrostową",
        "inline_explanation": "(metoda przyrostowa zakłada, że wiemy co budujemy, tylko dzielimy to na etapy; metoda ewolucyjna zakłada, że odkrywamy co budujemy w trakcie)",
        "correct": false
      }
    ],
    "explanation": "Podejście ewolucyjne/eksploracyjne stosuje się tam, gdzie wymagania są trudne do zdefiniowania z góry. System 'rośnie' wraz ze zrozumieniem problemu przez programistów i klienta."
  },
  {
    "id": 265,
    "question": "Skrajny wariant ewolucyjnego tworzenia oprogramowania zwany 'metodą studencką' ('code and fix'), charakteryzujący się brakiem dokumentacji i selektywnym testowaniem:",
    "options": [
      {
        "text": "nadaje się do realizacji oprogramowania 'jednorazowego użytku'",
        "inline_explanation": "(np. skrypty, prototypy do wyrzucenia)",
        "correct": true
      },
      {
        "text": "może być używany do przygotowywania wersji demonstracyjnych i treningowych",
        "inline_explanation": "(szybkie demo, które nie musi być stabilne ani bezpieczne)",
        "correct": true
      },
      {
        "text": "może być wykorzystywany do tworzenia bardzo rzadko używanych komponentów wielkich systemów",
        "inline_explanation": "(niebezpieczne podejście - każdy element dużego systemu musi być utrzymywalny)",
        "correct": false
      },
      {
        "text": "nie może być stosowany jako metoda tworzenia prototypów przeznaczonych do porzucenia",
        "inline_explanation": "(właśnie do tego nadaje się najlepiej)",
        "correct": false
      }
    ],
    "explanation": "Metoda 'zmarszczy brwi i napisz kod' jest akceptowalna tylko wtedy, gdy kod nie będzie musiał być utrzymywany, rozwijany ani integrowany z poważnym systemem. W inżynierii oprogramowania jest to antywzorzec procesu dla systemów produkcyjnych."
  },
  {
    "id": 266,
    "question": "Zaletami prowadzenia transmisji w trybie pełnego dupleksu (Full-Duplex) w standardzie Ethernet są:",
    "options": [
      {
        "text": "całkowita likwidacja kolizji w segmencie sieci",
        "inline_explanation": "(w pełnym dupleksie nadawanie i odbiór odbywają się na osobnych parach przewodów, a połączenie jest punkt-punkt ze switchem, więc mechanizm CSMA/CD i kolizje przestają istnieć)",
        "correct": true
      },
      {
        "text": "możliwość dwukrotnego zwiększenia sumarycznej przepustowości transmisji",
        "inline_explanation": "(np. dla łącza 1 Gb/s mamy 1 Gb/s w górę i 1 Gb/s w dół jednocześnie)",
        "correct": true
      },
      {
        "text": "brak ograniczenia długości medium transmisyjnego w segmencie warstwy fizycznej wynikającego z wymogów protokołu CSMA/CD",
        "inline_explanation": "(skoro nie ma CSMA/CD, nie ma wymogu 'szczeliny czasu' na wykrycie kolizji, co znosi limit odległości wynikający z czasu propagacji; pozostaje tylko limit tłumienia sygnału)",
        "correct": true
      },
      {
        "text": "możliwości wykorzystania urządzeń hub",
        "inline_explanation": "(koncentratory (huby) działają wyłącznie w trybie Half-Duplex, współdzieląc medium)",
        "correct": false
      }
    ],
    "explanation": "Tryb Full-Duplex to standard we współczesnych sieciach przełączanych (switched Ethernet). Dzięki wyeliminowaniu współdzielenia medium (jak w koncentratorach) i detekcji kolizji, sieć działa wydajniej i na większe odległości (szczególnie widoczne przy światłowodach)."
  },
  {
    "id": 267,
    "question": "Model odniesienia OSI/ISO:",
    "options": [
      {
        "text": "określa zadania poszczególnych warstw",
        "inline_explanation": "(definiuje CO dana warstwa ma robić, np. warstwa 3 odpowiada za routing)",
        "correct": true
      },
      {
        "text": "pozwala na niezależny rozwój sprzętu i oprogramowania w ramach poszczególnych warstw",
        "inline_explanation": "(dzięki enkapsulacji i standardowym interfejsom zmiana technologii w warstwie fizycznej nie wymaga zmiany przeglądarki internetowej)",
        "correct": true
      },
      {
        "text": "jest modelem czterowarstwowym",
        "inline_explanation": "(model OSI ma 7 warstw; 4 warstwy ma model TCP/IP)",
        "correct": false
      },
      {
        "text": "definiuje standardy w ramach każdej warstwy (np. protokół IP w warstwie sieciowej)",
        "inline_explanation": "(model OSI to model referencyjny/teoretyczny; konkretne protokoły jak IP 'wpisują się' w niego, ale nie są jego definicją)",
        "correct": false
      }
    ],
    "explanation": "Model OSI (Open Systems Interconnection) składa się z 7 warstw: 1. Fizycznej, 2. Łącza Danych, 3. Sieci, 4. Transportowej, 5. Sesji, 6. Prezentacji, 7. Aplikacji."
  },
  {
    "id": 268,
    "question": "Osiągnięcie przepustowości $1 \\text{ Gb/s}$ na kablu UTP kategorii 5e (tym samym, który jest używany w transmisji $100 \\text{ Mb/s}$) w standardzie Ethernet (1000BASE-T) jest:",
    "options": [
      {
        "text": "możliwe dzięki wykorzystaniu do transmisji wszystkich czterech par",
        "inline_explanation": "(Fast Ethernet 100Mb/s używa tylko 2 par; Gigabit Ethernet używa wszystkich 4 par dwukierunkowo)",
        "correct": true
      },
      {
        "text": "możliwe dzięki wykorzystaniu bardziej złożonego kodowania",
        "inline_explanation": "(zastosowano kodowanie PAM-5, które koduje 2 bity w jednym symbolu na każdej parze)",
        "correct": true
      },
      {
        "text": "nie jest możliwe - wymaga kabla o lepszych parametrach",
        "inline_explanation": "(kabel Cat 5e jest wystarczający dla 1 Gb/s na odległość do 100m)",
        "correct": false
      },
      {
        "text": "nie jest możliwe - taką przepustowość można osiągnąć tylko używając światłowodu",
        "inline_explanation": "(miedź obsługuje nawet 10 Gb/s na krótkich dystansach)",
        "correct": false
      }
    ],
    "explanation": "Standard 1000BASE-T osiągnął gigabitową prędkość na 'starych' kablach dzięki zaawansowanej obróbce sygnału (DSP), wykorzystaniu wszystkich 4 par przewodów jednocześnie w obu kierunkach (z układami usuwającymi echa) oraz wielopoziomowemu kodowaniu PAM-5."
  },
  {
    "id": 269,
    "question": "Kodowanie sygnałów w transmisji w sieciach komputerowych:",
    "options": [
      {
        "text": "wpływa na uzyskiwaną przepustowość",
        "inline_explanation": "(efektywne kodowanie pozwala przesłać więcej bitów w jednym hercu pasma)",
        "correct": true
      },
      {
        "text": "jest zależne od wykorzystywanego medium",
        "inline_explanation": "(inne kodowanie stosuje się w światłowodzie, inne w skrętce miedzianej, inne w WiFi)",
        "correct": true
      },
      {
        "text": "może pozwalać na osiągnięcie samosynchronizacji nadajnika i odbiornika",
        "inline_explanation": "(np. kod Manchester czy 4B5B zapewnia częste zmiany stanu sygnału, co pozwala odbiornikowi synchronizować zegar)",
        "correct": true
      },
      {
        "text": "jest przedmiotem zainteresowania warstwy sieciowej modelu OSI/ISO",
        "inline_explanation": "(kodowanie to domena warstwy 1 - fizycznej)",
        "correct": false
      }
    ],
    "explanation": "Warstwa fizyczna odpowiada za zamianę bitów na sygnały (elektryczne, optyczne, radiowe). Sposób tej zamiany to kodowanie liniowe (np. NRZ, Manchester, PAM)."
  },
  {
    "id": 270,
    "question": "Istnienie ograniczenia maksymalnej odległości między komunikującymi się hostami wynika z:",
    "options": [
      {
        "text": "w ramach jednego segmentu sieci: wymogów protokołu warstwy łącza danych",
        "inline_explanation": "(w starszych sieciach z CSMA/CD sygnał musiał zdążyć dotrzeć do końca segmentu i wrócić przed końcem nadawania najmniejszej ramki, aby wykryć kolizję)",
        "correct": true
      },
      {
        "text": "w ramach jednego segmentu sieci: parametrów medium fizycznego",
        "inline_explanation": "(tłumienie sygnału, dyspersja - fizyka ogranicza zasięg)",
        "correct": true
      },
      {
        "text": "w ramach jednego segmentu sieci: wymogów protokołu warstwy sieciowej",
        "inline_explanation": "(IP nie interesuje się fizyczną długością kabla)",
        "correct": false
      },
      {
        "text": "w ramach kilku segmentów sieci rozdzielonych przełącznicami: wymogów protokołu warstwy sieciowej",
        "inline_explanation": "(TTL w pakiecie IP ogranicza liczbę skoków, ale nie fizyczną odległość w metrach)",
        "correct": false
      }
    ],
    "explanation": "Ograniczenia zasięgu mają dwojakie podłoże: fizyczne (sygnał zanika) oraz logiczne (warstwa 2 i timingi protokołów dostępu do medium). Switche i routery 'regenerują' sygnał i ramy czasowe, pozwalając na budowę rozległych sieci."
  },
  {
    "id": 271,
    "question": "Które z wymienionych funkcji realizuje warstwa łącza danych (Data Link Layer) modelu OSI/ISO?",
    "options": [
      {
        "text": "dostarczenie adresacji fizycznej",
        "inline_explanation": "(adresy MAC)",
        "correct": true
      },
      {
        "text": "detekcja kolizji w medium transmisyjnym",
        "inline_explanation": "(mechanizmy podwarstwy MAC, np. w CSMA/CD)",
        "correct": true
      },
      {
        "text": "definicja strategii dostępu do łącza",
        "inline_explanation": "(decydowanie, kto i kiedy może nadawać)",
        "correct": true
      },
      {
        "text": "umożliwienie definiowania adresacji logicznej",
        "inline_explanation": "(adresy logiczne IP to warstwa 3 - sieciowa)",
        "correct": false
      }
    ],
    "explanation": "Warstwa 2 dzieli się na dwie podwarstwy: LLC (Logical Link Control) i MAC (Media Access Control). To właśnie MAC odpowiada za adresowanie fizyczne i dostęp do medium."
  },
  {
    "id": 272,
    "question": "Wirtualne sieci lokalne (VLAN):",
    "options": [
      {
        "text": "można definiować w oparciu o adresy fizyczne",
        "inline_explanation": "(przypisanie MAC do VLANu)",
        "correct": true
      },
      {
        "text": "mogą być rozpięte na wielu urządzeniach warstwy drugiej modelu OSI/ISO",
        "inline_explanation": "(dzięki tagowaniu ramek 802.1Q VLAN może obejmować wiele switchy)",
        "correct": true
      },
      {
        "text": "wyznaczają domenę rozgłoszeniową",
        "inline_explanation": "(każdy VLAN to osobna domena broadcastowa, co ogranicza zbędny ruch)",
        "correct": true
      },
      {
        "text": "poprawiają bezpieczeństwo sieci",
        "inline_explanation": "(separują ruch różnych grup użytkowników)",
        "correct": true
      },
      {
        "text": "można definiować w oparciu o adresy logiczne",
        "inline_explanation": "(rzadsze, ale możliwe - VLAN oparty na podsieci IP)",
        "correct": true
      },
      {
        "text": "stanowią mechanizm alternatywny dla budowy drzewa rozpinającego",
        "inline_explanation": "(STP działa niezależnie, a nawet per VLAN (PVST))",
        "correct": false
      },
      {
        "text": "stanowią podstawowy mechanizm zapobiegania przeciążeniom mostka",
        "inline_explanation": "(nie to jest ich głównym celem)",
        "correct": false
      }
    ],
    "explanation": "VLAN to logiczny podział sieci na poziomie warstwy 2. Pozwala grupować urządzenia niezależnie od ich fizycznego podpięcia, zwiększając bezpieczeństwo i wydajność poprzez ograniczenie domen rozgłoszeniowych."
  },
  {
    "id": 273,
    "question": "Algorytm budowy drzewa rozpinającego (STA - Spanning Tree Algorithm):",
    "options": [
      {
        "text": "jest stosowany w przypadku mostków uczących się (switchy)",
        "inline_explanation": "(wszystkie zarządzealne switche obsługują STP)",
        "correct": true
      },
      {
        "text": "służy zapobieżeniu występowania zapętleń transmisji ramek",
        "inline_explanation": "(pętle w warstwie 2 są zabójcze dla sieci - powodują burze rozgłoszeniowe)",
        "correct": true
      },
      {
        "text": "jest jednym ze sposobów elekcji głównego routera w sieci",
        "inline_explanation": "(wybiera Root Bridge (most główny), a nie router)",
        "correct": false
      },
      {
        "text": "służy zrównoważeniu obciążenia pomiędzy łączami o takich samych przepustowościach",
        "inline_explanation": "(STP blokuje nadmiarowe łącza, więc de facto uniemożliwia proste równoważenie obciążenia; dopiero MSTP/LACP na to pozwalają)",
        "correct": false
      }
    ],
    "explanation": "Protokół STP (Spanning Tree Protocol) wykrywa pętle w topologii sieci i logicznie blokuje wybrane porty, tworząc strukturę drzewa (wolną od pętli). W przypadku awarii głównego łącza, STP automatycznie odblokowuje łącze zapasowe."
  },
  {
    "id": 274,
    "question": "Które warstwy modelu OSI/ISO są różne dla sieci WAN i LAN?",
    "options": [
      {
        "text": "fizyczna i łącza danych",
        "inline_explanation": "(W tych warstwach definiowane są standardy medium i ramki, które różnią się dla Ethernetu (LAN) i np. MPLS/Frame Relay/światłowodów (WAN))",
        "correct": true
      },
      {
        "text": "fizyczna i sieci",
        "inline_explanation": "(warstwa sieciowa (IP) jest wspólna - to ona spaja Internet)",
        "correct": false
      },
      {
        "text": "łącza danych i sieci",
        "inline_explanation": "(warstwa sieci jest ta sama)",
        "correct": false
      },
      {
        "text": "fizyczna, łącza danych i sieci",
        "inline_explanation": "(warstwa 3 jest niezależna od medium)",
        "correct": false
      }
    ],
    "explanation": "Zadaniem warstwy sieciowej (3) jest abstrakcja od warstwy sprzętowej. Dzięki temu pakiet IP wygląda tak samo, niezależnie od tego, czy podróżuje przez sieć lokalną (Ethernet), czy przez łącze transoceaniczne. Różnice technologiczne występują w warstwach niższych (1 i 2)."
  },
  {
    "id": 275,
    "question": "Opisz, do czego jest wykorzystywany protokół ARP (Address Resolution Protocol):",
    "options": [
      {
        "text": "określenie odwzorowania między adresami warstwy 3 i 2 modelu OSI/ISO",
        "inline_explanation": "(tłumaczenie adresu logicznego IP na fizyczny adres MAC)",
        "correct": true
      },
      {
        "text": "uzyskania adresu IP",
        "inline_explanation": "(do tego służy DHCP lub dawniej RARP)",
        "correct": false
      },
      {
        "text": "uzyskania adresu MAC urządzenia spoza naszej sieci lokalnej",
        "inline_explanation": "(ARP działa tylko w obrębie domeny rozgłoszeniowej; dla urządzeń zdalnych ARP zwraca MAC bramy domyślnej/routera, a nie urządzenia docelowego)",
        "correct": false
      },
      {
        "text": "wyznaczania ścieżki pakietu",
        "inline_explanation": "(to zadanie protokołów routingu i narzędzi typu traceroute)",
        "correct": false
      }
    ],
    "explanation": "Protokół ARP służy do mapowania adresów IP na adresy MAC w sieciach lokalnych. Gdy komputer chce wysłać pakiet do innego IP w tej samej sieci, wysyła zapytanie rozgłoszeniowe 'Kto ma ten adres IP?', a właściciel odsyła swój adres MAC."
  },
  {
    "id": 276,
    "question": "Jeżeli dwie stacje znajdujące się w innych sieciach IP połączone są ze sobą dokładnie jednym routerem i chcą komunikować się ze sobą, to:",
    "options": [
      {
        "text": "wymagane jest ustawienie na każdej stacji adresu IP",
        "inline_explanation": "(warunek absolutnie konieczny do komunikacji w sieci IP)",
        "correct": true
      },
      {
        "text": "obydwie stacje muszą posiadać jednakową maskę",
        "inline_explanation": "(nie muszą, każda sieć może mieć inną wielkość/maskę)",
        "correct": false
      },
      {
        "text": "musi być uruchomiony mechanizm Proxy ARP na routerze",
        "inline_explanation": "(nie jest to konieczne, jeśli stacje mają poprawnie skonfigurowaną bramę domyślną)",
        "correct": false
      },
      {
        "text": "na routerze konieczne jest dodanie pozycji routingu statycznego",
        "inline_explanation": "(skoro router jest połączony bezpośrednio z obiema sieciami, trasy te są w jego tablicy jako 'Connected' - routing statyczny nie jest potrzebny)",
        "correct": false
      }
    ],
    "explanation": "Jest to najprostszy scenariusz routingu (inter-VLAN routing lub routing między interfejsami). Router zna obie sieci, bo jest do nich podpięty. Hosty muszą mieć unikalne adresy IP i wskazywać router jako bramę domyślną."
  },
  {
    "id": 277,
    "question": "Protokół IP w wersji 4 (IPv4) posiada następujące cechy:",
    "options": [
      {
        "text": "pozwala na fragmentację pakietów w węzłach pośrednich i u nadawcy",
        "inline_explanation": "(jeśli pakiet jest większy niż MTU łącza, router może go podzielić na mniejsze fragmenty)",
        "correct": true
      },
      {
        "text": "umożliwia kontrolę nagłówka pakietu za pomocą sumy kontrolnej",
        "inline_explanation": "(Header Checksum - weryfikuje tylko nagłówek, nie dane)",
        "correct": true
      },
      {
        "text": "umożliwia komunikację priorytetową",
        "inline_explanation": "(pole ToS - Type of Service / DSCP)",
        "correct": true
      },
      {
        "text": "zawiera mechanizmy potwierdzania doręczenia pakietów",
        "inline_explanation": "(IP jest protokołem bezpołączeniowym i niegwarantowanym; potwierdzenia to rola TCP)",
        "correct": false
      },
      {
        "text": "jest protokołem połączeniowym",
        "inline_explanation": "(jest bezpołączeniowy - każdy pakiet może iść inną drogą)",
        "correct": false
      },
      {
        "text": "jest zawodny, ale każda utrata pakietu jest sygnalizowana",
        "inline_explanation": "(jest 'best-effort'; przy przeciążeniu pakiety są odrzucane bez powiadomienia nadawcy przez sam protokół IP)",
        "correct": false
      },
      {
        "text": "posiada płaską adresację",
        "inline_explanation": "(adresacja jest hierarchiczna: sieć -> podsieć -> host)",
        "correct": false
      }
    ],
    "explanation": "IPv4 to protokół warstwy 3, działający na zasadzie 'best effort' (najlepszych starań). Nie gwarantuje dostarczenia, ale oferuje mechanizmy takie jak fragmentacja, suma kontrolna nagłówka czy oznaczanie priorytetu (QoS)."
  },
  {
    "id": 278,
    "question": "W jakich przypadkach jest stosowany protokół ICMP (Internet Control Message Protocol)?",
    "options": [
      {
        "text": "uzyskiwania informacji o konfiguracji sieci",
        "inline_explanation": "(np. komunikaty Router Advertisement, Redirect)",
        "correct": true
      },
      {
        "text": "sygnalizacji sytuacji awaryjnych",
        "inline_explanation": "(np. Destination Unreachable, Time Exceeded - gdy pakiet nie może dotrzeć do celu)",
        "correct": true
      },
      {
        "text": "transmisji danych wysokopiorytetowych",
        "inline_explanation": "(ICMP to protokół sterujący, nie służy do przesyłania danych użytkownika)",
        "correct": false
      },
      {
        "text": "wyszukiwania odbiorców ruchu multicastowego",
        "inline_explanation": "(do tego służy protokół IGMP)",
        "correct": false
      }
    ],
    "explanation": "ICMP to 'mechanik' protokołu IP. Służy do diagnostyki (ping, traceroute) oraz zgłaszania błędów (np. gdy router odrzuci pakiet, bo wygasł jego czas życia)."
  },
  {
    "id": 279,
    "question": "Jaki mechanizm uniemożliwia nieskończone krążenie ramek/pakietów IP w sieci w przypadku wystąpienia pętli routingu?",
    "options": [
      {
        "text": "pole TTL (Time To Live)",
        "inline_explanation": "(licznik w nagłówku IP, zmniejszany o 1 przez każdy router; gdy osiągnie 0, pakiet jest niszczony)",
        "correct": true
      },
      {
        "text": "mechanizm split-horizon",
        "inline_explanation": "(zapobiega pętlom w protokołach routingu Distance Vector, ale nie usuwa pakietów już krążących)",
        "correct": false
      },
      {
        "text": "mechanizm trigger-update",
        "inline_explanation": "(służy szybszej konwergencji routingu)",
        "correct": false
      },
      {
        "text": "NAT",
        "inline_explanation": "(tłumaczenie adresów)",
        "correct": false
      },
      {
        "text": "STP",
        "inline_explanation": "(zapobiega pętlom w warstwie 2 - Ethernet, a nie IP)",
        "correct": false
      }
    ],
    "explanation": "Pętle w warstwie 3 są nieuniknione w momentach zmian w sieci (zanim tablice routingu się zaktualizują). Mechanizm TTL gwarantuje, że zapętlony pakiet 'umrze' po określonej liczbie skoków, zamiast zapychać łącze w nieskończoność."
  },
  {
    "id": 280,
    "question": "Parametr 'niezawodność łącza' (reliability) wchodzi w skład metryki protokołu routingu:",
    "options": [
      {
        "text": "EIGRP (Enhanced Interior Gateway Routing Protocol)",
        "inline_explanation": "(używa złożonej metryki opartej na przepustowości, opóźnieniu, obciążeniu i niezawodności)",
        "correct": true
      },
      {
        "text": "IGRP (Interior Gateway Routing Protocol)",
        "inline_explanation": "(poprzednik EIGRP, używał tych samych parametrów)",
        "correct": true
      },
      {
        "text": "RIPv2",
        "inline_explanation": "(używa tylko liczby skoków - hop count)",
        "correct": false
      },
      {
        "text": "OSPF",
        "inline_explanation": "(używa kosztu opartego na przepustowości)",
        "correct": false
      }
    ],
    "explanation": "Protokoły firmy Cisco (IGRP/EIGRP) wykorzystują tzw. wartości K do obliczania metryki. Choć domyślnie biorą pod uwagę tylko przepustowość i opóźnienie, można skonfigurować je tak, by uwzględniały niezawodność łącza."
  },
  {
    "id": 281,
    "question": "Protokół TCP (Transmission Control Protocol):",
    "options": [
      {
        "text": "może grupować dane otrzymane do wysłania w celu zoptymalizowania wykorzystania połączeń sieciowych",
        "inline_explanation": "(Algorytm Nagle'a - zapobiega wysyłaniu dużej liczby mikroskopijnych pakietów, czekając na uzbieranie większej porcji danych)",
        "correct": true
      },
      {
        "text": "zezwala na wspólne potwierdzenie wielu przesłanych segmentów",
        "inline_explanation": "(Cumulative ACK - potwierdzenie o numerze N oznacza, że odebrano poprawnie wszystkie bajty do N-1)",
        "correct": true
      },
      {
        "text": "wymaga osobnego potwierdzenia każdego otrzymanego segmentu",
        "inline_explanation": "(nie wymaga, używa potwierdzeń skumulowanych)",
        "correct": false
      },
      {
        "text": "używa algorytmu Nagle'a w celu zapewnienia kontroli przepływu danych",
        "inline_explanation": "(Nagle służy poprawie efektywności/zmniejszeniu nagłówków; kontrolę przepływu realizuje mechanizm Okna Przesuwnego (Sliding Window))",
        "correct": false
      }
    ],
    "explanation": "TCP to protokół strumieniowy, który dba o wydajność sieci. Algorytm Nagle'a zapobiega 'syndromowi małych pakietów' (np. wysyłaniu 1 bajta danych w 40-bajtowym nagłówku), a mechanizm skumulowanych potwierdzeń redukuje ruch powrotny."
  },
  {
    "id": 282,
    "question": "Protokół UDP (User Datagram Protocol):",
    "options": [
      {
        "text": "stosuje porty jako adresy warstwy transportowej",
        "inline_explanation": "(podobnie jak TCP, używa 16-bitowych numerów portów do identyfikacji procesu/usługi)",
        "correct": true
      },
      {
        "text": "nie zabezpiecza przed duplikacją i zmianą kolejności datagramów",
        "inline_explanation": "(jest protokołem bezpołączeniowym i niegwarantowanym - aplikacja musi sama o to zadbać, jeśli tego potrzebuje)",
        "correct": true
      },
      {
        "text": "wprowadza mechanizmy fragmentacji dla danych użytkownika przekraczających maksymalny rozmiar datagramu UDP",
        "inline_explanation": "(UDP nie fragmentuje strumienia danych jak TCP; aplikacja musi dostarczyć dane mieszczące się w jednym datagramie/MTU)",
        "correct": false
      },
      {
        "text": "pozwala na grupowanie danych otrzymanych do wysłania w celu zoptymalizowania wykorzystania połączeń sieciowych",
        "inline_explanation": "(brak mechanizmów typu algorytm Nagle'a; wysyła dane natychmiast)",
        "correct": false
      }
    ],
    "explanation": "UDP to lekki protokół transportowy. Oferuje multipleksację (porty) i weryfikację integralności nagłówka (suma kontrolna), ale nie zapewnia niezawodności, kolejności ani kontroli przepływu. Jest idealny do streamingu i gier online."
  },
  {
    "id": 283,
    "question": "Adres typu broadcast (rozgłoszeniowy) dla sieci IPv4, w której znajduje się host $110.104.1.10$ i którą określa maska $255.0.0.0$ (/8), to:",
    "options": [
      {
        "text": "110.255.255.255",
        "inline_explanation": "(Maska /8 oznacza, że pierwszy oktet to sieć, a pozostałe trzy to host. Adres broadcast ma same jedynki w części hosta: 110.11111111.11111111.11111111)",
        "correct": true
      },
      {
        "text": "110.104.1.0",
        "inline_explanation": "(to byłby adres sieci dla maski /24)",
        "correct": false
      },
      {
        "text": "110.104.1.255",
        "inline_explanation": "(to byłby broadcast dla maski /24)",
        "correct": false
      }
    ],
    "explanation": "Aby obliczyć adres broadcast, bierzemy adres sieci (część sieciowa bez zmian, część hosta wyzerowana) i zamieniamy wszystkie bity w części hosta na 1. Dla sieci 110.0.0.0/8 daje to 110.255.255.255."
  },
  {
    "id": 284,
    "question": "Pole o nazwie Time To Live (TTL) w datagramie IP, które zabezpiecza przed zapętleniem routowania datagramu pomiędzy kolejnymi routerami w sieci, zawiera:",
    "options": [
      {
        "text": "liczbę routerów (skoków), przez jakie datagram IP może zostać przekazany dalej",
        "inline_explanation": "(każdy router dekrementuje tę wartość o 1; przy 0 pakiet jest odrzucany)",
        "correct": true
      },
      {
        "text": "czas w sekundach, w którym datagram IP można jeszcze przekazywać dalej",
        "inline_explanation": "(historycznie w specyfikacji były to sekundy, ale w praktyce od zawsze oznacza to liczbę skoków - hop limit)",
        "correct": false
      }
    ],
    "explanation": "TTL to mechanizm bezpieczeństwa w warstwie 3. Gdyby go nie było, błędna konfiguracja routingu (pętla) spowodowałaby, że pakiety krążyłyby w nieskończoność, zapychając łącza."
  },
  {
    "id": 285,
    "question": "Protokół UDP definiuje identyfikatory przesyłanych do hosta-odbiorcy datagramów zwane numerami portów, o długości w bitach:",
    "options": [
      {
        "text": "16",
        "inline_explanation": "(co daje zakres od 0 do 65535)",
        "correct": true
      },
      {
        "text": "32",
        "inline_explanation": "(długość adresu IPv4)",
        "correct": false
      },
      {
        "text": "8",
        "inline_explanation": "(jeden bajt)",
        "correct": false
      },
      {
        "text": "4",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Numery portów są 16-bitowymi liczbami całkowitymi bez znaku. Porty 0-1023 to tzw. Well Known Ports (zarezerwowane dla usług systemowych)."
  },
  {
    "id": 286,
    "question": "Wartości adresu IPv6 oraz maski, określające wszystkie hosty w internecie (trasa domyślna / default route), to:",
    "options": [
      {
        "text": "::/0",
        "inline_explanation": "(odpowiednik 0.0.0.0/0 w IPv4)",
        "correct": true
      },
      {
        "text": "::/2000",
        "inline_explanation": "(blok adresów Global Unicast)",
        "correct": false
      },
      {
        "text": "2000::/3",
        "inline_explanation": "(zakres adresów publicznych udostępnionych przez IANA)",
        "correct": false
      }
    ],
    "explanation": "Zapis `::/0` oznacza adres o długości prefixu 0 bitów, czyli pasuje do każdego adresu docelowego. Jest używany w tablicach routingu jako trasa domyślna (gateway of last resort)."
  },
  {
    "id": 287,
    "question": "Istnienie zasady 'Longest prefix match' w routingu IP spowoduje, że adres docelowy $200.200.200.1$ przy istnieniu w tablicy routingu reguł: $200.200.200.0/18$, $200.200.200.0/20$, $200.200.200.0/22$, $200.200.200.0/24$ zostanie dopasowany do:",
    "options": [
      {
        "text": "200.200.200.0/24",
        "inline_explanation": "(router zawsze wybiera trasę najbardziej precyzyjną, czyli taką, która ma najdłuższą maskę/prefiks pasującą do adresu docelowego)",
        "correct": true
      },
      {
        "text": "200.200.200.0/18",
        "inline_explanation": "(pasuje, ale jest zbyt ogólna)",
        "correct": false
      },
      {
        "text": "200.200.200.0/20",
        "inline_explanation": "(pasuje, ale jest mniej precyzyjna niż /24)",
        "correct": false
      },
      {
        "text": "200.200.200.0/22",
        "inline_explanation": "(pasuje, ale jest mniej precyzyjna niż /24)",
        "correct": false
      }
    ],
    "explanation": "Zasada najdłuższego dopasowania (Longest Prefix Match) to fundamentalna reguła routingu IP. Router szuka w tablicy wpisu, który ma najwięcej bitów zgodnych z adresem docelowym (największa wartość po ukośniku CIDR)."
  },
  {
    "id": 288,
    "question": "Maksymalna długość pakietu IP w wersji 4, licząc w bajtach, to:",
    "options": [
      {
        "text": "65535",
        "inline_explanation": "(pole 'Total Length' w nagłówku IP ma 16 bitów, więc $2^{16} - 1 = 65535$ bajtów)",
        "correct": true
      },
      {
        "text": "1500",
        "inline_explanation": "(to standardowe MTU dla Ethernetu, a nie limit protokołu IP)",
        "correct": false
      },
      {
        "text": "576",
        "inline_explanation": "(to minimalna wielkość pakietu, którą każdy host musi być w stanie odebrać bez fragmentacji)",
        "correct": false
      },
      {
        "text": "1025",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Choć protokół IP pozwala na pakiety do 64KB (65535 bajtów), w praktyce są one ograniczone przez warstwę łącza danych (MTU), np. w Ethernecie do 1500 bajtów. Większe pakiety muszą zostać podzielone (pofragmentowane)."
  },
  {
    "id": 289,
    "question": "Router iBGP (internal BGP), którego wprowadzenie do systemu rutowania iBGP umożliwia znaczne zredukowanie ilości otwartych sesji BGP między innymi routerami (rezygnację z tzw. full-mesh) nosi nazwę:",
    "options": [
      {
        "text": "Route Reflector (RR) / Route Reflector Client (RRC)",
        "inline_explanation": "(Route Reflector to router, który przekazuje (odbija) trasy od swoich klientów do innych peerów iBGP, łamiąc regułę 'nie przekazuj tras od iBGP do iBGP')",
        "correct": true
      },
      {
        "text": "BGP Mirror",
        "inline_explanation": "(nie ma takiej funkcji w standardzie BGP)",
        "correct": false
      }
    ],
    "explanation": "W standardowym iBGP każdy router musi mieć sesję z każdym innym (siatka pełna $N*(N-1)/2$). Route Reflector pozwala na strukturę gwiazdy, drastycznie zmniejszając liczbę potrzebnych połączeń TCP."
  },
  {
    "id": 290,
    "question": "Liczba klas CoS (Class of Service), definiowanych przez podstawowy mechanizm implementacji QoS (Quality of Service) w Ethernet (czyli standard IEEE 802.1p / pole PCP w 802.1Q), to:",
    "options": [
      {
        "text": "8",
        "inline_explanation": "(pole priorytetu ma 3 bity, co daje $2^3 = 8$ poziomów priorytetu, od 0 do 7)",
        "correct": true
      },
      {
        "text": "7",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "255",
        "inline_explanation": "(tyle klas ma pole DSCP w IPv4 - 8 bitów, choć w praktyce używa się 6 bitów -> 64 klasy)",
        "correct": false
      },
      {
        "text": "16",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Standard 802.1p (część 802.1Q odpowiedzialna za VLAN tagging) rezerwuje 3 bity w nagłówku ramki Ethernet na priorytet. Pozwala to na zdefiniowanie 8 klas ruchu, np. Voice (najwyższy), Video, Best Effort (domyślny), Background (najniższy)."
  },
  {
    "id": 291,
    "question": "Wariant protokołu STP (Spanning Tree Protocol), pozwalający w technologii Ethernet na logiczne pogrupowanie sieci VLAN i budowanie mniejszej liczby drzew rozpinających (po 1 drzewie dla każdej grupy/instancji) to:",
    "options": [
      {
        "text": "MSTP (Multiple Spanning Tree Protocol)",
        "inline_explanation": "(standard IEEE 802.1s - pozwala zmapować np. 100 VLANów na 2 instancje STP, oszczędzając zasoby procesora)",
        "correct": true
      },
      {
        "text": "PVSTP (Per VLAN Spanning Tree Protocol)",
        "inline_explanation": "(tworzy oddzielne drzewo dla każdego VLANu, co przy dużej ich liczbie mocno obciąża sieć)",
        "correct": false
      },
      {
        "text": "RSTP (Rapid Spanning Tree Protocol)",
        "inline_explanation": "(przyspiesza konwergencję, ale nie grupuje VLANów w instancje)",
        "correct": false
      },
      {
        "text": "SPB (Shortest Path Bridging)",
        "inline_explanation": "(technologia alternatywna dla STP)",
        "correct": false
      }
    ],
    "explanation": "MSTP rozwiązuje problem skalowalności protokołu PVST (gdzie każdy VLAN ma swoje drzewo) i ograniczeń CST (jedno drzewo dla wszystkich). Pozwala administratorowi ręcznie pogrupować VLANy w instancje (np. VLANy parzyste w jednej instancji, nieparzyste w drugiej) i utrzymywać tylko kilka drzew STP."
  },
  {
    "id": 292,
    "question": "Nazwa procesu przekazywania wiedzy o trasach pomiędzy różnymi protokołami rutowania dynamicznego IP (np. między OSPF a BGP) w routerach IP, to:",
    "options": [
      {
        "text": "redystrybucja (redistribution)",
        "inline_explanation": "(proces 'wstrzykiwania' tras z jednego źródła routingu do drugiego)",
        "correct": true
      },
      {
        "text": "IP Route Spoofing",
        "inline_explanation": "(spoofing to fałszowanie adresu nadawcy, atak sieciowy)",
        "correct": false
      }
    ],
    "explanation": "Redystrybucja jest niezbędna w dużych sieciach, gdzie np. część wewnętrzna działa na OSPF, a styk z internetem na BGP. Router graniczny bierze trasy z BGP i ogłasza je wewnątrz sieci OSPF (i odwrotnie)."
  },
  {
    "id": 293,
    "question": "Co określa standard IEEE 802.1Q?",
    "options": [
      {
        "text": "wirtualne sieci LAN (VLAN) budowane w środowisku transportującym ramki",
        "inline_explanation": "(standard tagowania ramek Ethernet identyfikatorem VLAN ID)",
        "correct": true
      },
      {
        "text": "Private VLAN nadbudowana nad Ethernet",
        "inline_explanation": "(PVLAN to funkcja bezpieczeństwa (izolacja portów), a nie sam standard 802.1Q)",
        "correct": false
      },
      {
        "text": "technologię tunelowania sieci VLAN o nazwie Q-in-Q",
        "inline_explanation": "(to standard 802.1ad)",
        "correct": false
      }
    ],
    "explanation": "Standard 802.1Q polega na wstawieniu dodatkowego, 4-bajtowego nagłówka do ramki Ethernet, który zawiera m.in. 12-bitowy identyfikator VLAN (VID). Pozwala to na przesyłanie ruchu wielu sieci logicznych jednym fizycznym łączem (trunk)."
  },
  {
    "id": 294,
    "question": "Protokół umożliwiający konwersję adresu IP zdalnej stacji na jej adres MAC w Ethernet, to:",
    "options": [
      {
        "text": "ARP (Address Resolution Protocol)",
        "inline_explanation": "(mapowanie warstwy 3 (IP) na warstwę 2 (MAC))",
        "correct": true
      },
      {
        "text": "MLD (Multicast Listener Discovery)",
        "inline_explanation": "(odpowiednik IGMP dla IPv6)",
        "correct": false
      },
      {
        "text": "SLIP (Serial Line Internet Protocol)",
        "inline_explanation": "(stary protokół dla łączy szeregowych, poprzednik PPP)",
        "correct": false
      }
    ],
    "explanation": "Gdy host chce wysłać pakiet, zna IP docelowe, ale karta sieciowa potrzebuje adresu fizycznego (MAC), by zbudować ramkę. ARP wysyła zapytanie 'Kto ma IP X?' i otrzymuje odpowiedź z adresem MAC."
  },
  {
    "id": 295,
    "question": "Dwie pod-warstwy definiowane w ramach warstwy drugiej (łącza danych) modelu ISO-OSI to odpowiednio:",
    "options": [
      {
        "text": "LLC (Logical Link Control) i MAC (Media Access Control)",
        "inline_explanation": "(LLC - 802.2, komunikuje się z warstwą sieci; MAC - 802.3/Ethernet, komunikuje się z medium fizycznym)",
        "correct": true
      },
      {
        "text": "LAN i WAN",
        "inline_explanation": "(typy sieci)",
        "correct": false
      },
      {
        "text": "FDDI i CDDI",
        "inline_explanation": "(standardy sieci pierścieniowych)",
        "correct": false
      },
      {
        "text": "LP (Link Pulse) i PHY (Physical)",
        "inline_explanation": "(pojęcia związane z warstwą fizyczną)",
        "correct": false
      }
    ],
    "explanation": "Warstwa łącza danych jest podzielona. Górna podwarstwa (LLC) jest niezależna od sprzętu i obsługuje multipleksację protokołów wyższych warstw. Dolna podwarstwa (MAC) zarządza dostępem do medium fizycznego (adresowanie fizyczne, unikanie kolizji)."
  },
  {
    "id": 296,
    "question": "Rodzaj obszaru (area) w domenie OSPF (Open Shortest Path First) nie otrzymującego żadnych informacji o zewnętrznych (external) trasach routingu OSPF to:",
    "options": [
      {
        "text": "stub area",
        "inline_explanation": "(obszar 'ślepy', do którego nie wpuszcza się tras zewnętrznych (LSA Type 5); routery w tym obszarze używają trasy domyślnej, by wyjść na zewnątrz)",
        "correct": true
      },
      {
        "text": "internal",
        "inline_explanation": "(to typ routera, a nie specjalny typ obszaru filtrujący trasy)",
        "correct": false
      },
      {
        "text": "backbone",
        "inline_explanation": "(obszar 0, który musi znać wszystkie trasy, by łączyć inne obszary)",
        "correct": false
      },
      {
        "text": "NSSA (Not-So-Stubby Area)",
        "inline_explanation": "(obszar, który pozwala na importowanie tras zewnętrznych w specyficzny sposób, więc 'coś' otrzymuje)",
        "correct": false
      }
    ],
    "explanation": "Obszary typu Stub służą do zmniejszenia tablic routingu na słabszych routerach peryferyjnych. Zamiast uczyć się tysięcy tras z Internetu, router w obszarze Stub wie tylko: 'wszystko czego nie znasz, wysyłaj do routera brzegowego (ABR)'."
  },
  {
    "id": 297,
    "question": "Parametr o nazwie 'Wielkość okna' (Window size), którego wartość przekazywana jest w datagramach potwierdzenia TCP w kierunku od odbiorcy do nadawcy ma na celu:",
    "options": [
      {
        "text": "określenie ilości danych, jakie nadawca może w danej chwili wysłać (służy do sterowania przepływem)",
        "inline_explanation": "(zapobiega zalaniu odbiorcy danymi, których nie zdąży przetworzyć)",
        "correct": true
      },
      {
        "text": "informowanie o wielkości datagramu (bufora), jaką może przyjąć host w aktualnym stanie",
        "inline_explanation": "(mechanizm Flow Control - odbiorca 'reklamuje' swoje wolne miejsce w buforze)",
        "correct": true
      },
      {
        "text": "określenie długości następnego datagramu oraz wszystkich kolejnych",
        "inline_explanation": "(nie określa długości pojedynczego pakietu, lecz sumaryczną ilość bajtów w locie)",
        "correct": false
      },
      {
        "text": "określenie ilości danych w datagramie, w którym się znajduje",
        "inline_explanation": "(wielkość danych jest w nagłówku IP, Window Size dotyczy przyszłych danych)",
        "correct": false
      }
    ],
    "explanation": "Window Size (TCP Sliding Window) to mechanizm kontroli przepływu. Odbiorca mówi nadawcy: 'Mam jeszcze X bajtów wolnego miejsca w buforze'. Nadawca może wysłać tyle danych bez czekania na kolejne potwierdzenie. Gdy bufor się zapełnia, okno maleje (nawet do 0), zmuszając nadawcę do wstrzymania transmisji."
  },
  {
    "id": 298,
    "question": "Dwa rodzaje obszarów (area) / poziomy routingu w protokole rutowania dynamicznego IS-IS, to:",
    "options": [
      {
        "text": "intra-area (Level 1) i inter-area (Level 2)",
        "inline_explanation": "(IS-IS dzieli sieć hierarchicznie na routing wewnątrzobszarowy (L1) i międzyobszarowy (L2))",
        "correct": true
      },
      {
        "text": "LAN i WAN",
        "inline_explanation": "",
        "correct": false
      },
      {
        "text": "stub i backbone",
        "inline_explanation": "(pojęcia specyficzne dla OSPF)",
        "correct": false
      },
      {
        "text": "Autonomous System i Internal System",
        "inline_explanation": "",
        "correct": false
      }
    ],
    "explanation": "Protokół IS-IS (używany często przez dostawców internetu) ma strukturę dwupoziomową. Level 1 routery znają trasy tylko w swoim obszarze. Level 2 routery tworzą szkielet (backbone) łączący obszary. Istnieją też routery L1/L2 pełniące funkcję bram."
  }
]
